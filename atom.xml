<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[大神的iOS开发博客]]></title>
  <subtitle><![CDATA[知识来源于分解]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://linfeng1009.gitcafe.io/"/>
  <updated>2015-10-28T08:02:09.000Z</updated>
  <id>http://linfeng1009.gitcafe.io/</id>
  
  <author>
    <name><![CDATA[大神]]></name>
    <email><![CDATA[1057105719@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[3D Touch实践——Quick Action]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/10/20/3D-Touch%E5%AE%9E%E8%B7%B5/"/>
    <id>http://linfeng1009.gitcafe.io/2015/10/20/3D-Touch实践/</id>
    <published>2015-10-20T07:17:25.000Z</published>
    <updated>2015-10-28T08:02:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="3D_Touch简介">3D Touch简介</h2><p>随着iOS9以及iPhone 6s和iPhone 6s plus的发布，苹果添加一种立体的用户界面:<br>用户在主屏幕上不需要打开APP，按压图标就可以快速访问APP提供的一些功能。<br>在APP内，用户按压界面就可以预览更多地内容，获得加速访问的特征。</p>
<h2 id="主屏幕Quick_Action">主屏幕Quick Action</h2><p><img src="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/maps_directions_home_2x.png" alt=""></p>
<p>快速选项(Quick Action)可以让用户预见并加速与APP交互，iOS9SDK提供的官方API可以使你定义静态或者动态的快速选项，以及检测当前设备快速选项的可用性。</p>
<p>1.定义静态快速选项选项在APP工程的<code>Info.plist</code>文件中添加<code>UIApplicationShortcutItems</code>数组。<br>2.定义动态快速选项使用<code>UIApplicationShortcutItem</code>和相关的API，然后给应用程序的共享对象<code>UIApplication</code>使用<code>shortcutItems</code>这个属性添加动态的快速选项。</p>
<h3 id="静态快速选项">静态快速选项</h3><p><code>UIApplicationShortcutItems</code>(iOS数组)给APP指定静态主屏幕的快速选项，这个键包含了一个字典数组，每个字典包含关于一个快速选项的详细信息。<br>你可以指定静态快速选项给你的APP用一个字典数组。当用户在支持3D Touch的设备上按压主屏幕图标时，在主屏幕上显示快速选项的数量是由系统决定的(只能显示4个)。<br>静态快速选项你在<code>Info.plist</code>文件中定义显示在主屏幕上以同样地顺序出现在文件中。下面是一个Demo:<br><img src="http://7xkpsz.com1.z0.glb.clouddn.com/3dtouchInfoplist.png" alt=""></p>
<p>然后的AppDelegate.m文件中添加<code>application:performActionForShortcutItem:completionHandler:</code>代理方法，根据<code>UIApplicationShortcutItem</code>的type属性和之前在info.plist设置<code>UIApplicationShortcutItemType</code>对应的在值来判断，用户点击的是哪个快速选项。这个方法当用户通过选择一条接近激活应用时就会调用，除了<code>-application:willFinishLaunchingWithOptions: or -application:didFinishLaunchingWithOptions returns NO.</code>这种情况。在<code>-application:didFinishLaunchingWithOptions</code>中可以通过<code>UIApplicationLaunchOptionsShortcutItemKey</code>键来获取当前接收快速选项的<code>UIApplicationShortcutItem</code>对象，来处理用户的意图。<br>demo运行结果:<br><img src="http://7xkpsz.com1.z0.glb.clouddn.com/3dtouchquickaction.gif" alt=""></p>
<p><img src="http://7xkpsz.com1.z0.glb.clouddn.com/D1CAC8C1-A43C-4E11-B382-96D1270FD133.png" alt=""></p>
<p>静态定义快速在运行时常用的key:<br>UIApplicationShortcutItemType (必须使用) 用来区分与其他快速选项的分类<br>UIApplicationShortcutItemTitle (必须使用) 快速选项显示的标题<br>UIApplicationShortcutItemSubtitle  快速选项显示的子标题<br>UIApplicationShortcutItemIconType  图片类型由系统提供<br>UIApplicationShortcutItemIconFile  自定义的图标<br>UIApplicationShortcutItemUserInfo  附加信息</p>
<p>Demo地址: <a href="https://github.com/ludaye123/3DTouch-Static-QuickActions.git" target="_blank" rel="external">GitHub</a></p>
<h3 id="动态快速选项">动态快速选项</h3><p>定义动态快速选项使用<code>UIApplicationShortcutItem</code>和相关的API，然后给应用程序的共享对象<code>UIApplication</code>使用<code>shortcutItems</code>这个属性添加动态的快速选项。示例代码如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupApplicationShortcutItems</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIcon</span> *homeIcon = [<span class="built_in">UIApplicationShortcutIcon</span> iconWithType:<span class="built_in">UIApplicationShortcutIconTypeCompose</span>];</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIcon</span> *messageIcon = [<span class="built_in">UIApplicationShortcutIcon</span> iconWithTemplateImageName:<span class="string">@"message"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo1 = @&#123;<span class="string">@"key"</span>:<span class="string">@"home"</span>&#125;;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo2 = @&#123;<span class="string">@"key"</span>:<span class="string">@"message"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIMutableApplicationShortcutItem</span> *homeShortcutItem = [[<span class="built_in">UIMutableApplicationShortcutItem</span> alloc] initWithType:<span class="string">@"io.gitcafe.linfeng1009.main"</span> localizedTitle:<span class="string">@"主页"</span> localizedSubtitle:<span class="string">@"跳转主页"</span> icon:homeIcon userInfo:userInfo1];</span><br><span class="line">    <span class="built_in">UIMutableApplicationShortcutItem</span> *messageShortcutItem = [[<span class="built_in">UIMutableApplicationShortcutItem</span> alloc] initWithType:<span class="string">@"io.gitcafe.linfeng1009.message"</span> localizedTitle:<span class="string">@"消息"</span> localizedSubtitle:<span class="string">@"跳转消息"</span> icon:messageIcon userInfo:userInfo2];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *items = @[homeShortcutItem,messageShortcutItem];</span><br><span class="line">    <span class="built_in">NSArray</span> *exsitItems = [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.shortcutItems</span>;</span><br><span class="line">    <span class="built_in">NSArray</span> *updateItems = [exsitItems arrayByAddingObjectsFromArray:items];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.shortcutItems</span> = updateItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果:</p>
<p><img src="http://7xkpsz.com1.z0.glb.clouddn.com/2C7B34D8-D1B0-4AEA-98D9-D4DF3C812743.png" alt=""></p>
<h3 id="动态_VS_静态快速选项">动态 VS 静态快速选项</h3><p>定义主屏幕动态快速选项使用这个类(UIApplicationShortcutItem),代码创建快速选项，并且在运行时注册它们给应用程序对象。<br>定义主屏幕静态快速在运行时用<code>UIApplicationShortcutItems</code>数组在Xcode工程的<code>info.plist</code>文件中，当你的应用被安装时系统注册静态快速选项。<br>系统限制了快速在运行时显示的数量，当用户按压主屏幕上的图标，在限制显示的快速在运行时的标题内，静态快速在运行时具有优先显示(demo中可以看出)，开始显示在列表的顶部位置。如果你的静态快速在运行时没有超过限定显示的数量，并且也动态定义了快速在运行时，那么动态创建的快速在运行时也会显示。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="3D_Touch简介">3D Touch简介</h2><p>随着iOS9以及iPhone 6s和iPhone 6s plus的发布，苹果添加一种立体的用户界面:<br>用户在主屏幕上不需要打开APP，按压图标就可以快速访问APP提供的一些功能。<br>在APP内，]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 对象解析]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/10/19/object-parse/"/>
    <id>http://linfeng1009.gitcafe.io/2015/10/19/object-parse/</id>
    <published>2015-10-19T08:31:02.000Z</published>
    <updated>2015-10-19T08:31:02.000Z</updated>
    <content type="html"><![CDATA[<p>Apple开源库: <a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">点击这里</a>，当前版本为最新版本:objc4-647.tar.gz</p>
<p><img src="http://blog.leichunfeng.com/images/object_model.png" alt=""></p>
<h2 id="Object">Object</h2><hr>
<p>在Objective-C中，除了一些基本类型外，基本上都可以称之为对象。首先从类的实例进行分析：<br>打开刚刚下载源码的工程：<br>找到objc_private.h这个文件，在文件的上面部分可以看到Class和id的定义</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到Class和id分为objc_class和objc_object类型的指针，Command+左键查看下objc_object的定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    isa_t isa;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由此可以得知，其实oc对象实质上就是一个objc_object结构体的对象，仅包含一个isa的成员变量，isa所对应的内容就是对象所属的类。id在运行时通过isa可以指向任意的oc对象。</p>
<h2 id="Class">Class</h2><hr>
<p>对象发送一个消息时，所需的数据和方法都是由其所属类提供的，类描述了对象占用空间大小，成员变量的类型以及描述对象的行为。实质就是对象发送消息以及所需的数据是通过isa找到其所属的类，类来提供其对象所需的一切。<br>类的定义如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="keyword">uint32_t</span> info;</span><br><span class="line">    <span class="keyword">uint32_t</span> instance_size;</span><br><span class="line">    <span class="keyword">struct</span> old_ivar_list *ivars;</span><br><span class="line">    <span class="keyword">struct</span> old_method_list **methodLists;</span><br><span class="line">    Cache cache;</span><br><span class="line">    <span class="keyword">struct</span> old_protocol_list *protocols;</span><br><span class="line">    <span class="comment">// CLS_EXT only</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ivar_layout;</span><br><span class="line">    <span class="keyword">struct</span> old_class_ext *ext;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  more</span></span><br><span class="line">    	...</span><br><span class="line">   <span class="comment">// more</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在类的定义中，可以得出类实质上也是对象，它也包含isa成员变量，成员变量列表，方法列表以及协议列表。<br>那么类对象的isa对应的值又是什么呢？ 带着个这个问题继续。</p>
<h2 id="Meta_Class">Meta Class</h2><hr>
<p>通过上面类的定义得知类其实也是对象，既然是对象那就有对应的所属类，这个类称之为元类(Meta Class)，元类保存了静态方法列表。<br>我们在创建一个对象时，经常会使用某个类调用alloc或者new方法，例如[UIView new],给类对象发送一个new消息，和对象发送消息一样，类对象也要通过其isa找到对应的所属类，去查找响应的方法。<br>那么问题来了？元类是不是也是对象呢？ 没错，元类也是对象，叫做元类对象，那么它的isa对应的所属类又是什么？元类对象对应的所属类叫做根元类(Root Meta Class)。那么根元类理所当然也是一个对象，isa对应的值就是其本身。至于元类，在开发中并不能显示的调用而且也没用必要。</p>
<h2 id="总结">总结</h2><hr>
<p>1.类的对象发送消息时，根据isa找到其所属类，然后从类提供的方法去查找，如果当前类找不到，再从其父类中查找，直到找到，否则异常(不能识别方法)。<br>2.类对象发送消失时，根据isa找到元类，然后从元类提供的方法去查找，如果当前类找不到，在从其父类中查找，直到找到，否则异常。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Apple开源库: <a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">点击这里</a>，当前版本为最新版本:objc4-647.tar.gz</p>
<p]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/10/13/git-commad/"/>
    <id>http://linfeng1009.gitcafe.io/2015/10/13/git-commad/</id>
    <published>2015-10-13T07:23:24.000Z</published>
    <updated>2015-10-13T07:23:24.000Z</updated>
    <content type="html"><![CDATA[<p>1.初始化仓库 git init<br>2.添加文件到仓库<br>    git add <file><br>    git commit</file></p>
<p>3.查看仓库当前分支状态 git status<br>4.对比文件  git diff <file><br>5.查看提交记录 git log<br>6.查看命令记录 git reflog<br>7.回滚到上一个版本 git reset —hard HEAD^ 上上个版本git reset —hard HEAD^^<br>8.回滚到上20个版本 git reset —hard HEAD~20<br>9.修改了工作区文件，想放弃修改 git checkout — <file><br>10.修改了工作区文件，摒弃commit到缓存区，想放弃修改<br>  git reset HEAD <file><br>  git checkout — <file><br>11.添加到缓存区的文件<br>    rm <file><br>    工作区和版本库不一致<br>    两个选择<br>    从版本库中删除: git rm <file> ,git commit -m “说明”<br>    恢复文件: git checkout — <file><br>12.添加远程库 git remote add origin 仓库地址<br>远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来<br>之后推送使用 git push origin master， 拉取文件 git pull origin master<br>13.克隆远程库 git clone 仓库地址<br>14.查看分支 git branch (-a 包括远程分支)<br>15.创建分支 git branch <name><br>16.切换分支 git checkout <name><br>17.创建并切换分支 git checkout -b <name><br>18.在当前分支合并其他分支  git merge <name><br>19.删除分支 git branch -d <name><br>20.合并分支禁用Fast forward git merge —no-ff -m “合并说明” <name><br>21.保存当前工作区 git stash<br>22.查看缓存工作区列表 git stash list<br>22.恢复工作区 git stash pop<br>23.查看远程库信息 git remote -v；<br>24.本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致;建立本地分支和远程分支的关联，使用git branch —set-upstream branch-name origin/branch-name,从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</name></name></name></name></name></name></file></file></file></file></file></file></file></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1.初始化仓库 git init<br>2.添加文件到仓库<br>    git add <file><br>    git commit</file></p>
<p>3.查看仓库当前分支状态 git status<br>4.对比文件  git diff <file><br]]>
    </summary>
    
      <category term="Git" scheme="http://linfeng1009.gitcafe.io/tags/Git/"/>
    
      <category term="Git" scheme="http://linfeng1009.gitcafe.io/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIStackView Tutorial:介绍堆栈视图(译)]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/10/08/stack-view/"/>
    <id>http://linfeng1009.gitcafe.io/2015/10/08/stack-view/</id>
    <published>2015-10-08T09:54:03.000Z</published>
    <updated>2015-10-19T09:03:01.000Z</updated>
    <content type="html"><![CDATA[<p>英文原文: <a href="http://www.raywenderlich.com/114552/uistackview-tutorial-introducing-stack-views" target="_blank" rel="external">UIStackView Tutorial: Introducing Stack Views</a></p>
<p>我们都在那里，有个新的需求，你需要在运行时添加或者移除一个视图，并且也需要调整邻近的视图的位置。<br>你采用什么方法？你给约束添加输出口在故事板上这样你就能激活或者禁用某些吗?或者你使用第三方库？或根据复杂性也许你能在代码中做一切。<br>也许这次你的视图层次没有必要在运行时改变，但是你必须考虑如何把一个新视图嵌入到你的故事板。你有没有最终只是清除所有的约束并从头开始重新添加它们，因为它比执行复杂的约束操作更加容易吗？<br>随着UIStackView的引入，上面的任务变得非常简单。堆栈视图提供一种水平或者垂直布局多个视图方式。通过配置一些简单的属性，例如: <code>alignment</code>,<code>distribution</code>和<code>spacing</code>.你可以定义包含的视图如何去调整自己可用的空间。</p>
<h2 id="开始">开始</h2><p>在这篇UIStackView的引导，你运行的APP叫做<code>Vacation Spots</code>.它是一个简单的APP,向你展示一个为了摆脱烦恼的地名的列表。<br>但是不要收拾包裹就走人，因为这里有一些问题你将通过使用堆栈视图来修复，比你单独使用自动布局更加简单的一种方式.<br>开始下载<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip" target="_blank" rel="external">初始工程</a>作为引导，运行它在iPhone6模拟器上，你将看到你可能去度假的地名列表.<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/01-table-view-is-now-correct_750x1334-281x500.png" alt=""><br>去London的信息界面通过点击London单元.<br>初略一看，这个视图好像没什么问题，但是它有一些问题.<br>1.看到视图底部的排列的按钮.它们之间当前的位置有一个固定的空间值，所以它们没有适配屏幕的宽度。为了全面的看到问题，临时旋转模拟器屏幕到横屏方向通过按下Command和left按键(左方向箭头).<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/02-issues-visible-in-landscape-view_1334x750-480x270.png" alt=""><br>2.点击靠近<code>WEATHER</code>的<code>Hide</code>按钮，成功隐藏文字，但是没有重新调整它下面部分的位置，留下一块空白空间。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/03-hide-weather-issue_750x1334-281x500.png" alt=""><br>3.每节段的顺序能够改善，将会有更多逻辑，如果<code>what to see</code>这部分位置放置到<code>why visit</code>这部分后面，在<code>weather</code>它们之间。<br>4.底部的按钮有点太靠近视图底部边缘在横屏模式下。最好是如果你可以减少不同部分之间的间距——但只有在横向模式。</p>
<p>现在,你有一个想法你会做改善,是时候进入这个项目。<br>打开<code>Main.storyboard</code>并且查看<code>Spot Info View Controller</code>场景，有一些颜色在你的堆栈视图中。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/04-colorful-scene-in-storyboard_504x636-396x500.png" alt=""></p>
<p>这些标签和按钮已经设置了各种背景颜色在运行时会被清除。在故事板中，它们简单的可视帮助显示如何改变堆视图的各种属性从而影响内嵌视图的结构.<br>你现在不需要这样做,但是如果在任何时候你想看到背景颜色在运行应用程序时,可以暂时注释掉以下行在 SpotInfoViewController内的viewDidLoad方法。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clear background colors from labels and buttons</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">view</span> <span class="keyword">in</span> backgroundColoredViews &#123;</span><br><span class="line">  <span class="keyword">view</span>.backgroundColor = UIColor.clearColor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，任意输出口连接的标签有占位符文本，那些设置的输出口变量的名称为了使它们连接。这使得更简单告诉标签将更新它们的文本在运行时。例如，标签随着文本<whyvisitlabel>被连接为：</whyvisitlabel></p>
<pre><code><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> whyVisitLabel: <span class="type">UILabel</span>!
</code></pre><p>需要注意的另一件事是，故事板的场景不是默认600x600的方块当使用size classes.<br>size classes一直可用，但初始导航控制器的大小设置为iPhone 4英寸以下模拟指标部分在属性检查器。这一点容易使用故事板;模拟指标属性在运行时没有任何影响——视图将为不同的设备调整。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/05-simulated-metrics-iphone-4-inch_639x173.png" alt=""></p>
<h2 id="你的第一个堆视图">你的第一个堆视图</h2><hr>
<p>第一件事你将通过使用堆视图修复底部排列按钮之间的空隙。堆栈视图可以分发其视图沿其轴以不同的方式,与等量的方法之一是每个视图之间的间距。<br>幸运地是，嵌入已存在的视图到新堆视图中并不是火箭科学。首先，选择所有的按钮底部的位置<code>Spot Info View Controller</code>场景通过点击一个,然后按住Command键点击另外两个:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/06-select-bottom-row-of-buttons_420x80.png" alt=""><br>如果大纲视图不是已经打开,继续打开它通过显示文档大纲按钮左下角的画布:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/07-document-outline-button_120x40.png" alt=""><br>验证所有三个按钮选择通过检查他们的大纲视图:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/08-verify-button-selection_360x90.png" alt=""><br>他们并不都是选择,你也可以在大纲视图命令点击每个按钮来选择他们。一旦选中,单击新的堆栈按钮底部的工具栏自动布局正确的故事板的画布上:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/09-stack_button_outlined_148x52.png" alt=""><br>这些按钮将被嵌入新的堆栈视图中:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/10-bottom-row-is-now-in-stack-view_640x100.png" alt=""><br>这些按钮现在整齐彼此连靠着-你很快就会解决。<br>虽然堆栈视图负责定位按钮,但是你还需要添加自动布局约束位置堆栈视图本身。<br>嵌入一个视图在堆栈视图时,约束其他视图删除。例如,嵌入在堆栈视图按钮之前,<code>Submit Rating</code>按钮的顶部有一个垂直间距约束连接它的底部<code>Rating</code>标签:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/11-prior-constraint_420x90.png" alt=""><br>点击<code>Submit Rating</code>按钮,它不再有任何约束附加到它:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/12-no-more-constraints_400x80.png" alt=""><br>验证约束消失的另一种方法是通过查看尺寸检查器(⌥⌘5):<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/13-check-size-inspector_640x80.png" alt=""><br>为了约束添加到堆栈视图本身,您首先需要选择。在故事板中选择一个堆栈视图很棘手,如果其视图完全填满堆栈视图。一个简单的方法是在大纲视图选择堆栈视图:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/14-stack-view-document-outline-selection_660x80.png" alt=""><br>另一个技巧是按住Shift键和右键单击任何堆栈视图的视图,或者Control-Shift-click如果你使用触控板。你会得到一个上下文菜单,显示了视图层次结构在你点击的位置,和你只是选择堆栈视图菜单中点击它。现在,选择堆栈视图使用Shift-Right-click方法:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/15-select-stack-view-in-view-hierarchy-menu_400x280.png" alt=""><br>现在，点击Pin按钮在自动布局工具栏上给它添加约束:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/16-pin-button_142x57.png" alt=""><br>First add a check to Constrain to margins. Then add the following constraints to the edges of your stack view:<br>首先添加一个检查约束边缘。然后添加以下约束你的边缘堆栈视图:</p>
<pre><code><span class="string">Top:</span> <span class="number">20</span>, <span class="string">Leading:</span> <span class="number">0</span>, <span class="string">Trailing:</span> <span class="number">0</span>, <span class="string">Bottom:</span> <span class="number">0</span>
</code></pre><p>仔细检查上面的数字,上下左右的约束,确保焊接层选择。然后点击添加4约束:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/17-bottom-stack-view-constraints_264x364.png" alt=""><br>堆栈的视图是正确的大小,但它已经扩大了第一个按钮填充任何额外的空间:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/18-first-button-is-stretched_400x80.png" alt=""><br>属性决定了一个堆栈视图列出了其观点沿轴分布性质。目前,它的设置来填补,这意味着所包含的视图将完全填补堆栈视图沿其轴。为此,堆栈视图只会扩大它的一个视图来填补这一额外的空间,具体地说,它扩展了视图内容紧凑优先级最低的水平,或者如果所有优先级相等,它扩展了第一个视图。<br>然而,你不是寻找按钮完全填满堆栈视图——你希望他们是等距的。确保堆栈视图仍然选择和属性检查器。改变填充等于间距的分布:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/19-change-distribution-to-equal-spacing_640x148.png" alt=""><br>现在编译和运行,点击任何单元,旋转模拟器(⌘→)。你会发现底部按钮现在空间本身同样!<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/20-now-buttons-are-equally-spaced_1334x750-480x270.png" alt=""><br>为了解决这个问题不使用堆栈视图,您将不得不使用间隔的视图,每一对按钮之间。你必须添加等宽约束到所有的间隔的视图以及大量的额外约束。<br>它会看起来像下面这样。为了在截图中可见,间隔的视图有一个浅灰色背景:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/21-alternate-solution-1_346x76.png" alt=""><br>这不是太多的问题如果你只有这一次的故事板,但许多视图是动态的。这不是一个简单的任务在运行时来添加一个新按钮或隐藏或删除现有的按钮，由于相邻间隔视图和约束，为了隐藏一个视图在堆栈视图,所有你要做的就是设置包含视图的隐藏属性为true和堆栈视图处理其余的。这就是你会修理间隔在<code>WEATHER</code>下面标签当用户隐藏文本。您将在本教程稍后做一旦天气部分标签添加到一个堆栈视图。</p>
<h2 id="转化部分">转化部分</h2><hr>
<p>你会把所有的其他部分在SpotInfoViewController使用堆栈视图。这将使您可以轻松地完成剩下的任务。接下里你将转化评级部分。</p>
<h3 id="评级部分">评级部分</h3><p>正如上面你刚刚创建堆栈视图，选择旁边的<code>Rating</code>标签和<code>Star</code>标签:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/22-select-rating-label-and-stars-label_640x74.png" alt=""><br>然后单击栈上的按钮来将它们嵌入在堆栈视图:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/23-after-clicking-stack-button_640x74.png" alt=""><br>现在点击Pin按钮，勾选<code>Constrain to margins</code>并且添加下面三个约束:<br>Top: 20, Leading: 0, Bottom: 20<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/24-add-second-stack-view-constraints_264x171.png" alt=""><br>现在去属性检查器设置间隔为8:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/25-set-spacing-to-8_259x87.png" alt=""><br>有可能你会看到一个错误的观点警告,看到这样<code>stars</code>标签已经超出界限的视图:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/26-stars-label-weirdly-stretched_640x85.png" alt=""><br>有时Xcode可能暂时显示警告或堆栈视图位置不正确,但警告将会消失,你让其他更新。您通常可以忽略这些。然而,立即修复它,你能说服堆栈视图布局通过将其框架由一个点和背部或临时改变它的一个布局属性。为了说明这一点,改变从填补顶部对齐,然后回到填补。现在你会看到星星标签位置正确:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/27-change-alignment-to-top-and-back_640x85.png" alt=""><br>构建和运行验证一切看起来和之前一模一样。</p>
<h3 id="取消嵌入堆栈视图">取消嵌入堆栈视图</h3><p>在你走得太远之前,最好有一些基本的“急救”培训。有时你可能会发现自己与你不再需要额外的堆栈视图,可能是因为实验、重构或只是偶然。幸运的是,有一个简单的方法来从堆栈视图unembed视图。首先,你要选择你想要删除的堆栈视图。然后按住Option键,点击栈上的按钮。在出现的上下文菜单中点击Unembed:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/28-how-to-unembed_186x71.png" alt=""><br>另一个方法是选择堆栈视图,然后从菜单中选择Editor\ Unembed。</p>
<h3 id="你的第一个垂直堆栈视图">你的第一个垂直堆栈视图</h3><p>现在，你将创建你的第一个垂直堆栈视图，选择<code>WHY VISIT</code>标签和<code>&lt;whyVisitLabel&gt;</code>如下:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/29-select-why-visit-labels_640x90.png" alt=""><br>Xcode将正确推断,这应该是一个垂直堆栈视图基于标签的位置。单击堆栈按钮嵌入这两个堆栈视图:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/30-embed-why-visit-labels_640x90.png" alt=""><br>较低的标签以前约束将视图的右边距,但约束时被嵌入在堆栈视图。目前,堆栈视图没有约束,所以采用的固有宽度最大的视图。<br>随着堆栈视图被选择，点击Pin按钮，勾选<code>Constrain to margins</code>,设置上，左和右的约束为0.<br>然后,单击下拉底部约束和选择<code>WEATHER</code>(当前距离=20)：<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/31-dont-select-nearest-neighbor-constraint_463x417.png" alt=""><br>默认情况下,显示最近的邻居的约束,这为约束隐藏按钮底部的距离15。你真需要约束下面的<code>WEATHER</code>标签。最后,点击 Add 4 Constraints。您现在应该看到如下:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/32-why-visit-stack-view-stretched_640x90.png" alt=""><br>您现在有了一个扩展堆栈视图右边固定在右边距的视图。然而,底部标签还是一样的宽度。你会解决这个问题通过更新堆栈视图对齐属性。</p>
<h2 id="对齐属性">对齐属性</h2><hr>
<p>对齐属性决定了一个堆栈视图列出了其视图垂直于轴。垂直堆栈视图,可能的值<code>Fill</code>,<code>Leading</code>、<code>Center</code>和<code>Trailing</code>。可能水平堆栈视图对齐值略有不同:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/33-horizontal-and-vertical-alignment_594x171.png" alt=""><br><code>.Top</code>代替<code>.Leading</code>,<code>Bottom</code>代替<code>.Trailing</code>,也有两个属性,只在水平方向上是有效的。<code>.FirstBaseline</code>, <code>.LastBaseline</code>。<br>选择每个值,看看它如何影响标签的位置垂直堆栈视图:<br>Fill:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/34-alignment-fill_640x64.png" alt=""><br>Leading:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/35-alignment-leading_640x64.png" alt=""><br>Center:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/36-alignment-center_640x64.png" alt=""><br>Trailing:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/37-alignment-trailing_640x64.png" alt=""><br>当你完成测试每个值,设置对齐来填充:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/38-now-select-alignment-fill_640x64.png" alt=""><br>然后构建和运行验证一切看起来不错,没有退化。</p>
<p>指定<code>Fill</code>意味着你想要的所有视图完全填满堆栈视图垂直于它的轴。这导致<code>WHY VISIT</code>标签来扩大自己的右边缘。<br>但如果你只想要底部标签扩大自身优势?<br>现在,没关系因为标签在运行时将有一个透明的背景,但它将很重要当你转化<code>weather</code>部分时。<br>您将了解如何完成,使用一个额外的堆栈视图。</p>
<h2 id="转化WHAT_TO_SEE部分">转化WHAT TO SEE部分</h2><hr>
<p>这个部分非常类似于前面,所以这里的说明是短暂的。<br>1.首先，选择<code>WHAT TO SEE</code>标签和下面的<code>&lt;whatToSeeLabel&gt;</code><br>2.点击堆栈按钮<br>3.点击Pin按钮<br>4.勾选<code>Constrain to margin</code>,并且添加下面四个约束:<br>Top: 20, Leading: 0, Trailing: 0, Bottom: 20<br>5.设置堆栈视图的对齐方式为Fill<br>你的故事板现在看起来应该是这样的:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/39-after-what-to-see-section_640x308.png" alt=""><br>构建和运行验证一切看起来仍然一样。<br>这使得你只有<code>WEATHER</code>部分了。</p>
<h2 id="转化WEATHER部分">转化WEATHER部分</h2><p>WEATHER部分比其他部分更加复杂，由于包含隐藏按钮。<br>一种方法你可以用将创建一个嵌套的堆栈视图通过将天气标签和隐藏按钮嵌入到一个水平堆栈视图,然后嵌入水平堆栈视图和<code>&lt;weatherInfoLabel&gt;</code>垂直堆栈视图。<br>看起来像这样的:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/40-weather-stack-in-stack_640x92.png" alt=""><br>注意<code>WEATHER</code>标签已经扩大到等于<code>Hide</code>按钮的高度。这并不是理想的方法,因为这将导致基线之间的有额外的空间<code>WEATHER</code>标签和它下面的文本。<br>记住,<code>alignment</code>指定定位垂直堆栈视图。所以,你可以设置<code>alignment</code>到<code>Bottom</code>:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/41-weather-stack-in-stack-alignment-bottom_640x92.png" alt=""><br>但你真的不想<code>Hide</code>按钮的高度决定堆栈视图的高度。<br>您将实际的方法是有<code>Hide</code>按钮不会在天气的堆栈视图部分,或任何其他堆栈视图。<br>它仍将是一个顶层视图的子视图,您将添加一个约束<code>WEATHER</code>标签——这将会在堆栈视图。没错,你会从一个按钮添加一个约束之外的一个堆栈视图标签在一个堆栈视图!<br>选择<code>WEATHER</code>标签和它下面的<code>&lt;weatherInfoLabel&gt;</code>：<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/42-select-weather-and-info-label_640x92.png" alt=""><br>点击堆栈按钮:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/43-weather-click-stack-button_640x92.png" alt=""><br>点击Pin按钮，勾选<code>Constrain to margins</code>，添加下面四个约束:<br>Top: 20, Leading: 0, Trailing: 0, Bottom: 20<br>设置堆栈视图的对齐方式为Fill:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/44-weather-alignment-fill_640x92.png" alt=""><br>你需要<code>Hide</code>按钮的左边缘和<code>WEATHER</code>标签的右边缘之间的约束,因此天气标签填补堆栈视图不能工作。<br>但是,你希望<code>&lt;weatherInfoLabel&gt;</code>填补堆栈底部视图<br>。你可以做到这一点通过嵌入<code>WEATHER</code>标签到垂直堆栈视图。记住,一个垂直堆栈视图的一致性可以设置<code>.Leading</code>,如果堆栈视图是超出其内在的宽度,其包含的视图仍将是其主要方面保持一致。<br>选择<code>WEATHER</code>标签使用文档大纲,或通过使用Control-Shift-click方法:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/45-select-just-the-weather-label_640x92.png" alt=""><br>然后点击堆栈按钮:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/46-weather-in-horizontal-stack_640x92.png" alt=""><br>设置<code>Alignment</code>为<code>Leading</code>,确保<code>Axis</code>设置为<code>Vertical</code>：<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/47-vertical-and-leading_640x92.png" alt=""><br>很完美!你有外堆栈视图拉伸内部堆栈视图来填补宽度,但内部堆栈视图允许标签保持原来的宽度!<br>构建和运行。为什么是闲逛的<code>Hide</code>按钮在文本中间呢?<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/48-hide-label-incorrect-position_750x573-419x320.png" alt=""><br>这是因为当你嵌入天气标签在堆栈视图,和它之间的任何约束,<code>Hide</code>按钮被移除。<br>添加新的约束从隐藏按钮<code>control - drag``WEATHER</code>标签:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/49-drag-to-weather-label_380x94.png" alt=""><br>然后按住Shift选择多个选项,并选择水平间距和基线。然后点击添加约束:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/50-add-multiple-constraints_380x224.png" alt=""><br>构建和运行。隐藏按钮现在应该正确定位,因为被设置为隐藏的标签是嵌入在一个堆栈视图,紧迫的隐藏隐藏标签,并调整它下面的视图-—一切无需手动调整任何约束。<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/51-hide-button-works_750x732-328x320.png" alt=""><br>现在所有的部分都是独特的堆栈视图,你将它们嵌入到外部堆栈视图,这将使最后的两个任务微不足道。</p>
<h2 id="顶层堆栈视图">顶层堆栈视图</h2><hr>
<p>命令点击选择所有五个顶级堆栈视图在大纲视图:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/52-select-all-stack-views-in-outline_640x260.png" alt=""><br>然后点击堆栈按钮:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/53-stack-all-the-views_640x185.png" alt=""><br>点击Pin按钮，勾选<code>Constrain to margins</code>,添加所有边缘的约束为0。设置<code>Spacing</code>为20，<code>Alignment</code>为<code>Fill</code>,你的故事板场景看起来像这样:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/54-set-the-spacing-to-20-and-alignment-to-fill_640x300.png" alt=""><br>编译运行:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/55-hide-button-lost-again_750x487-480x312.png" alt=""><br>哎呀!看起来<code>Hide</code>按钮再次失去了约束当<code>WEATHER</code>堆栈视图是嵌入在外层堆栈视图。没问题,再加上约束以同样的方式。<br>从<code>Hide</code>按钮<code>control - drag``WEATHER</code>标签,然后按住<code>Shift</code>,选择水平间距和基线。然后点击添加约束:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/56-add-constraints-to-button-again_380x223.png" alt=""><br>编译运行，<code>Hide</code>按钮现在的位置是正确的。</p>
<h2 id="重新定位视图">重新定位视图</h2><hr>
<p>现在,所有的部分都是在一个顶级堆栈视图中,您将修改<code>WHAT TO SEE</code>部分的位置到<code>WEATHER</code>部分上面。<br>从大纲视图选择中间堆栈视图,并将其拖动到第一和第二的视图之间。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:保持堆栈的指针稍微往左视图之间你拖动它,这样它仍然是一个外堆栈视图的子视图。蓝色小圆应该定位在两个堆栈视图之间的左边缘,而不是在正确的边缘:</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/57-drag-and-drop-to-reposition-section_639x130.png" alt=""><br>现在<code>WEATHER</code>部分是第三节从顶部起,但自从<code>Hide</code>按钮不是堆栈视图的一部分,它不会被移动,所以它的结构将会错位。<br>点击<code>Hide</code>按钮选择它:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/58-hide-button-not-moved_640x130.png" alt=""><br>然后单击解决自动布局问题中的三角形形状的按钮自动布局工具栏和下所选视图部分,点击update frame:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/59-resolve-auto-layout-issues_356x269.png" alt=""><br><code>Hide</code>按钮将会返回正确的位置:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/60-hide-button-back-to-correct-position_640x130.png" alt=""><br>很好，用自动布局重新定位视图和重新添加约束就不会是你做过的最困难的事。</p>
<h2 id="Size_Class基本配置">Size Class基本配置</h2><hr>
<p>最后,你就可以把注意力转移到一个剩余的任务列表。在横屏模式中,垂直空间是非常珍贵的,所以你想将堆栈视图的部分更紧密地联系在一起。要做到这一点,您将使用大小类顶级堆栈视图的间距设置为10,而不是20时,垂直类是紧凑的大小。<br>选择顶级堆栈视图,单击+按钮旁边的<code>Spacing</code>:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/61-select-plus-button_260x120.png" alt=""><br>选择<code>Any Width &gt; Compact Height</code>:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/62-anywidth-compact-height_403x108.png" alt=""><br>设置<code>Spacing</code>为10在新的<code>wAny hC</code>区域:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/63-set-spacing-to-10_260x160.png" alt=""><br>编译和运行。竖屏模式的间距应该保持不变。旋转模拟器(⌘←)和注意,部分减少之间的间距和按钮现在有充裕的空间从底部的视图:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/64-spacing-in-iphone-landscape_1334x750-480x270.png" alt=""><br>如果你没有添加一个顶级堆栈视图中,您仍然可以使用大小类的垂直间距设置为10的四个约束条件,单独的五个部分,但它不是更好的设置在一个地方吗?<br>你和你的时间有更好的事情要做,例如动画!</p>
<h2 id="动画">动画</h2><hr>
<p>目前,有点突兀,隐藏和显示天气信息。您将添加一些动画平滑过渡。<br>堆栈视图与UIView动画引擎完全兼容。这意味着动画安排子视图的外观/消失,很简单,其切换动画块内部隐藏的属性。<br>是时候写些代码了，打开<code>SpotInfoViewController.swift</code>看到<code>updateWeatherInfoViews(hideWeatherInfo:animated:).</code><br>你看到这个方法的尾部这行</p>
<pre><code>weatherInfoLabel<span class="class">.hidden</span> = shouldHideWeatherInfo
</code></pre><p>用下面的方法代替它:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> animated &#123;</span><br><span class="line">  UIView.animateWithDuration(<span class="number">0.3</span>) &#123;</span><br><span class="line">    self.weatherInfoLabel.<span class="variable">hidden =</span> shouldHideWeatherInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  weatherInfoLabel.<span class="variable">hidden =</span> shouldHideWeatherInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译和运行,点击隐藏或显示按钮。动画感觉不是更好?<br>除了动画隐藏的属性视图中包含堆栈视图中,您还可以动画属性堆栈视图本身,如<code>alignment</code>、<code>distribution</code>、<code>spacing</code>和<code>axis</code>。</p>
<h2 id="从这里去哪里?">从这里去哪里?</h2><p>你可以下载完成的代码<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip" target="_blank" rel="external">在这里</a><br>在这UIStackView教程中,您学到了很多关于堆栈视图以及堆栈视图使用的各种属性定位它的子视图。堆栈视图是高度可配置的,而且可能有一个以上的方式实现相同的结果。<br>最好的方法是建立在你学过的东西自己尝试各种属性。而不是设置属性和移动,请参阅玩其他属性如何影响视图中的堆栈视图的布局。<br>本教程是一个缩写版的第六章,“UIStackView和自动布局变化”和第七章“中间UIStackView”从iOS 9教程。如果你想了解更多关于UIStackView和其他新特性在iOS 9请看看这本书!<br>与此同时,如果你有任何问题或评论本教程或堆栈视图,请加入以下论坛讨论!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文原文: <a href="http://www.raywenderlich.com/114552/uistackview-tutorial-introducing-stack-views" target="_blank" rel="external">UIStackVi]]>
    </summary>
    
      <category term="iOS9" scheme="http://linfeng1009.gitcafe.io/tags/iOS9/"/>
    
      <category term="iOS翻译" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS内存管理ARC]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/09/29/memory-arc/"/>
    <id>http://linfeng1009.gitcafe.io/2015/09/29/memory-arc/</id>
    <published>2015-09-29T09:08:20.000Z</published>
    <updated>2015-09-29T09:08:20.000Z</updated>
    <content type="html"><![CDATA[<p>ARC是一个编译器的特征，提供自动内存管理对Objective-C对象。而不是必须思索<code>retain</code>和<code>release</code>操作，ARC容许你集中精力在令人有趣的代码上，这个对象图表示对象之间的关系在你的应用中。<br><img src="https://developer.apple.com/library/prerelease/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Art/ARC_Illustration.jpg" alt=""></p>
<h2 id="ARC概述">ARC概述</h2><hr>
<p>ARC可以让你没必要记住什么时候使用<code>retain</code>,<code>release</code>和<code>autorelease</code>,ARC预估对象的必要生命周期并且自动插入合适的内存管理调用方法在编译时，也会生成合适的dealloc方法。<br>一个完整正确的实现的Person类可能是这样的：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Person </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> NSString *firstName;</span><br><span class="line"><span class="variable">@property</span> NSString *lastName;</span><br><span class="line"><span class="variable">@property</span> NSNumber *yearOfBirth;</span><br><span class="line"><span class="variable">@property</span> Person *spouse;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">@implementation</span> Person</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="attribute">TODO</span>: 属性默认是Strong引用</span><br></pre></td></tr></table></figure>
<p>使用ARC，实现contrived方法</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="atom">void</span>)<span class="atom">contrived</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="name">Person</span> *<span class="atom">aPerson</span> = [[<span class="name">Person</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">    [<span class="atom">aPerson</span> <span class="atom">setFirstName</span>:@<span class="string">"William"</span>];</span><br><span class="line">    [<span class="atom">aPerson</span> <span class="atom">setLastName</span>:@<span class="string">"Dudney"</span>];</span><br><span class="line">    [<span class="atom">aPerson</span> <span class="atom">setYearOfBirth</span>:[[<span class="name">NSNumber</span> <span class="atom">alloc</span>] <span class="atom">initWithInteger</span>:<span class="number">2011</span>]];</span><br><span class="line">    <span class="name">NSLog</span>(@<span class="string">"aPerson: %@"</span>, <span class="atom">aPerson</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARC注意内存管理，所以Person和NSNumber对象都不会泄露<br>你也能够安全的实现Person类的takeLastNameFrom:方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)takeLastNameFrom:(Person *)person </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *oldLastname = [<span class="keyword">self</span> lastName];</span><br><span class="line">    [<span class="keyword">self</span> setLastName:[person lastName]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Lastname changed from %@ to %@"</span>, oldLastname, [<span class="keyword">self</span> lastName]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARC确保oldLastname在NSLog语句前不会释放</p>
<h2 id="ARC强制执行新规则">ARC强制执行新规则</h2><hr>
<p>1.你不能明确地调用<code>dealloc</code>,实现或调用<code>retain</code>,<code>release</code>,<code>retainCount</code>或<code>autorelease</code>方法，禁止扩充使用<code>@selector(retain), @selector(release)</code>等等。</p>
<p>2.你可以实现<code>dealloc</code>方法，如果你需要管理资源而不是释放实例变量，你没有必要(实际上你业不能)释放实例变量，但是你也许需要调用<code>[systemClassInstance setDelegate:nil]</code>在系统类，其实的代码使用ARC不能编译</p>
<p>3.自定义<code>dealloc</code>方法在ARC上是没有必要调用<code>[super dealloc]</code>(其实会编译错误)。父链会自动执行通过编译器。</p>
<p>4.你能一直使用<code>CFRetain</code>,<code>CFRelease</code>，和其他与CoreFoundation风格对象关联的方法。</p>
<p>5.你不能使用<code>NSAllocateObject</code>或<code>NSDeallocateObject</code>,创建对象使用<code>alloc</code>，<code>runtime</code>会关注释放对象。</p>
<p>6.你不能使用对象指针在C结构体中，你可以创建一个一个Objective-C类来管理数据</p>
<p>7.<code>id</code>和<code>void *</code>之间没有临时的角色，你必须使用指定的角色，告诉编译器关于对象的生命周期。</p>
<p>8.你不能使用<code>NSAutoreleasePool</code>对象，ARC提供<code>@autoreleasepool</code>block来代替。这种方式比<code>NSAutoreleasePool</code>效率更高。</p>
<p>9.你不能使用内存区域，再也没有必要使用<code>NSZone</code>，它们被现在的Objective-C运行时忽略</p>
<p>10.为了兼容手动<code>retain-release</code>代码，ARC强加了约束对于方法命名:<br>你不能给一个访问器的命名以<code>new</code>开头。如果声明一个属性它的命名以<code>new</code>开头，除非你指定一个不同的getter方法，否则不能正常运行。</p>
<pre><code><span class="comment">// Won't work:</span>
<span class="variable">@property</span> NSString *newTitle;

<span class="comment">// Works:</span>
<span class="variable">@property</span> (getter=theNewTitle) NSString *newTitle;
</code></pre><h2 id="ARC生命周期修饰符">ARC生命周期修饰符</h2><hr>
<p>ARC介绍几个新的生命周期修饰符给对象，一个弱引用(weak)不会延伸它所指向对象的声明周期，当没有强引用这个对象时，它会自动变为nil,合理的使用weak将帮助你确保不会创建循环引用。</p>
<h3 id="Property修饰">Property修饰</h3><p>The keywords weak and strong are introduced as new declared property attributes, as shown in the following examples.</p>
<p><code>weak</code>和<code>strong</code>关键字被引用修饰新声明的属性,如下例子所示:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的声明与 @property(retain) MyClass *myObject;同义</span></span><br><span class="line"><span class="comment">// ARC环境下，对象默认的修饰是strong</span></span><br><span class="line"><span class="variable">@property</span>(strong) MyClass *myObject;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下面的声明与 "@property(assign) MyClass *myObject;"类似</span></span><br><span class="line"><span class="comment">// 除了MyClass 实例被释放，这个属性的值被设置为nil代替保留一个悬挂指针</span></span><br><span class="line"><span class="variable">@property</span>(weak) MyClass *myObject;</span><br></pre></td></tr></table></figure>
<h3 id="变量修饰符">变量修饰符</h3><p>你可以用下面几个生命周期修饰符修饰变量:</p>
<pre><code>__<span class="keyword">strong</span>
__<span class="keyword">weak</span>
__unsafe_unretained
__autoreleasing
</code></pre><p><strong>strong是默认的，对象的一直存执，直到没有一个strong指向它。
</strong>weak指定一个引用，不会保持引用对象的生命，当没有一个strong引用所指的对象，它所引用的会被设置为nil<br><strong>unsafe_unretained 指定一个引用，不会保持引用对象的生命，当没有一个strong引用所指的对象，它所引用不会设置为nil。如果它所引用的对象被释放了，会指向一个悬挂指针(野指针)
</strong>autoreleasing 通常用来暗示参数，传递引用在返回时自动释放。</p>
<p>你应该正确修饰变量，格式如下:<br><code>ClassName * qualifier variableName;</code></p>
<p>eg:</p>
<pre><code>MyClass <span class="keyword">*</span> __weak myWeakReference;    
MyClass <span class="keyword">*</span> __unsafe_unretained myUnsafeReference;
</code></pre><p>Take care when using <strong>weak variables on the stack. Consider the following example:<br>注意当使用</strong>weak变量在栈上是，思考下面的示例:</p>
<pre><code>NSString * __weak <span class="built_in">string</span> = <span class="string">[[NSString alloc] initWithFormat:@"First Name: %@", [self firstName]]</span>;
NSLog(@<span class="string">"string: %@"</span>, <span class="built_in">string</span>);
</code></pre><p>虽然string被赋值了一个字符串对象，但是由于字符串对象没有其他强引用，因此会立刻释放，打印语句显示的内容为null</p>
<p>你也需要对象传递通过引用，下面代码能正常运行</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">BOOL</span> OK = [myObject performOperationWithError:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (!OK) &#123;</span><br><span class="line">    <span class="comment">// Report the error.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>然而，error的隐式声明为:</p>
<pre><code><span class="title">NSError</span> * __strong <span class="built_in">error</span>;
</code></pre><p>方法的声明为:</p>
<pre><code><span class="tag">-</span>(<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">performOperationWithError</span>:<span class="value">(NSError * __autoreleasing *)error</span></span>;
</code></pre><p>编译器因此会重写代码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> * __<span class="keyword">strong</span> error;</span><br><span class="line"><span class="built_in">NSError</span> * __autoreleasing tmp = error;</span><br><span class="line"><span class="built_in">BOOL</span> OK = [myObject performOperationWithError:&amp;tmp];</span><br><span class="line">error = tmp;</span><br><span class="line"><span class="keyword">if</span> (!OK) &#123;</span><br><span class="line">    <span class="comment">// Report the error.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>局部变量的声明(<strong>strong)与参数(_</strong>autoreleasing)之间不匹配造成编译器创建临时变量。你能获取原始指针通过修改声明参数(id <strong>strong *)当你获取</strong>strong变量地址事，或者是你直接声明变量为__autoreleasing</p>
<h3 id="使用生命周期修饰符来避免强应用循环">使用生命周期修饰符来避免强应用循环</h3><p>你可以使用生命周期修饰符来避免强引用循环,例如，如果你有一个图形对象安排在父子层级，并且父对象需要指向子对象，反之亦然。你让父对象与子对象强关联，子对象与父对象弱关联。其他情况可能更微妙,特别是当他们涉及block对象。</p>
<p>在MRC环境中，<strong>block id x;x的影响没有保留。在ARC环境中，</strong>block id x;默认是保留x.为了在ARC下获得MRC的行为，你可以使用<strong>unsafe_unretained </strong>block id x;正如名字<strong>unsafe_unretained </strong>block id x;所示。然而，没有保留的变量是很危险的因此不推荐，两个更好的选择是用<strong>weak或者是设置</strong>block 的值为nil打破循环引用。</p>
<p>下面的代码片段说明了这个问题使用的模式有时被用于手动引用计数。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyViewController</span> *myController = [[<span class="type">MyViewController</span> alloc] init…];</span><br><span class="line">// ...</span><br><span class="line">myController.completionHandler =  ^(<span class="type">NSInteger</span> <span class="literal">result</span>) &#123;</span><br><span class="line">   [myController dismissViewControllerAnimated:<span class="type">YES</span> completion:<span class="keyword">nil</span>];</span><br><span class="line">&#125;;</span><br><span class="line">[self presentViewController:myController animated:<span class="type">YES</span> completion:^&#123;</span><br><span class="line">   [myController release];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>你可以使用__block修饰符并且设置myController变量为空在block中</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyViewController</span> * __block myController = [[<span class="type">MyViewController</span> alloc] init…];</span><br><span class="line">// ...</span><br><span class="line">myController.completionHandler =  ^(<span class="type">NSInteger</span> <span class="literal">result</span>) &#123;</span><br><span class="line">    [myController dismissViewControllerAnimated:<span class="type">YES</span> completion:<span class="keyword">nil</span>];</span><br><span class="line">    myController = <span class="keyword">nil</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者是你可以使用一个临时的weak变量</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyViewController</span> *myController = [[<span class="type">MyViewController</span> alloc] init…];</span><br><span class="line">// ...</span><br><span class="line"><span class="type">MyViewController</span> * __weak weakMyViewController = myController;</span><br><span class="line">myController.completionHandler =  ^(<span class="type">NSInteger</span> <span class="literal">result</span>) &#123;</span><br><span class="line">    [weakMyViewController dismissViewControllerAnimated:<span class="type">YES</span> completion:<span class="keyword">nil</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于非一般的循环，你应该使用:</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyViewController</span> *myController = [[<span class="type">MyViewController</span> alloc] init…];</span><br><span class="line">// ...</span><br><span class="line"><span class="type">MyViewController</span> * __weak weakMyController = myController;</span><br><span class="line">myController.completionHandler =  ^(<span class="type">NSInteger</span> <span class="literal">result</span>) &#123;</span><br><span class="line">    <span class="type">MyViewController</span> *strongMyController = weakMyController;</span><br><span class="line">    <span class="keyword">if</span> (strongMyController) &#123;</span><br><span class="line">        // ...</span><br><span class="line">        [strongMyController dismissViewControllerAnimated:<span class="type">YES</span> completion:<span class="keyword">nil</span>];</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        // <span class="type">Probably</span> nothing...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在某些情况下,您可以使用<strong>unsafe_unretained如果类不是</strong>weak兼容。然而,这可能成为重要的不切实际的周期,因为很难或不可能验证__unsafe_unretained指针仍然有效,仍然指向同一个对象。</p>
<h3 id="ARC管理AutoReleasePool">ARC管理AutoReleasePool</h3><p>Using ARC, you cannot manage autorelease pools directly using the NSAutoreleasePool class. Instead, you use @autoreleasepool blocks:<br>使用ARC，你不能管理自动释放池直接使用<code>NSAutoreleasePool</code>，你可以使用@autoreleasepool block代替:</p>
<pre><code><span class="variable">@autoreleasepool</span> {
     <span class="comment">// Code, such as a loop that creates a large number of temporary objects.</span>
}
</code></pre><p>这个简单的结构允许编译器推断引用技术的状态。在入口点，一个自动释放池被推入，正常退出(brek,return,goto,fall-through等等)自动释放池被推出。为了兼容现在的代码，如果退出是由于异常，那么自动释放池不会推出。</p>
<h3 id="栈变量初始化为nil">栈变量初始化为nil</h3><p>使用ARC,strong,weak和autoreleasing栈变量会隐式的初始化为nil。</p>
<pre><code>- (<span class="keyword">void</span>)myMethod {
    <span class="built_in">NSString</span> *name;
    <span class="built_in">NSLog</span>(<span class="string">@"name: %@"</span>, name);
}
</code></pre><p>将会打印null而不是崩溃</p>
<h3 id="使用编译标志启用或禁用ARC">使用编译标志启用或禁用ARC</h3><p>启用ARC使用<code>-fobjc-arc</code>编译标志，禁用ARC的编译标致<code>-fno-objc-arc</code></p>
<h2 id="Toll-Free_Bridging(无缝桥接)">Toll-Free Bridging(无缝桥接)</h2><hr>
<p>在许多Cocoa应用中，你需要使用Core Foundation风格的对象，例如Core Foundation，CoreGraphics等等。编译器不会自动管理Core Foundation对象的生命周期，你必须调用CFRetain和CFRelease来管理Core Foundation对象的生命周期。</p>
<p>编译器必须知道由谁来负责释放转换后的对象,如果你把一个NSObject当作 Core Foundation 对象来使用,则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图,编译器没办法自己做主。同样如果你创建一个Core Foundation对象并把它转换为NSObject对象,你也必须告诉ARC占据对象的所有权,并在适当的时候释放该对象。这就是所谓的 bridging casts。</p>
<p>__bridge 改变Objective-C和Core Foundation对象的之间的类型转化，不改变对象的所有权。</p>
<p>__bridge_retained or CFBridgingRetain 将Objective-C对象转变为Core Foundation对象，并且所有权转变给Core Foundation,由程序员管理内存。</p>
<p>__bridge_transfer or CFBridgingRelease 将非Objective-C对象转变为Objective-C对象，所有权转变给ARC，由系统管理。</p>
<p>eg:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>logFirstNameOfPerson:<span class="params">(<span class="variable">ABRecordRef</span>)</span>person &#123;</span><br><span class="line"> </span><br><span class="line">    NSString *name = <span class="params">(<span class="variable">NSString</span> *)</span>ABRecordCopyValue<span class="params">(person, k<span class="variable">ABPersonFirstNameProperty</span>)</span>;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"Person's first name: %@"</span>, name)</span>;</span><br><span class="line">    [name release];</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>替换:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>logFirstNameOfPerson:<span class="params">(<span class="variable">ABRecordRef</span>)</span>person &#123;</span><br><span class="line"> </span><br><span class="line">    NSString *name = <span class="params">(<span class="variable">NSString</span> *)</span>CFBridgingRelease<span class="params">(<span class="variable">ABRecordCopyValue</span>(person, k<span class="variable">ABPersonFirstNameProperty</span>)</span>);</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"Person's first name: %@"</span>, name)</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>ARC是一个编译器的特征，提供自动内存管理对Objective-C对象。而不是必须思索<code>retain</code>和<code>release</code>操作，ARC容许你集中精力在令人有趣的代码上，这个对象图表示对象之间的关系在你的应用中。<br><img s]]>
    </summary>
    
      <category term="内存管理" scheme="http://linfeng1009.gitcafe.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS多线程总结之GCD]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/09/29/thread-summary-gcd/"/>
    <id>http://linfeng1009.gitcafe.io/2015/09/29/thread-summary-gcd/</id>
    <published>2015-09-29T09:07:00.000Z</published>
    <updated>2015-09-29T09:06:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Grand_Central_Dispatch_(GCD)">Grand Central Dispatch (GCD)</h2><h3 id="1-GCD概述">1.GCD概述</h3><p>GCD由语言特征、运行时库和系统提供的增强功能组成，综合提升多核硬件支持代码在iOS和OS X中并发执行。</p>
<h4 id="GCD对象和ARC">GCD对象和ARC</h4><p>当你构建你的应用使用OC语言编译时，所有的<code>dispatch</code>对象也是OC对象。同样的，在ARC的环境中，<code>dispatch</code>对象和任何其他OC对象一样会自动的<code>retain</code> 和 <code>release</code>。在MRC环境中时，使用<code>dispatch_retain</code>和<code>dispatch_release</code>函数(和OC语义相同)来保留或者释放派发对象。你不能使用<code>Core Foundation</code>的保留和释放函数。</p>
<h3 id="2-创建和管理队列">2.创建和管理队列</h3><hr>
<p>在GCD中，有两种队列，串行队列和并发队列，串行队列中根据FIFO的方式执行任务，但同时只能执行一个任务。并发队列也会根据FIFO的方式执行任务，但是同时可以执行多个任务。</p>
<p>1.<code>dispatch_queue_t dispatch_get_main_queue(void);</code><br>返回一个主队列，主队列通过系统自动创建并且和你的应用的主线程相关联。</p>
<p>2.<code>dispatch_queue_t dispatch_get_global_queue( long identifier, unsigned long flags);</code><br>返回一个全局的并发队列，任务提交到这个队列中会被安排与其他任务并发执行。</p>
<p>3.<code>dispatch_queue_t dispatch_queue_create( const char *label, dispatch_queue_attr_t attr);</code><br>创建一个新的调度队列，label参数为对列贴上一个唯一的标示符，官方推荐名为反向的域名(com.example.myqueue), attr参数指定为<code>DISPATCH_QUEUE_SERIAL</code>或者<code>NULL</code>创建一个串行队列，指定为<code>DISPATCH_QUEUE_CONCURRENT</code>创建一个并发队列。</p>
<p>4.<code>dispatch_queue_t dispatch_get_current_queue(void);</code><br>返回当前的队列，这个函数被定义永远都不会返回为NULL。当在提交的block上下文的外部调用时，这个函数会返回主队列如果是在主线程中调用。如果在其他任意的线程中调用，这个函数会返回默认的并发队列。</p>
<p>5.<code>const char * dispatch_queue_get_label(dispatch_queue_t queue);</code>获取指定代理的唯一标示，返回可能为空</p>
<h3 id="3-等候任务调度">3.等候任务调度</h3><p>GCD提供和管理FIFO队列，你的应用可以block对象的形式提交任务。block提交到调度队列在一个系统全面管理的线程池上执行。不能保证线程执行一个任务。GCD提供3种类型的队列:<br>主队列: 在你应用的主线程上顺序执行任务<br>并发队列: 任务按照先入先出的方式移除队列，并发执行并且能够以任意顺序完成<br>串行队列: 按照先入先出的方式同时只能执行一个任务<br>主队列是自动创建的通过系统并且和你应用的主线程关联。你的应用使用下面三个方法的其中一个去调用提交到主队列的block</p>
<p>调用<code>dispatch_main</code><br>调用<code>UIApplicationMain</code>(iOS) 或 <code>NSApplicationMain</code>(OS X)<br>使用<code>CFRunLoopRef</code>在主线程 </p>
<p>使用并发队列同时执行多个任务。GCD自动创建四个并发调度队列，并且在应用中是全局的，它们之间的区别仅在于优先级。你的应用请求这些队列使用<code>dispatch_get_global_queue</code>函数。因为这些并发队列在你用中是全局的，所以一你不需要保留或者释放，保留或者释放方法的调用对于它们是可以忽略的。</p>
<p>使用串行队列可确保那些任务按照预期的方式执行。你的用用必须明确地创建和管理串行队列。如果有必要可以穿件多个串行队列，但是应该避免使用它们代替并发队列只是为了同时执行过个任务。</p>
<p>1.<code>void dispatch_async( dispatch_queue_t queue, dispatch_block_t block);</code><br>提交一个block异步执行在指定调度队列上，并且立刻返回。</p>
<p>2.<code>void dispatch_async_f( dispatch_queue_t queue, void *context, dispatch_function_t work);</code><br>再指定的队列上异步调用在应用中定义的方法，context为应用中自定义函数的参数，work为自定义函数的IMP<br>eg:</p>
<pre><code>dispatch_function_t fuction = (dispatch_function_t)custonFuction;
dispatch_async_f(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), (<span class="keyword">void</span> *)<span class="number">10</span>, fuction);

<span class="keyword">void</span> custonFuction(<span class="keyword">int</span> par)
{
       <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,par);
       <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);
}
</code></pre><p>3.<code>void dispatch_sync( dispatch_queue_t queue, dispatch_block_t block);</code><br>添加block到目标调度队列执行并且等待直到block执行完成，不像<code>dispatch_async</code>,这个函数不会返回直到block已经完成。调用这个函数并且目标队列为当前的队列会造成死锁。</p>
<p>4.<code>void dispatch_after( dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</code><br>指定时间执行block,通常用来延时执行某个操作，而不用NSTimer</p>
<p>5.<code>void dispatch_apply( size_t iterations, dispatch_queue_t queue, void (^block)( size_t));</code><br>多次执行block任务</p>
<p>6.<code>void dispatch_once( dispatch_once_t *predicate, dispatch_block_t block);</code><br>在整个应用生命周期内仅仅执行一次block任务，通常实现单例模式</p>
<p>eg:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">       </span><br><span class="line"><span class="built_in">NSString</span> *url = <span class="string">@"http://tao.goulew.com/users/upfile/201504/201504081150270big.jpg"</span>;</span><br><span class="line">        <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc] initWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:url]];</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(image)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="4-使用调度组">4.使用调度组</h3><p>调度组: 在应用中向调度队列中添加多个任务block，使用调度组可以追踪当所有的任务完成时，即便它们处于不同的队列中。<br>1.<code>void dispatch_group_async( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</code><br>提交一个block到调度队列并且使这个block与指定的调度组相关联</p>
<p>2.<code>dispatch_group_t dispatch_group_create( void);</code><br>创建一个调度组</p>
<p>3.<code>void dispatch_group_notify( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</code><br>调度一个block对象提交到队列中当之前提交的block对象已经完成时</p>
<p>eg:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">       </span><br><span class="line">    NSLog<span class="list">(@<span class="string">"%@任务1"</span>,[NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">           </span><br><span class="line">    NSLog<span class="list">(@<span class="string">"%@任务2"</span>,[NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">       </span><br><span class="line">    NSLog<span class="list">(@<span class="string">"%@任务3"</span>,[NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog<span class="list">(@<span class="string">"所有的任务完成"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Grand_Central_Dispatch_(GCD)">Grand Central Dispatch (GCD)</h2><h3 id="1-GCD概述">1.GCD概述</h3><p>GCD由语言特征、运行时库和系统提供的增强功能组成，综合提升多核硬件支持代]]>
    </summary>
    
      <category term="iOS多线程" scheme="http://linfeng1009.gitcafe.io/tags/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Associated Objects实现用Block代替UIAlertView代理方法]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/09/23/associated-object/"/>
    <id>http://linfeng1009.gitcafe.io/2015/09/23/associated-object/</id>
    <published>2015-09-23T04:05:34.000Z</published>
    <updated>2015-09-23T04:05:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>之前在一个项目中，有多个地方要用到UIAlertView，每次都要遵循UIAlertView协议，实现代理方法，使得代码过于分散。在iOS8以后，官方提供了UIAlertController类，通过闭包终于可以甩掉之前的代理方法了，但是在iOS8一下，同样想实现这样的功能，首先想到的是通过创建一个category，但是在category中并不能添加属性。在官方文档中有看到 objc_setAssociatedObject 和 objc_getAssociatedObject运行时方法可以动态关联对象,那么这样就没问题了。</p>
<h3 id="1-AssociatedObject_API简介">1.AssociatedObject API简介</h3><h4 id="objc_setAssociatedObject">objc_setAssociatedObject</h4><hr>
<p><code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</code><br>设置一个关联值对于一个给定对象使用给定的key和关联策略</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>object</td>
<td>关联的对象</td>
</tr>
<tr>
<td>key</td>
<td>关联的key</td>
</tr>
<tr>
<td>value</td>
<td>关联对象关联的key对于的value</td>
</tr>
<tr>
<td>policy</td>
<td>关联策略</td>
</tr>
</tbody>
</table>
<p>关联策略类似于定于属性时的修饰(strong,weak,nonatomic)</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_ASSIGN</span> = <span class="number">0</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_RETAIN_NONATOMIC</span> = <span class="number">1</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_COPY_NONATOMIC</span> = <span class="number">3</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_RETAIN</span> = <span class="number">01401</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_COPY</span> = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="objc_getAssociatedObject">objc_getAssociatedObject</h4><hr>
<p><code>id objc_getAssociatedObject(id object, void *key)</code><br>通过对象用指定的key获取value</p>
<h4 id="objc_removeAssociatedObjects">objc_removeAssociatedObjects</h4><hr>
<p><code>void objc_removeAssociatedObjects(id object)</code><br>移除关联对象所有关联的内容</p>
<h3 id="2-使用AssociatedObject用Block代替UIAlertView的代理方法">2.使用AssociatedObject用Block代替UIAlertView的代理方法</h3><hr>
<h4 id="2-1_定义AlertAction">2.1 定义AlertAction</h4><p>1.新建一个继承NSObject的DSAlertAction<br>2.定义一个title属性和block<br>3.定义一个初始化方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^DSAlertActionHandler) ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DSAlertAction</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) DSAlertActionHandler alertActionHandler;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)actionWithTitle:(<span class="built_in">NSString</span> *)title handler:(DSAlertActionHandler)alertActionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2_UIAlertView分类">2.2 UIAlertView分类</h4><hr>
<p>1.初始化方法，注意在初始化方法中otherAlertActions是可变参数</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">-<span class="params">(id)</span>initWithTitle:<span class="params">(<span class="variable">NSString</span> *)</span>title message:<span class="params">(<span class="variable">NSString</span> *)</span>message cancelAlertAction:<span class="params">(<span class="variable">DSAlertAction</span> *)</span>cancelAlertAction otherAlertActions:<span class="params">(<span class="variable">DSAlertAction</span> *)</span>otherAlertActions, </span>... <span class="variable">NS_REQUIRES_NIL_TERMINATION</span>;</span><br></pre></td></tr></table></figure>
<p>2.添加一个addAction方法，用来添加操作<br>3.设置关联对象,初始化方法中otherAlertActions是可变参数，关联一个数组对象，用来存储这些参数，稍后会在其代理方法中使用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *)alertActions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *alertActions = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">void</span> *)ALERT_ACTIONS);</span><br><span class="line">    <span class="keyword">if</span>(!alertActions)</span><br><span class="line">    &#123;</span><br><span class="line">        alertActions = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">void</span> *)ALERT_ACTIONS, alertActions, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> alertActions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.在代理方法中，调用在初始化方法中传递的操作</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(buttonIndex &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	TODO: 从关联数组中取出对应的操作对象，然后调用其block</span><br><span class="line">        <span class="built_in">NSArray</span> *alertActions = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">void</span> *)ALERT_ACTIONS);</span><br><span class="line">        DSAlertAction *alertAction = alertActions[buttonIndex];</span><br><span class="line">        <span class="keyword">if</span>(alertAction<span class="variable">.alertActionHandler</span>)</span><br><span class="line">            alertAction<span class="variable">.alertActionHandler</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">void</span> *)ALERT_ACTIONS, <span class="literal">nil</span>, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">    TODO: 在完成操作后，切记将关联key对象的值置空，防止内存泄露</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，UIActionSheet可以这样实现。<br>具体代码已上传至GitHub: <a href="https://github.com/ludaye123/DSAlertView-Blocks" target="_blank" rel="external">https://github.com/ludaye123/DSAlertView-Blocks</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="前言">前言</h3><p>之前在一个项目中，有多个地方要用到UIAlertView，每次都要遵循UIAlertView协议，实现代理方法，使得代码过于分散。在iOS8以后，官方提供了UIAlertController类，通过闭包终于可以甩掉之前的代理方法了，但是]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS多线程总结之NSOperation 和 NSOperationQueue]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/09/22/thread-summary-nsoperate/"/>
    <id>http://linfeng1009.gitcafe.io/2015/09/22/thread-summary-nsoperate/</id>
    <published>2015-09-22T05:11:32.000Z</published>
    <updated>2015-09-22T05:11:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="NSOperation">NSOperation</h2><h3 id="1-NSOperation概述">1.NSOperation概述</h3><p><code>NSOperation</code>类是一个抽象类，你用来封装代码和数据与单一任务关联。因为它是抽象的，不能直接使用这个类，但可以直接子类化或者是使用系统定义好的子类(<code>NSInvocationOperation</code> or <code>NSBlockOperation</code>)去执行实际任务。尽管是抽象的，<code>NSOperation</code>基本实现包括了重要的逻辑确保安全执行你的任务。这些内建的逻辑允许你集中精力在实际实现的任务中，而不是粘合代码来确保它和系统其他的对象正常运行。</p>
<p>一个操作对象是一个单一的对象，它只执行任务一次并且不能用来重复执行。你执行操作通过把它们加入到一个操作队列(<code>NSOperationQueue</code>的对象)中，操作队列中的操作就会直接执行在一个不同的线程，间接的使用<code>libdispatch</code>库(通常讲的GCD)</p>
<h3 id="2-NSOperation的子类">2.NSOperation的子类</h3><p><code>NSOperation</code>是一个抽象类，系统预先给我们提供了两个子类，分别是:<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>.</p>
<h4 id="2-1_NSInvocationOperation">2.1 NSInvocationOperation</h4><p><code>NSInvocationOperation</code>类是<code>NSOperation</code>的具体子类，管理执行单一封装的任务，你可以使用这个类去启动一个操作，由指定的对象调用选择器。这个类实现非并发操作。</p>
<h4 id="2-1-1_使用方法">2.1.1 使用方法</h4><p>初始化方法，返回一个<code>NSInvocationOperation</code>对象，指定的目标对象和选择器进行初始化</p>
<pre><code><span class="pp">- <span class="params">(instancetype)</span>initWithTarget:<span class="params">(id)</span>target
                  selector:<span class="params">(<span class="variable">SEL</span>)</span>sel
                    object:<span class="params">(id)</span>arg</span>
</code></pre><p>eg:</p>
<pre><code>- (<span class="keyword">void</span>)viewDidLoad
{
    [<span class="keyword">super</span> viewDidLoad];
     <span class="built_in">NSInvocationOperation</span> *invocaitonOperation = [[<span class="built_in">NSInvocationOperation</span> alloc]
     initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(downLoadTask) object:<span class="literal">nil</span>];
   <span class="comment">// [invocaitonOperation start];</span>
       <span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];
    [operationQueue addOperation:invocaitonOperation];
}    

- (<span class="keyword">void</span>)downLoadTask
{
      <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);
      TODO: &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fc8cb502b60</span>&gt;{number = <span class="number">1</span>, name = main}
      这里打印出当成线程的信息，是主线程，也就是说如果直接调用其start方法并不会去创建一个新的线程执
      行任务，只是在当前线程中执行
   TODO: &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fb18a59a410</span>&gt;{number = <span class="number">2</span>, name = (null)}
   修改上面的代码，把操作添加到操作队列后，在操作队列中会自动调用start,并且产生新的线程
   <span class="built_in">NSBlockOperation</span> 同样如此
}
</code></pre><h4 id="2-2_NSBlockOperation">2.2 NSBlockOperation</h4><p><code>NSBlockOperation</code>是<code>NSOperation</code>的另一个具体的子类，管理并发执行的一个或多个block。你可以使用这个对象立马执行多个block，并没有为每个block创建一个单独操作对象。当执行超过一个block时，这个操作本身会考虑只有当所有的block执行完成后才会结束。Blocks增加到一个block操作中会分发一个默认的优先级的工作队列，block本身不应该设想关于配置它们执行的环境。</p>
<h4 id="2-2-1_使用方法">2.2.1 使用方法</h4><p>指定一个block创建并返回<code>NSBlockOperation</code>对象</p>
<pre><code>+ (instancetype)<span class="string">blockOperationWithBlock:</span>(<span class="typename">void</span> (^)(<span class="typename">void</span>))block
- (<span class="typename">void</span>)<span class="string">addExecutionBlock:</span>(<span class="typename">void</span> (^)(<span class="typename">void</span>))block  <span class="comment">// 增加多个block</span>
</code></pre><p>eg: </p>
<pre><code><span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^{

    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);

}];

<span class="comment">//    [blockOperation start];</span>
<span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];
[operationQueue addOperation:blockOperation];
</code></pre><h4 id="2-3_自定义NSOperation">2.3 自定义NSOperation</h4><p>对于非并发的操作，你仅重载一个main方法即可，在这个方法中，你放置需要执行所给任务的代码，当然你也可以自定义一个初始化方法来构造和创建自定义类的对象。也许你可能想要定义getter和setter方法来访问数据从这个操作中，然而，如果你自定义的getter和setter方法，你必须确保这些方法能被安全的调用从多线程中。</p>
<p>如果你想要创建一个并发操作，你至少需要重载下面的方法和属性。</p>
<pre><code><span class="built_in">start</span>
asynchronous
executing
finished
</code></pre><p>对于一个并发操作，你的<code>start</code>方法是负责启动异步操作的方式。是否生产一个线程或者调用一个异步方法，你要从这个方法实现。在开始操作，你的<code>start</code>方法应该更新这个操作的执行状态通过<code>executing</code>属性记录。做这个操作是通过发送KVO通知给<code>executing</code>关键路径，这让其他与这个操作有联系的对象知道这个操作现在已经在运行，你的<code>executing</code>属性必须在线程安全的方式下提供状态变化。</p>
<h3 id="3-NSOperation_依赖">3.NSOperation 依赖</h3><p>依赖是一种便捷的方式去执行操作按照指定的命令。你能添加和移除依赖给一个操作使用<code>addDependency:</code>和<code>removeDependency:</code>方法。默认情况，一个操作对象的依赖不认为是准备好的直到所有的依赖操作对象都完成执行。一旦最后一个依赖操作完成，这个依赖操作对象变成准备状态并且能够被执行。举个例子来说，有两个操作operation1和operation2，如果operation1依赖operation2,那么需要等operation2完成后，operation1才可以执行。</p>
<p>eg: </p>
<pre><code>  <span class="built_in">NSBlockOperation</span> *downOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^{
    <span class="comment">// 开始下载任务，例如下载一个一张图片</span>
    <span class="built_in">NSLog</span>(<span class="string">@"下载图片"</span>);
}];

<span class="built_in">NSBlockOperation</span> *processOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^{
    <span class="comment">// 下载完成后，处理图片</span>
    <span class="built_in">NSLog</span>(<span class="string">@"处理图片"</span>);
}];

[processOperation addDependency:downOperation];
<span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];
[operationQueue addOperation:downOperation];
[operationQueue addOperation:processOperation];
TODO: 不要把操作设置依赖为自己本身，如果这样做会造成死循环，并且这个操作不会执行
</code></pre><h2 id="NSOperationQueue">NSOperationQueue</h2><h3 id="1-NSOperationQueue的概述">1.NSOperationQueue的概述</h3><p><code>NSOperationQueue</code>类管理执行操作对象的集合，操作对象加入到队列后会保留在队列中直到它已经明确的取消或者完成执行任务。操作在队列内(但尚未执行)它们自己有组织的根据优先级和互相依赖的对象相应的去执行。一个应用可以创建多个操作队列并且可以提交操作到多个操作队列中的任何一个。<br>相互依赖的对象提供了一个绝对执行的命令给这些操作对象，甚至这个操作位于不同的操作队列中。一个操作对象不被考虑准备执行直到所有的依赖操作已经完成执行。对于准备执行的操作对象，操作队列总是先执行高优先级相对其他已准备的操作。<br>你不能直接移除一个操作从队列中在它被加入后。一个操作保留在队中直到它记录操作已经完成了任务。完成了任务并不意味着操作执行的任务也完成了。一个操作能够被取消。取消一个操作对象在队列中离开的对象通知对象尽可能快的中止任务。对于当前正在执行的操作，这意味着操作对象工作的执行代码必须检查取消状态，停止一切正在做的事情，并且标记它已经完成。对于排队但尚未执行的操作，队列必须调用操作对象的<code>start</code>方法，以便它可以处理取消事件并且标记它已完成。</p>
<h3 id="2-NSOperationQueue常用方法和属性">2.NSOperationQueue常用方法和属性</h3><h4 id="2-1_方法">2.1 方法</h4><p><code>+ (NSOperationQueue *)currentQueue</code> 获取当前队列<br><code>+ (NSOperationQueue *)mainQueue</code>  获取与主线程相关联的操作队列<br><code>- (void)addOperation:(NSOperation *)operation</code> 添加一个操作<br><code>- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops
    waitUntilFinished:(BOOL)wait</code> 添加一个操作的数组，wait为YES会阻塞当前线程，直到所有的操作完成<br><code>- (void)addOperationWithBlock:(void (^)(void))block</code> 将一单一的block封装到一个操作对象内添加到队列<br><code>- (void)cancelAllOperations</code>  取消队列中所有执行的操作，这个方法会调用队列中所有操作对象的<code>cancel</code>方法<br><code>- (void)waitUntilAllOperationsAreFinished</code> 阻塞当前线程直到所有排队或者执行的操作完成执行</p>
<h4 id="2-2_属性">2.2 属性</h4><p><code>@property NSInteger maxConcurrentOperationCount</code> 队列中能够同时执行的最大操作个数，默认没有限制<br><code>@property(getter=isSuspended) BOOL suspended</code> 队列是否处于活动状态 </p>
<h3 id="3-NSOperationQueue的使用">3.NSOperationQueue的使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocationOperation</span> *operation1 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(processOperation) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *operation2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作2"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">[operationQueue addOperation:operation1];</span><br><span class="line">[operationQueue addOperation:operation2];</span><br><span class="line">[operationQueue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作3"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)processOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"操作1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSOperation_class/index.html" target="_blank" rel="external">NSOperation</a><br><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSInvocationOperation_Class/index.html" target="_blank" rel="external">NSInvocationOperation</a><br><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSBlockOperation_class/index.html#//apple_ref/doc/uid/TP40008157-CH1-SW2" target="_blank" rel="external">NSBlockOperation</a><br><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSOperationQueue_class/" target="_blank" rel="external">NSOperationQueue</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="NSOperation">NSOperation</h2><h3 id="1-NSOperation概述">1.NSOperation概述</h3><p><code>NSOperation</code>类是一个抽象类，你用来封装代码和数据与单一任务关联。因为它是抽]]>
    </summary>
    
      <category term="iOS多线程" scheme="http://linfeng1009.gitcafe.io/tags/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS多线程总结之NSThread]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/09/16/thread-summary-nsthread/"/>
    <id>http://linfeng1009.gitcafe.io/2015/09/16/thread-summary-nsthread/</id>
    <published>2015-09-16T01:54:02.000Z</published>
    <updated>2015-09-16T01:54:02.000Z</updated>
    <content type="html"><![CDATA[<p>iOS开发中，实现线程的方式总体有三种<br>1.NSThread<br>2.NSOperate 和 NSOperateQueue<br>3.GCD<br>还有一种更加底层的API,用pthread来实现</p>
<h3 id="NSThread">NSThread</h3><p>一个NSThread对象控制一条线程的执行。用这个类当你想要让一个OC方法运行在它自己的执行线程中。线程特别有用 当你需要执行一个漫长的任务时,但是又不想阻塞应用中其他部分的执行。另外,你能够用线程去避免阻塞应用的主线程,处理用户界面和相关的事件操作。线程也能别用来把一个大的任务分解成多个小得任务,从而引领性能提升在多核计算机上。</p>
<h4 id="1-NSThread的使用">1.NSThread的使用</h4><p>创建一个NSThread对象，官方提供了两个方法</p>
<pre><code><span class="pp">- <span class="params">(instancetype)</span>initWithTarget:<span class="params">(id)</span>target
                  selector:<span class="params">(<span class="variable">SEL</span>)</span>selector
                    object:<span class="params">(id)</span>argument

+ <span class="params">(void)</span>detachNewThreadSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector
                   toTarget:<span class="params">(id)</span>aTarget
                 withObject:<span class="params">(id)</span>anArgument</span>
</code></pre><h4 id="2-参数">2.参数</h4><p>target:    指定对象的消息通过选择器发送<br>selector: 选择器指定发送给目标对象的消息，这个选择器最多只有一个参数并且必须没有返回值<br>argument: 传给目标对象的单一参数，可以为空</p>
<h4 id="3-区别">3.区别</h4><p><code>NSThread</code>提供成员方法和静态方法来创建其对象，前者跟后者的区别在于启动线程的时候，前者需要调用<code>start</code>方法来启动，后者会自动启动。</p>
<h4 id="4-NSObject方法">4.NSObject方法</h4><p>用NSObject提供的<code>performSelectorInBackground</code>的方法隐式创建线程,通过<code>performSelectorOnMainThread</code>方法在主线程上的更新。</p>
<pre><code><span class="pp">- <span class="params">(void)</span>performSelectorInBackground:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>arg
- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait</span>
</code></pre><h4 id="5-常用属性和方法">5.常用属性和方法</h4><p>1.<code>sleepUntilDate</code> 睡眠直到指定的时间(<code>NSDate</code>)<br>2.<code>sleepForTimeInterval</code> 睡眠给定一个指定的时长(单位为秒)<br>3.<code>exit</code> 退出当前线程<br>4.<code>cancel</code> 取消当前线程<br>5.<code>isMainThread</code> 是否是主线程<br>6.<code>mainThread</code> 获取主线程<br>7.<code>currentThread</code> 获取当前线程<br>8.<code>executing</code> 是否正在执行(Bool)<br>9.<code>finished</code> 是否完成执行(Bool)<br>10.<code>cancelled</code> 是否取消(Bool)</p>
<h4 id="6-通知">6.通知</h4><p><code>NSDidBecomeSingleThreadedNotification</code>  暂时没有实现<br><code>NSThreadWillExitNotification</code>  当线程将要退出的时候会发送此通知<br><code>NSWillBecomeMultiThreadedNotification</code> 当且仅当第一个线程从当前线程中派发的时候会发送此通知<br>通知中的object就是这个当前发送通知的传递的线程对象，这个通知不会包含userinfo字典内容</p>
<h4 id="7-eg">7.eg</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    [NSThread detachNewThreadSelector:self toTarget:@selector(downloadTask) withObject:nil];</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(downloadTask) object:<span class="literal">nil</span>];    </span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadTask</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">///////////////////////</span></span><br><span class="line">    <span class="comment">// 开始执行比较耗时的是操作</span></span><br><span class="line">    <span class="comment">// 执行完成后，到主线程中进行刷新操作</span></span><br><span class="line">     <span class="built_in">NSString</span> *url = <span class="string">@"http://tao.goulew.com/users/upfile/201504/201504081150270big.jpg"</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc] initWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:url]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(updateUI:) withObject:image waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)updateUI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 更新页面操作</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单下载图片的例子，效果如下</p>
<p><img src="http://7xkpsz.com1.z0.glb.clouddn.com/Simulator%20Screen%20Shot%20Sep%2015,%202015,%2012.54.59.png?imageView2/2/w/320/h/568" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>iOS开发中，实现线程的方式总体有三种<br>1.NSThread<br>2.NSOperate 和 NSOperateQueue<br>3.GCD<br>还有一种更加底层的API,用pthread来实现</p>
<h3 id="NSThread">NSThread</h3]]>
    </summary>
    
      <category term="iOS多线程" scheme="http://linfeng1009.gitcafe.io/tags/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[制作pod库并提交到Cocoapods]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/08/20/create-pods/"/>
    <id>http://linfeng1009.gitcafe.io/2015/08/20/create-pods/</id>
    <published>2015-08-20T05:35:14.000Z</published>
    <updated>2015-09-09T02:32:41.000Z</updated>
    <content type="html"><![CDATA[<p>摘自:<a href="http://yulingtianxia.com/blog/2014/05/26/publish-your-pods-on-cocoapods-with-trunk/" target="_blank" rel="external">玉令天下</a></p>
<p>简介<br>2014年5月20日，CocoaPods不再接受向CocoaPods/Specs的pull request，官方的说法是为了安全考虑，防止每个人的pod被其他人修改，于是CocoaPods团队开发了trunk服务，这样每个人都是其发布的pod的owner，没有权限的人无法修改，这样更安全。<br>更改后的提交架构是这样的：(来自官方图片)</p>
<p><img src="http://blog.cocoapods.org/assets/blog_img/trunk/architecture-diagram.png" alt=""></p>
<p>以前的podspec文件都是ruby格式，而trunk为我们带来了更轻便的json格式，你后你可以用json来配置你的pod了。不用担心过去我们发布的pod，他们依然健在，并且trunk会将podspec文件转化为podspec.json文件。<br>这里给出一个官方的介绍链接：<a href="http://blog.cocoapods.org/CocoaPods-Trunk/#transition" target="_blank" rel="external">http://blog.cocoapods.org/CocoaPods-Trunk/#transition</a><br>废话不多说，简要介绍下如何使用trunk新建我们的pod：<br>开始注册<br>trunk需要CocoaPods 0.33版本以上，用pod —version命令查看版本，如果版本低，需要升级：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gem <span class="keyword">install</span> cocoapods</span><br><span class="line">pod setup</span><br></pre></td></tr></table></figure></p>
<p>然后会一直卡在Setting up CocoaPods master repo这里，这条命令用于跟新本地电脑上的保存的Pods依赖库tree。由于每天有很多人会创建或者更新Pods依赖库，这条命令执行的时候会相当慢，还请耐心等待。我们需要经常执行这条命令，否则有新的Pods依赖库的时候执行pod search命令是搜不出来的。再开启一个终端，通过cd ~/.cocoapods命令进入cocoapods根目录，然后通过du -sh *命令查看总的文件大小，如果隔一阵子会增加，那么说明一切正常，下载速度取决于你的网络。<br>更新完成后，下一步是注册trunk，这一步需要自备梯子，否则就会出现这种问题<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pod</span> trunk register yulingtianxia<span class="variable">@gmail</span>.com <span class="string">'Yang Xiaoyu'</span> --description=<span class="string">'macbook pro'</span> --verbose</span><br></pre></td></tr></table></figure></p>
<p>上面的命令是我注册时使用的，你需要把邮箱和名字以及描述替换成你的，加上—verbose可以输出详细debug信息，方便出错时查看。<br>注册后CocoaPods会给你的邮箱发送验证链接，点击后就注册成功了，可以用pod trunk me命令查看自己的注册信息：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bogon:YXYNumberAnimationLabel yangxiaoyu$ pod trunk me</span><br><span class="line">  -<span class="ruby"> <span class="constant">Name</span><span class="symbol">:</span>     <span class="constant">Yang</span> <span class="constant">Xiaoyu</span></span><br><span class="line"></span>  -<span class="ruby"> <span class="constant">Email</span><span class="symbol">:</span>    yulingtianxia<span class="variable">@gmail</span>.com</span><br><span class="line"></span>  -<span class="ruby"> <span class="constant">Since</span><span class="symbol">:</span>    <span class="constant">May</span> <span class="number">25</span>th, <span class="number">20</span><span class="symbol">:</span><span class="number">27</span></span><br><span class="line"></span>  -<span class="ruby"> <span class="constant">Sessions</span><span class="symbol">:</span> </span><br><span class="line"></span>    -<span class="ruby"> <span class="constant">May</span> <span class="number">25</span>th, <span class="number">20</span><span class="symbol">:</span><span class="number">27</span> - <span class="constant">September</span> <span class="number">30</span>th, <span class="number">22</span><span class="symbol">:</span><span class="number">41</span>. <span class="constant">IP</span><span class="symbol">:</span> <span class="number">23.228</span>.<span class="number">209.171</span></span><br><span class="line"></span>  Description: macbook pro</span><br></pre></td></tr></table></figure></p>
<p>上面是我的注册信息，CocoaPods不通过密码来验证用户，而是通过一个session token。<br>部署你的Pod<br>首先你需要建立一个podspec文件，这是我的podspec文件：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib <span class="keyword">create</span> <span class="keyword">Library</span></span><br></pre></td></tr></table></figure>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.<span class="built_in">new</span> <span class="built_in">do</span> |s|</span><br><span class="line">  s.name         = <span class="string">"YXYNumberAnimationLabel"</span></span><br><span class="line">  s.<span class="built_in">version</span>      = <span class="string">"1.0.1"</span></span><br><span class="line">  s.summary      = <span class="string">"一个可以动起来的数字Label"</span></span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line">                    通过设置数字变化的插值来展现动画效果</span><br><span class="line">                   DESC</span><br><span class="line">  s.homepage     = <span class="string">"https://github.com/yulingtianxia/YXYNumberAnimationLabel"</span></span><br><span class="line">  </span><br><span class="line">  s.license      = <span class="string">'MIT'</span></span><br><span class="line">  s.author       = &#123; <span class="string">"YangXiaoyu"</span> =&gt; <span class="string">"yulingtianxia@gmail.com"</span> &#125;</span><br><span class="line">  s.social_media_url = <span class="string">"http://twitter.com/yulingtianxia"</span></span><br><span class="line">  s.source       = &#123; :git =&gt; <span class="string">"https://github.com/yulingtianxia/YXYNumberAnimationLabel.git"</span>, :tag =&gt; s.<span class="built_in">version</span>.to_s &#125;</span><br><span class="line"></span><br><span class="line">  s.<span class="built_in">platform</span>     = :ios, <span class="string">'6.0'</span></span><br><span class="line">  s.requires_arc = <span class="constant">true</span></span><br><span class="line"></span><br><span class="line">  s.source_files = <span class="string">'YXYNumberAnimationLabel/*'</span></span><br><span class="line">  s.frameworks = <span class="string">'Foundation'</span>, <span class="string">'UIKit'</span></span><br><span class="line">  <span class="comment">#s.private_header_files = 'Classes/ios/private/*.h'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#s.dependency 'FLKAutoLayout', '~&gt; 0.1'</span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>具体配置什么的大家走很熟悉，这里只是讲述使用trunk后需要注意的地方和新的操作<br>在验证和上传你的podspec文件到trunk之前，需要将你的源码push到Github上，tag一个版本号并发布一个release版本，这样podspec文件中的s.source的值才能是准确的：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add -A &amp;&amp; git <span class="operator"><span class="keyword">commit</span> -m <span class="string">"Release 1.0.1."</span>  </span><br><span class="line">git tag <span class="string">'1.0.1'</span>  </span><br><span class="line">git push <span class="comment">--tags  </span></span><br><span class="line">git push origin <span class="keyword">master</span></span></span><br></pre></td></tr></table></figure></p>
<p>这两条命令是为pod添加版本号并打上tag:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="operator">the</span> <span class="built_in">new</span> <span class="built_in">version</span> <span class="built_in">to</span> <span class="number">1.0</span>.1</span><br><span class="line"><span class="built_in">set</span> <span class="operator">the</span> <span class="built_in">new</span> tag <span class="built_in">to</span> <span class="number">1.0</span>.1</span><br></pre></td></tr></table></figure></p>
<p>在你podspec文件下的路径运行pod trunk push YXYNumberAnimationLabel.podspec 命令，同样需要翻墙梯子自备，别忘了将YXYNumberAnimationLabel.podspec替换成你的podspec文件名。<br>pod trunk push命令做了如下三个工作：<br>验证你本地的podspec文件（你也可以用pod lib lint命令来验证）<br>上传你的podspec文件到trunk<br>将你的podspec文件转化成trunk需要的JSON文件<br>如果部署成功，CocosPods会在Twitter上@你<br>就像文章最开始的架构图描述的那样，你在trunk中的操作依然会在CocoaPods/Specs仓库中更新。以后再做更改时只需要更新版本号然后通过trunk来提交，不用向CocoaPods/Specspull request并等待审核和merge了。<br>运行pod setup来更新你的Pods依赖库tree后，再使用pod search YXYNumberAnimationLabel命令来查找刚刚加入的名字叫YXYNumberAnimationLabel的依赖库：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; YXYNumberAnimationLabel (<span class="number">1.0</span>.1)</span><br><span class="line">   一个可以动起来的数字Label</span><br><span class="line">   pod <span class="string">'YXYNumberAnimationLabel'</span>, <span class="string">'~&gt; 1.0.1'</span></span><br><span class="line">   - <span class="string">Homepage:</span> <span class="string">https:</span><span class="comment">//github.com/yulingtianxia/YXYNumberAnimationLabel</span></span><br><span class="line">   - <span class="string">Source:</span>   <span class="string">https:</span><span class="comment">//github.com/yulingtianxia/YXYNumberAnimationLabel.git</span></span><br><span class="line">   - <span class="string">Versions:</span> <span class="number">1.0</span>.1, <span class="number">1.0</span>.0 [master repo]</span><br></pre></td></tr></table></figure></p>
<p>将其他人加入到你的Pod<br>为了让其他人也有权限来和你一起建设你的代码，你需要运行下面的命令来赋予别人权限，假如我将kyle@cocoapods.org加入到我的名字叫ARAnalytics的库中，我需要运行下面的命令：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk<span class="instruction"> add-owner </span>ARAnalytics kyle@cocoapods.org</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>摘自:<a href="http://yulingtianxia.com/blog/2014/05/26/publish-your-pods-on-cocoapods-with-trunk/" target="_blank" rel="external">玉令天下</a><]]>
    </summary>
    
      <category term="Cocoapods" scheme="http://linfeng1009.gitcafe.io/tags/Cocoapods/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发常用正则表达式]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/08/18/modified-by-helensong/"/>
    <id>http://linfeng1009.gitcafe.io/2015/08/18/modified-by-helensong/</id>
    <published>2015-08-18T07:54:03.000Z</published>
    <updated>2015-10-19T09:02:20.000Z</updated>
    <content type="html"><![CDATA[<p>在之前项目开发中，遇到过一些输入内容的判断，判断手机号码是否合法等等。<br>记录下iOS开发中常用的正则表达式。</p>
<p>手机号码</p>
<p>1)移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188<br>2)联通：130,131,132,152,155,156,185,186<br>3)电信：133,1349,153,180,189<br>NSString * MOBILE = @”^1(3[0-9]|5[0-35-9]|8[025-9])\d{8}$”;</p>
<p>中国移动：China Mobile<br>134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188<br>NSString * CM = @”^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\d)\d{7}$”;</p>
<p>中国联通：China Unicom<br>130,131,132,152,155,156,185,186<br>NSString * CU = @”^1(3[0-2]|5[256]|8[56])\d{8}$”;</p>
<p>中国电信：China Telecom<br>133,1349,153,180,189<br>NSString * CT = @”^1((33|53|8[09])[0-9]|349)\d{7}$”;</p>
<p>大陆地区固话及小灵通<br>区号：010,020,021,022,023,024,025,027,028,029<br>号码：七位或八位<br>NSString * PHS = @”^0(10|2[0-5789]|\d{3})\d{7,8}$”;</p>
<pre><code>以上集合一起，并兼容<span class="number">14</span>开头的
+ (<span class="built_in">BOOL</span>)isMobileNumber:(<span class="built_in">NSString</span> *)mobileNum
{
    <span class="built_in">NSString</span> * phoneRegex = <span class="string">@"^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$"</span>;
    <span class="built_in">BOOL</span> isMatch = [mobileNum isMatchedByRegex:phoneRegex];
    <span class="keyword">return</span> isMatch;
}
</code></pre><hr>
<p>邮箱验证<br>       NSString *emailRegex = @”[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}”; </p>
<p>匹配中文字符的正则表达式： [\u4e00-\u9fa5]<br>评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 </p>
<p>匹配双字节字符(包括汉字在内)：[^\x00-\xff]<br>评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） </p>
<p>匹配空白行的正则表达式：\n\s*\r<br>评注：可以用来删除空白行 </p>
<p>匹配HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/\1&gt;|&lt;.</em>? /&gt;<br>评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧没有能力为力 </p>
<p>匹配首尾空白字符的正则表达式：^\s<em>|\s</em>$<br>评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 </p>
<p>匹配Email地址的正则表达式：\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*<br>评注：表单验证时很实用 </p>
<p>匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*<br>评注：网上流传的版本功能很有限，上面这个基本可以满足需求 </p>
<p>匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br>评注：表单验证时很实用 </p>
<p>匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}<br>评注：匹配形式如 0511-4405222 或 021-87888822 </p>
<p>匹配腾讯QQ号：[1-9][0-9]{4,}<br>评注：腾讯QQ号从10000开始 </p>
<p>匹配中国邮政编码：[1-9]\d{5}(?!\d)<br>评注：中国邮政编码为6位数字 </p>
<p>匹配身份证：\d{15}|\d{18}<br>评注：中国的身份证为15位或18位 </p>
<p>匹配ip地址：\d+.\d+.\d+.\d+<br>评注：提取ip地址时有用 </p>
<p>匹配特定数字：<br>^[1-9]\d<em>$　 　 //匹配正整数<br>^-[1-9]\d</em>$ 　 //匹配负整数<br>^-?[1-9]\d<em>$　　 //匹配整数<br>^[1-9]\d</em>|0$　 //匹配非负整数（正整数 + 0）<br>^-[1-9]\d<em>|0$　　 //匹配非正整数（负整数 + 0）<br>^[1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>$　　 //匹配正浮点数<br>^-([1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>)$　 //匹配负浮点数<br>^-?([1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>|0?.0+|0)$　 //匹配浮点数<br>^[1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）<br>^(-([1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）<br>评注：处理大量数据时有用，具体应用时注意修正 </p>
<p>匹配特定字符串：<br>^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串<br>^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串<br>^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串<br>^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串<br>^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在之前项目开发中，遇到过一些输入内容的判断，判断手机号码是否合法等等。<br>记录下iOS开发中常用的正则表达式。</p>
<p>手机号码</p>
<p>1)移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,18]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深复制VS浅复制]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/07/09/deepcopy-vs-shallowcopy/"/>
    <id>http://linfeng1009.gitcafe.io/2015/07/09/deepcopy-vs-shallowcopy/</id>
    <published>2015-07-09T06:26:48.000Z</published>
    <updated>2015-07-13T02:04:14.000Z</updated>
    <content type="html"><![CDATA[<p>苹果官方内存管理原则：<br>1.谁创建谁负责release：如果使用 alloc、new、copy、mutablecopy来创建对象，那么必须要调用release或者autorelease来释放对象。<br>2.谁retain谁负责release：只要你对对象使用了retain方法，那么必须要调用release或者autorelease来释放对象。</p>
<p>深复制 VS 浅复制 (deep copy VS shallow copy)</p>
<p>深复制：通过复制操作后，返回一个新的副本对象，对此副本对象的任何操作不会影响到原对象，当然原对象的任何操作也不会影响到副本对象。在OC中的深复制本质上是产生了一个新的对象，<br>也就是常说的内容复制(内容拷贝)；</p>
<p>浅复制：通过复制操作后，得到一个副本对象，在OC中本质上是对于原对象的指针复制，没有产生新的对象。</p>
<p>copy VS mutablecopy</p>
<p>shallow copy eg:</p>
<pre><code><span class="built_in">NSString</span> *scrStr  = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSString</span> *copyStr = [scrStr <span class="keyword">copy</span>];

<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %p,copyStr = %p \n"</span>,scrStr,copyStr); <span class="comment">// 内存地址: scrStr = 0x100211d90,copyStr = 0x100211d90  一致</span>
<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %@,copyStr = %@ \n"</span>,scrStr,copyStr); <span class="comment">// 打印内容: scrStr = deep copy vs shallow copy,copyStr = deep copy vs shallow copy </span>
</code></pre><p>deep copy eg:</p>
<pre><code><span class="built_in">NSString</span> *scrStr  = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSMutableString</span> *copyStr = [scrStr mutableCopy];

<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %p,copyStr = %p \n"</span>,scrStr,copyStr); <span class="comment">//内存地址: scrStr = 0x100208490,copyStr = 0x100208490 内存地址不一致，说明生产了新的对象</span>
<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %@,copyStr = %@ \n"</span>,scrStr,copyStr); <span class="comment">//打印内容: scrStr = deep copy vs shallow copy,copyStr = deep copy vs shallow copy </span>
</code></pre><p>deep copy eg:</p>
<pre><code><span class="built_in">NSMutableString</span> *scrStr  = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSString</span> *copyStr = [scrStr mutableCopy];

<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %p,copyStr = %p \n"</span>,scrStr,copyStr); <span class="comment">//内存地址: scrStr = 0x100111f10,copyStr = 0x100111fe0 内存地址不一致，说明生产了新的对象</span>
<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %@,copyStr = %@ \n"</span>,scrStr,copyStr); <span class="comment">//打印内容: scrStr = deep copy vs shallow copy,copyStr = deep copy vs shallow copy </span>
</code></pre><p>deep copy eg:</p>
<pre><code><span class="built_in">NSMutableString</span> *scrStr  = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSMutableString</span> *copyStr = [scrStr mutableCopy];

<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %p,copyStr = %p \n"</span>,scrStr,copyStr); <span class="comment">//内存地址: scrStr = 0x100111f10,copyStr = 0x100111fe0 内存地址不一致，说明生产了新的对象</span>
<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %@,copyStr = %@ \n"</span>,scrStr,copyStr); <span class="comment">//打印内容: scrStr = deep copy vs shallow copy,copyStr = deep copy vs shallow copy </span>
</code></pre><p>通过以上几个示例，当使用copy方法时，返回的是一个不可变副本，也就是相当于指针拷贝，使用mutablecopy方法时，会返回一个可变副本，相当于内容拷贝，会生成新的对象。</p>
<p>Copy 内存管理</p>
<p>浅复制内存管理 eg:</p>
<pre><code><span class="built_in">NSString</span> *scrStr  = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSString</span> *copyStr = [scrStr <span class="keyword">copy</span>];
<span class="built_in">NSLog</span>(<span class="string">@"srcStr = %zd,copyStr = %zd"</span>,[scrStr retainCount],[copyStr retainCount]); <span class="comment">//引用计数: srcStr = 2,copyStr = 2</span>
[copyStr release];
</code></pre><p>深复制内存管理 eg:</p>
<pre><code><span class="built_in">NSMutableString</span> *scrStr  = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSString</span> *copyStr = [scrStr <span class="keyword">copy</span>];        
<span class="built_in">NSLog</span>(<span class="string">@"srcStr = %zd,copyStr = %zd"</span>,[scrStr retainCount],[copyStr retainCount]); <span class="comment">//引用计数: srcStr = 1,copyStr = 1</span>
[copyStr release];
</code></pre><p>浅复制：没有产生新对象，但是原对象(副本对象)的引用计数会加1，上例中srcStr对象非自己生成，无需再调用release，但copyStr是srcStr对象的副本，所以需要调用release释放内存<br>深复制：产生新对象，原对象的引用计数不变，副本对象的引用计数为1，上例中srcStr对象非自己生成，无需再调用release,但copyStr是srcStr深复制而来，所以需要调用release释放内存</p>
<p>总结：</p>
<p>深复制：<br>        1.原对象和副本对象不是指向同一个对象<br>        2.原对象的引用计数不变，副本对象的引用计数为1<br>    3.深复制的实质是生成新的对象</p>
<p>浅复制：<br>    1.原对象和副本对象指向同一个对象<br>    2.原对象(副本对象)的引用计数加1，相当于做了一次retain操作<br>    3.浅复制的实质没有产生新对象，仅是指针拷贝</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>苹果官方内存管理原则：<br>1.谁创建谁负责release：如果使用 alloc、new、copy、mutablecopy来创建对象，那么必须要调用release或者autorelease来释放对象。<br>2.谁retain谁负责release：只要你对对象使用了ret]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Xcode升级插件失效修复方法]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/07/07/xcode-update-plugin-problem/"/>
    <id>http://linfeng1009.gitcafe.io/2015/07/07/xcode-update-plugin-problem/</id>
    <published>2015-07-07T09:50:23.000Z</published>
    <updated>2015-10-19T09:04:26.000Z</updated>
    <content type="html"><![CDATA[<p>1.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID<br><code>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID</code><br>2.然后输入如下命令   【最后一项是获取到的DVTPlugInCompatibilityUUID】<br><code>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add 0420B86A-AA43-4792-9ED0-6FE0F2B16A13</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID<br><code>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID</code>]]>
    </summary>
    
      <category term="Xcode" scheme="http://linfeng1009.gitcafe.io/tags/Xcode/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用Quart2D给图片添加水印以及截取圆形图片]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/06/08/quart2d/"/>
    <id>http://linfeng1009.gitcafe.io/2015/06/08/quart2d/</id>
    <published>2015-06-08T10:34:33.000Z</published>
    <updated>2015-10-19T09:05:38.000Z</updated>
    <content type="html"><![CDATA[<p>一、添加水印<br>为了不让图片被别人滥用，造成侵权，一般都会给图片加上水印。在iOS里面添加水印可以通过[CoreGraphics]框架提供的方法来操作。<br>一般思路：<br>        1.开启一个跟原图大小一致的context<br>        2.将水印文字设置添加在原图上的位置并绘制在当前的context<br>        3.从当前的context获取新的图片<br>        4.关闭当前的context<br>    代码实现：</p>
<pre><code>+ (<span class="built_in">UIImage</span> *)imageNamed:(<span class="built_in">NSString</span> *)name waterMark:(<span class="built_in">NSString</span> *)mark
{
    <span class="built_in">CGFloat</span> textWidth = <span class="number">0</span>;
    <span class="built_in">UIImage</span> *originImage = [<span class="keyword">self</span> imageNamed:name];
    textWidth = [mark boundingRectWithSize:<span class="built_in">CGSizeMake</span>(MAXFLOAT, <span class="number">20.0</span>) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> attributes:@{<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15.0</span>]} context:<span class="literal">nil</span>]<span class="variable">.size</span><span class="variable">.width</span>;
    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(originImage<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0.0</span>);
    [originImage drawAtPoint:<span class="built_in">CGPointZero</span>];
    [mark drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">10.0</span>,<span class="number">5.0</span>) withAttributes:@{<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">22.0</span>],<span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> redColor]}];
    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();
    <span class="built_in">UIGraphicsEndImageContext</span>();

    <span class="keyword">return</span> newImage;
}
</code></pre><p> 效果图片如下：<br><img src="http://7xkpsz.com1.z0.glb.clouddn.com/watermark.png" alt="水印"></p>
<p>二、截取圆形图片<br>在平常项目开发中设计会有一些圆形的图片，例如用户头像。大多会去设置View的layer的cornerRadius和masksToBounds.<br>    self.imageView.layer.cornerRadius = 50.0;<br>    self.imageView.layer.masksToBounds = YES;<br>这样做虽然能够达到我们要的效果，每一次加载都要去将视图的图层去渲染，这样严重影响性能。在项目中不推荐这样使用，有更好的方法去达到这种效果—-截图图片<br>在原图的基础上去截取一个圆形的图片，关键点就是在原图上绘制一个正切圆。<br>    代码实现：</p>
<pre><code>+ (<span class="built_in">UIImage</span> *)circleImageWithNamed:(<span class="built_in">NSString</span> *)name
{
    <span class="built_in">UIImage</span> *originImage = [<span class="keyword">self</span> imageNamed:name];
    <span class="built_in">CGFloat</span> newImageW = originImage<span class="variable">.size</span><span class="variable">.width</span> &lt; originImage<span class="variable">.size</span><span class="variable">.height</span>? originImage<span class="variable">.size</span><span class="variable">.width</span> : originImage<span class="variable">.size</span><span class="variable">.height</span>;
    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(originImage<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0.0</span>);
    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, newImageW, newImageW)];
    [path addClip];
    [originImage drawAtPoint:<span class="built_in">CGPointZero</span>];
    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();
    <span class="built_in">UIGraphicsEndImageContext</span>();

    <span class="keyword">return</span> newImage;
}
</code></pre><p> 效果图如下：<br> <img src="http://7xkpsz.com1.z0.glb.clouddn.com/circle.png" alt="截取圆图"></p>
<p> 三、绘制纯色图片<br> 在开发过程会有遇到给Button设置背景色情况，直接设置Button的backgourndcolor就没有高亮的效果，所以直接根据颜色去绘制一张纯色的图片<br>     代码实现:</p>
<pre><code> + (<span class="built_in">UIImage</span> *)imageWith<span class="built_in">UIColor</span>:(<span class="built_in">UIColor</span> *)color
{
    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>);
    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0.0</span>);
    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();
    <span class="built_in">CGContextSetFillColorWithColor</span>(context, color<span class="variable">.CGColor</span>);
    <span class="built_in">CGContextFillRect</span>(context, rect);
    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();
    <span class="built_in">UIGraphicsEndImageContext</span>();

    <span class="keyword">return</span> image;
}
</code></pre><p>GitHub: <a href="https://github.com/ludaye123/UIImage-Quartz2D" target="_blank" rel="external">https://github.com/ludaye123/UIImage-Quartz2D</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一、添加水印<br>为了不让图片被别人滥用，造成侵权，一般都会给图片加上水印。在iOS里面添加水印可以通过[CoreGraphics]框架提供的方法来操作。<br>一般思路：<br>        1.开启一个跟原图大小一致的context<br>        2.将水印]]>
    </summary>
    
      <category term="Quart2D" scheme="http://linfeng1009.gitcafe.io/tags/Quart2D/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSLog高效打印调试信息]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/05/18/nslog/"/>
    <id>http://linfeng1009.gitcafe.io/2015/05/18/nslog/</id>
    <published>2015-05-18T09:50:01.000Z</published>
    <updated>2015-10-19T09:06:42.000Z</updated>
    <content type="html"><![CDATA[<p>打印当前的方法以及行号<br>NSMutableArray *someObject = [NSMutableArray array];<br>NSLog(@”%s:%d someObject=%@”, <strong>func</strong>, <strong>LINE</strong>, someObject);<br>[someObject addObject:@”foo”];<br>NSLog(@”%s:%d someObject=%@”, <strong>func</strong>, <strong>LINE</strong>, someObject);</p>
<p>表1 预处理的宏</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>格式说明符</th>
<th>描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>func</strong></td>
<td>%s</td>
<td>当前被调用的方法 </td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td>%d</td>
<td>当前的行号在源代码文件中 </td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td>%s</td>
<td>源代码文件的路径</td>
</tr>
<tr>
<td><strong>PRETTY_FUNCTION</strong></td>
<td>%s</td>
<td>类似 <strong>func</strong>, 但是包含详细信息在C++代码中</td>
</tr>
</tbody>
</table>
<p>项目中调试一般会定义一个宏，调试打印当前的信息，特别是在比较复杂的项目中调试。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#ifdef</span> DEBUG</span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">DSLog</span><span class="params">(...)</span></span> <span class="function"><span class="title">NSLog</span><span class="params">(@<span class="string">"%s %d \n %@ \n\n"</span>,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])</span></span></span><br><span class="line"><span class="id">#else</span></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">DSLog</span><span class="params">(...)</span></span></span><br><span class="line"><span class="id">#endif</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>打印当前的方法以及行号<br>NSMutableArray *someObject = [NSMutableArray array];<br>NSLog(@”%s:%d someObject=%@”, <strong>func</strong>, <strong>LINE<]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/04/10/hello-world/"/>
    <id>http://linfeng1009.gitcafe.io/2015/04/10/hello-world/</id>
    <published>2015-04-10T08:22:09.000Z</published>
    <updated>2015-04-10T08:22:09.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[CoreLocation 基本使用]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/02/12/corelocation-basic-use/"/>
    <id>http://linfeng1009.gitcafe.io/2015/02/12/corelocation-basic-use/</id>
    <published>2015-02-12T09:59:43.000Z</published>
    <updated>2015-10-19T09:12:43.000Z</updated>
    <content type="html"><![CDATA[<p>1.导入头文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;CoreLocation/CoreLocation.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>2.定义一个属性<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) CLLocationManager *locationManager;</span><br></pre></td></tr></table></figure></p>
<p>3.设置Get方法<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (CLLocationManager *)locationManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_locationManager)</span><br><span class="line">    &#123;</span><br><span class="line">        _locationManager = [[CLLocationManager alloc] init];</span><br><span class="line">        _locationManager.<span class="keyword">delegate</span> = self;</span><br><span class="line">        _locationManager.distanceFilter = <span class="number">100.0</span>; 	<span class="comment">// 定位距离过滤</span></span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        <span class="keyword">extern</span> const CLLocationAccuracy kCLLocationAccuracyBestForNavigation    <span class="comment">// 导航定位最好的精确度</span></span><br><span class="line">		<span class="keyword">extern</span> const CLLocationAccuracy kCLLocationAccuracyBest;				<span class="comment">// 定位最好的精确度</span></span><br><span class="line">		<span class="keyword">extern</span> const CLLocationAccuracy kCLLocationAccuracyNearestTenMeters;	<span class="comment">// 定位精确到10米</span></span><br><span class="line">		<span class="keyword">extern</span> const CLLocationAccuracy kCLLocationAccuracyHundredMeters;		<span class="comment">// 定位精确到100米</span></span><br><span class="line">		<span class="keyword">extern</span> const CLLocationAccuracy kCLLocationAccuracyKilometer;			<span class="comment">// 定位精确到1000米</span></span><br><span class="line">		<span class="keyword">extern</span> const CLLocationAccuracy kCLLocationAccuracyThreeKilometers;		<span class="comment">// 定位精确到3000米</span></span><br><span class="line">		*/</span><br><span class="line">        _locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters; <span class="comment">// 定位精确度</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _locationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.实现代理方法<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 授权状态代理方法</span></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">locationManager:</span>(CLLocationManager *)manager <span class="string">didChangeAuthorizationStatus:</span>(CLAuthorizationStatus)status</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(status == kCLAuthorizationStatusAuthorizedAlways || status == kCLAuthorizationStatusAuthorizedWhenInUse)</span><br><span class="line">    &#123;</span><br><span class="line">        [self.locationManager startUpdatingLocation];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@<span class="string">"授权失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位更新位置代理方法</span></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">locationManager:</span>(CLLocationManager *)manager <span class="string">didUpdateLocations:</span>(NSArray *)locations</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// locations包括的现在的位置</span></span><br><span class="line">    NSLog(@<span class="string">"%@"</span>,locations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.开始定位<br>在viewController的viewDidLoad方法中开启定位服务<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidLoad</span> &#123;</span><br><span class="line">    <span class="attr_selector">[super viewDidLoad]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意在iOS8中使用定位服务，由于苹果对定位服务的启用了进一步做了限制，启用定位服务需要授权</span></span><br><span class="line">    <span class="comment">// 以及需要在info.plist 文件中配置才会弹出授权提示框</span></span><br><span class="line">    <span class="comment">// NSLocationWhenInUseUsageDescription     允许在前台定位</span></span><br><span class="line">    <span class="comment">// NSLocationAlwaysUsageDescription   	   允许在前后台定位</span></span><br><span class="line">    <span class="tag">if</span>([[UIDevice currentDevice].systemVersion doubleValue] &gt;= <span class="number">8.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr_selector">[self.locationManager requestWhenInUseAuthorization]</span>;</span><br><span class="line"><span class="comment">//        [self.locationManager requestAlwaysAuthorization];</span></span><br><span class="line">		<span class="comment">// iOS8 在代理方法中确认授权成功后，启动定位服务</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="tag">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="attr_selector">[self.locationManager startUpdatingLocation]</span>;</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.CLLocation常用属性和方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) CLLocationCoordinate2D coordinate; <span class="comment">// 经纬度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) CLLocationDistance altitude; <span class="comment">// 海拔高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) CLLocationAccuracy horizontalAccuracy; <span class="comment">// 水平精确度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) CLLocationAccuracy verticalAccuracy; <span class="comment">// 垂直精确度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) CLLocationDirection course; <span class="comment">// 活动方向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) CLLocationSpeed speed; <span class="comment">// 当前活动速度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDate</span> *timestamp; <span class="comment">// 定位更新时间</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1.导入头文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="c]]>
    </summary>
    
      <category term="iOS定位" scheme="http://linfeng1009.gitcafe.io/tags/iOS%E5%AE%9A%E4%BD%8D/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS并发编程指南]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/01/18/iOS-Concurrentcy-Programming/"/>
    <id>http://linfeng1009.gitcafe.io/2015/01/18/iOS-Concurrentcy-Programming/</id>
    <published>2015-01-18T09:59:23.000Z</published>
    <updated>2015-10-19T09:16:21.000Z</updated>
    <content type="html"><![CDATA[<p>iOS Concurrency Programming Guide</p>
<p>iOS 和 Mac OS 传统的并发编程模型是线程，不过线程模型伸缩性不强，而且编写正确的线程代码也不容易。Mac OS 和 iOS 采取 asynchronous design approach 来解决并发的问题。</p>
<p>引入的异步技术有两个：</p>
<p>Grand Central Dispatch：系统管理线程，你不需要编写线程代码。只需定义想要执行的任务，然后添加到适当的dispatch queue。Grand Central Dispatch会负责创建线程和调度你的任务。系统直接提供线程管理，比应用实现更加高效。</p>
<p>Operation Queue：Objective-C对象，类似于dispatch queue。你定义想要执行的任务，并添加任务到operation queue，后者负责调度和执行这些任务。和Grand Central Dispatch一样，Operation Queue也管理了线程，更加高效。</p>
<p>Dispatch Queue</p>
<p>基于C的执行自定义任务机制。dispatch queue按先进先出的顺序，串行或并发地执行任务。serial dispaptch queue一次只能执行一个任务，直接当前任务完成才开始出列并启动下一个任务。而concurrent dispatch queue则尽可能多地启动任务并发执行。</p>
<p>优点：</p>
<p>直观而简单的编程接口</p>
<p>提供自动和整体的线程池管理</p>
<p>提供汇编级调优的速度</p>
<p>更加高效地使用内存</p>
<p>不会trap内核under load</p>
<p>异步分派任务到dispatch queue不会导致queue死锁</p>
<p>伸缩性强</p>
<p>serial dispatch queue比锁和其它同步原语更加高效</p>
<p>Dispatch Sources</p>
<p>Dispatch Sources 是基于C的系统事件异步处理机制。一个Dispatch Source封装了一个特定类型的系统事件，当事件发生时提交一个特定的block对象或函数到dispatch queue。你可以使用Dispatch Sources监控以下类型的系统事件：</p>
<p>定时器</p>
<p>信号处理器</p>
<p>描述符相关的事件</p>
<p>进程相关的事件</p>
<p>Mach port事件</p>
<p>你触发的自定义事件</p>
<p>Operation Queues</p>
<p>Operation Queues是Cocoa版本的并发dispatch queue，由 NSOperationQueue 类实现。dispatch queue总是按先进先出的顺序执行任务，而 Operation Queues 在确定任务执行顺序时，还会考虑其它因素。最主要的一个因素是指定任务是否依赖于另一个任务的完成。你在定义任务时配置依赖性，从而创建复杂的任务执行顺序图</p>
<p>提交到Operation Queues的任务必须是 NSOperation 对象，operation object封装了你要执行的工作，以及所需的所有数据。由于 NSOperation 是一个抽象基类，通常你需要定义自定义子类来执行任务。不过Foundation framework自带了一些具体子类，你可以创建并执行相关的任务。</p>
<p>Operation objects会产生key-value observing(KVO)通知，对于监控任务的进程非常有用。虽然operation queue总是并发地执行任务，你可以使用依赖，在需要时确保顺序执行</p>
<p>异步设计技术</p>
<p>通过确保主线程自由响应用户事件，并发可以很好地提高应用的响应性。通过将工作分配到多核，还能提高应用处理的性能。但是并发也带来一定的额外开销，并且使代码更加复杂，更难编写和调试代码。</p>
<p>因此在应用设计阶段，就应该考虑并发，设计应用需要执行的任务，及任务所需的数据结构。</p>
<p>Operation Queues</p>
<p>基于Objective-C，因此基于Cocoa的应用通常会使用Operation Queues</p>
<p>Operation Objects</p>
<p>operation object 是 NSOperation 类的实例，封装了应用需要执行的任务，和执行任务所需的数据。NSOperation 本身是抽象基类，我们必须实现子类。Foundation framework提供了两个具体子类，你可以直接使用：</p>
<p>类    描述<br>NSInvocationOperation    可以直接使用的类，基于应用的一个对象和selector来创建operation object。如果你已经有现有的方法来执行需要的任务，就可以使用这个类。<br>NSBlockOperation    可以直接使用的类，用来并发地执行一个或多个block对象。operation object使用“组”的语义来执行多个block对象，所有相关的block都执行完成之后，operation object才算完成。<br>NSOperation    基类，用来自定义子类operation object。继承NSOperation可以完全控制operation object的实现，包括修改操作执行和状态报告的方式。<br>所有operation objects都支持以下关键特性：</p>
<p>支持建立基于图的operation objects依赖。可以阻止某个operation运行，直到它依赖的所有operation都已经完成。</p>
<p>支持可选的completion block，在operation的主任务完成后调用。</p>
<p>支持应用使用KVO通知来监控operation的执行状态。</p>
<p>支持operation优先级，从而影响相对的执行顺序</p>
<p>支持取消，允许你中止正在执行的任务</p>
<p>并发 VS 非并发Operations</p>
<p>通常我们通过将operation添加到operation queue中来执行该操作。但是我们也可以手动调用start方法来执行一个operation对象，这样做不保证operation会并发执行。NSOperation类对象的 isConcurrent 方法告诉你这个operation相对于调用start方法的线程，是同步还是异步执行的。isConcurrent 方法默认返回NO，表示operation与调用线程同步执行。</p>
<p>如果你需要实现并发operation，也就是相对调用线程异步执行的操作。你必须添加额外的代码，来异步地启动操作。例如生成一个线程、调用异步系统函数，以确保start方法启动任务，并立即返回。</p>
<p>多数开发者从来都不需要实现并发operation对象，我们只需要将operations添加到operation queue。当你提交非并发operation到operation queue时，queue会创建线程来运行你的操作，因此也能达到异步执行的目的。只有你不希望使用operation queue来执行operation时，才需要定义并发operations。</p>
<p>创建一个 NSInvocationOperation 对象</p>
<p>如果已经现有一个方法，需要并发地执行，就可以直接创建 NSInvocationOperation 对象，而不需要自己继承 NSOperation。</p>
<p>@implementation MyCustomClass </p>
<ul>
<li>(NSOperation<em>)taskWithData:(id)data {<br>NSInvocationOperation</em> theOp = [[[NSInvocationOperation alloc] initWithTarget:self<br>selector:@selector(myTaskMethod:) object:data] autorelease]; </li>
</ul>
<p>return theOp;<br>} </p>
<p>// This is the method that does the actual work of the task. </p>
<ul>
<li>(void)myTaskMethod:(id)data {<br>// Perform the task.<br>}<br>@end<br>创建一个 NSBlockOperation 对象</li>
</ul>
<p>NSBlockOperation 对象用于封装一个或多个block对象，一般创建时会添加至少一个block，然后再根据需要添加更多的block。当 NSBlockOperation 对象执行时，会把所有block提交到默认优先级的并发dispatch queue。然后 NSBlockOperation 对象等待所有block完成执行，最后标记自己已完成。因此可以使用block operation来跟踪一组执行中的block，有点类似于thread join等待多个线程的结果。区别在于block operation本身也运行在一个单独的线程，应用的其它线程在等待block operation完成时可以继续工作。</p>
<p>NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{<br>NSLog(@”Beginning operation.\n”);<br>// Do some work.<br>}];<br>使用 addExecutionBlock: 可以添加更多block到这个block operation对象。如果需要顺序地执行block，你必须直接提交到所需的dispatch queue。</p>
<p>自定义Operation对象</p>
<p>如果block operation和invocation operation对象不符合应用的需求，你可以直接继承 NSOperation，并添加任何你想要的行为。NSOperation 类提供通用的子类继承点，而且实现了许多重要的基础设施来处理依赖和KVO通知。继承所需的工作量主要取决于你要实现非并发还是并发的operation。</p>
<p>定义非并发operation要简单许多，只需要执行主任务，并正确地响应取消事件;NSOperation 处理了其它所有事情。对于并发operation，你必须替换某些现有的基础设施代码。</p>
<p>执行主任务</p>
<p>每个operation对象至少需要实现以下方法：</p>
<p>自定义initialization方法：初始化，将operation 对象设置为已知状态</p>
<p>自定义main方法：执行你的任务</p>
<p>你也可以选择性地实现以下方法：</p>
<p>main方法中需要调用的其它自定义方法</p>
<p>Accessor方法：设置和访问operation对象的数据</p>
<p>dealloc方法：清理operation对象分配的所有内存</p>
<p>NSCoding 协议的方法：允许operation对象archive和unarchive</p>
<p>@interface MyNonConcurrentOperation : NSOperation {<br>id myData;<br>}<br>-(id)initWithData:(id)data;<br>@end </p>
<p>@implementation MyNonConcurrentOperation </p>
<ul>
<li><p>(id)initWithData:(id)data {<br>if (self = [super init])<br>myData = [data retain];<br>return self;<br>} </p>
</li>
<li><p>(void)dealloc {<br>[myData release];<br>[super dealloc];<br>} </p>
</li>
</ul>
<p>-(void)main {<br>@try {<br>NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];<br>// Do some work on myData and report the results.<br>[pool release];<br>}<br>@catch(…) {<br>// Do not rethrow exceptions.<br>}<br>}<br>@end<br>响应取消事件</p>
<p>operation开始执行之后，会一直执行任务直到完成，或者显式地取消操作。取消可能在任何时候发生，甚至在operation执行之前。尽管 NSOperation 提供了一个方法，让应用取消一个操作，但是识别出取消事件则是你的事情。如果operation直接终止，可能无法回收所有已分配的内存或资源。因此operation对象需要检测取消事件，并优雅地退出执行。</p>
<p>operation 对象定期地调用 isCancelled 方法，如果返回YES(表示已取消)，则立即退出执行。不管是自定义 NSOperation 子类，还是使用系统提供的两个具体子类，都需要支持取消。isCancelled方法本身非常轻量，可以频繁地调用而不产生大的性能损失。以下地方可能需要调用isCancelled：</p>
<p>在执行任何实际的工作之前</p>
<p>在循环的每次迭代过程中，如果每个迭代相对较长可能需要调用多次</p>
<p>代码中相对比较容易中止操作的任何地方</p>
<ul>
<li>(void)main {<br>@try {<br>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];<br>BOOL isDone = NO; </li>
</ul>
<p>while (![self isCancelled] &amp;&amp; !isDone) {<br>// Do some work and set isDone to YES when finished<br>}<br>[pool release];<br>}<br>@catch(…) {<br>// Do not rethrow exceptions.<br>}<br>}<br>注意你的代码还需要完成所有相关的资源清理工作</p>
<p>为并发执行配置operations</p>
<p>Operation对象默认按同步方式执行，也就是在调用start方法的那个线程中直接执行。由于operation queue为非并发operation提供了线程支持，对应用来说，多数operations仍然是异步执行的。但是如果你希望手工执行operations，而且仍然希望能够异步执行操作，你就必须采取适当的措施，通过定义operation对象为并发操作来实现。</p>
<p>方法    描述<br>start    （必须）所有并发操作都必须覆盖这个方法，以自定义的实现替换默认行为。手动执行一个操作时，你会调用start方法。因此你对这个方法的实现是操作的起点，设置一个线程或其它执行环境，来执行你的任务。你的实现在任何时候都绝对不能调用super。<br>main    （可选）这个方法通常用来实现operation对象相关联的任务。尽管你可以在start方法中执行任务，使用main来实现任务可以让你的代码更加清晰地分离设置和任务代码<br>isExecuting<br>isFinished    （必须）并发操作负责设置自己的执行环境，并向外部client报告执行环境的状态。因此并发操作必须维护某些状态信息，以知道是否正在执行任务，是否已经完成任务。使用这两个方法报告自己的状态。<br>这两个方法的实现必须能够在其它多个线程中同时调用。另外这些方法报告的状态变化时，还需要为相应的key path产生适当的KVO通知。<br>isConcurrent    （必须）标识一个操作是否并发operation，覆盖这个方法并返回YES</p>
<p>@interface MyOperation : NSOperation {<br>BOOL        executing;<br>BOOL        finished;<br>} </p>
<ul>
<li>(void)completeOperation;<br>@end </li>
</ul>
<p>@implementation MyOperation </p>
<ul>
<li><p>(id)init {<br>self = [super init];<br>if (self) {<br>executing = NO;<br>finished = NO;<br>}<br>return self;<br>} </p>
</li>
<li><p>(BOOL)isConcurrent {<br>return YES;<br>} </p>
</li>
<li><p>(BOOL)isExecuting {<br>return executing;<br>} </p>
</li>
<li><p>(BOOL)isFinished {<br>return finished;<br>} </p>
</li>
<li><p>(void)start {<br>// Always check for cancellation before launching the task.<br>if ([self isCancelled])<br>{<br>// Must move the operation to the finished state if it is canceled.<br>[self willChangeValueForKey:@”isFinished”];<br>finished = YES;<br>[self didChangeValueForKey:@”isFinished”];<br>return;<br>} </p>
</li>
</ul>
<p>// If the operation is not canceled, begin executing the task.<br>[self willChangeValueForKey:@”isExecuting”];<br>[NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];<br>executing = YES;<br>[self didChangeValueForKey:@”isExecuting”];<br>} </p>
<ul>
<li>(void)main {<br>@try {<br>NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init]; </li>
</ul>
<p>// Do the main work of the operation here. </p>
<p>[self completeOperation];<br>[pool release];<br>}<br>@catch(…) {<br>// Do not rethrow exceptions.<br>}<br>} </p>
<ul>
<li>(void)completeOperation {<br>[self willChangeValueForKey:@”isFinished”];<br>[self willChangeValueForKey:@”isExecuting”]; </li>
</ul>
<p>executing = NO;<br>finished = YES; </p>
<p>[self didChangeValueForKey:@”isExecuting”];<br>[self didChangeValueForKey:@”isFinished”];<br>}<br>@end<br>即使操作被取消，你也应该通知KVO observers，你的操作已经完成。当某个operation对象依赖于另一个operation对象的完成时，它会监测后者的isFinished key path。只有所有依赖的对象都报告已经完成，第一个operation对象才会开始运行。如果你的operation对象没有产生完成通知，就会阻止其它依赖于你的operation对象运行。</p>
<p>维护KVO依从</p>
<p>NSOperation类的key-value observing(KVO)依从于以下key paths：</p>
<p>isCancelled</p>
<p>isConcurrent</p>
<p>isExecuting</p>
<p>isFinished</p>
<p>isReady</p>
<p>dependencies</p>
<p>queuePriority</p>
<p>completionBlock</p>
<p>如果你覆盖start方法，或者对NSOperation对象的其它自定义运行(覆盖main除外)，你必须确保自定义对象对这些key paths保留KVO依从。覆盖start方法时，需要关注isExecuting和isFinished两个key paths。</p>
<p>如果你希望实现依赖于其它东西(非operation对象)，你可以覆盖isReady方法，并强制返回NO，直到你等待的依赖得到满足。如果你需要保留默认的依赖管理系统，确保你调用了[super isReady]。当你的operation对象的准备就绪状态发生改变时，生成一个isReady的key path的KVO通知。</p>
<p>除非你覆盖了 addDependency: 或 removeDependency: 方法，否则你不需要关注dependencies key path</p>
<p>虽然你也可以生成 NSOperation 的其它KVO通知，但通常你不需要这样做。如果需要取消一个操作，你可以直接调用现有的cancel方法。类似地，你也很少需要修改queue优先级信息。最后，除非你的operation对象可以动态地改变并发状态，你也不需要提供isConcurrent key path的KVO通知。</p>
<p>自定义一个Operation对象的执行行为</p>
<p>对Operation对象的配置发生在创建对象之后，将其添加到queue之前。</p>
<p>配置operation之间的依赖关系</p>
<p>依赖关系可以顺序地执行相关的operation对象，依赖于其它操作，则必须等到该操作完成之后自己才能开始。你可以创建一对一的依赖关系，也可以创建多个对象之间的依赖图。</p>
<p>使用 NSOperation 的 addDependency: 方法在两个operation对象之间建立依赖关系。表示当前operation对象将依赖于参数指定的目标operation对象。依赖关系不局限于相同queue中的operations对象，Operation对象会管理自己的依赖，因此完全可以在不同的queue之间的Operation对象创建依赖关系。</p>
<p>唯一的限制是不能创建环形依赖，这是程序员的错误，所有受影响的operations都无法运行!</p>
<p>当一个operation对象依赖的所有其它对象都已经执行完成，该operation就变成准备执行状态(如果你自定义了isReady方法，则由你的方法确定是否准备好运行)。如果operation已经在一个queue中，queue就可以在任何时候执行这个operation。如果你需要手动执行该operation，就自己调用operation的start方法。</p>
<p>配置依赖必须在运行operation和添加operation到queue之前进行，之后添加的依赖关系可能不起作用。</p>
<p>依赖要求每个operation对象在状态发生变化时必须发出适当的KVO通知。如果你自定义了operation对象的行为，就必须在自定义代码中生成适当的KVO通知，以确保依赖能够正确地执行。</p>
<p>修改Operation的执行优先级</p>
<p>对于添加到queue的Operations，执行顺序首先由已入队列的operations是否准备好，然后再根据所有operations的相对优先级确定。是否准备好由对象的依赖关系确定，优先级等级则是operation对象本身的一个属性。默认所有operation都拥有“普通”优先级，不过你可以通过 setQueuePriority: 方法来提升或降低operation对象的优先级。</p>
<p>优先级只能应用于相同queue中的operations。如果应用有多个operation queue，每个queue的优先级等级是互相独立的。因此不同queue中的低优先级操作仍然可能比高优先级操作更早执行。</p>
<p>优先级不能替代依赖关系，优先级只是queue对已经准备好的operations确定执行顺序。先满足依赖关系，然后再根据优先级从所有准备好的操作中选择优先级最高的那个执行。</p>
<p>修改底层线程的优先级</p>
<p>Mac OS X 10.6之后，我们可以配置operation底层线程的执行优先级，线程直接由内核管理，通常优先级高的线程会给予更多的执行机会。对于operation对象，你指定线程优先级为0.0到1.0之间的某个数值，0.0表示最低优先级，1.0表示最高优先级。默认线程优先级为0.5</p>
<p>要设置operation的线程优先级，你必须在将operation添加到queue之前，调用 setThreadPriority: 方法进行设置。当queue执行该operation时，默认的start方法会使用你指定的值来修改当前线程的优先级。不过新的线程优先级只在operation的main方法范围内有效。其它所有代码仍然(包括completion block)运行在默认线程优先级。</p>
<p>如果你创建了并发operation，并覆盖了start方法，你必须自己配置线程优先级。</p>
<p>设置一个completion block</p>
<p>在Mac OS X 10.6之后，operation可以在主任务完成之后执行一个completion block。你可以使用这个completion block来执行任何不属于主任务的工作。例如你可以使用这个block来通知相关的client，操作已经执行完成。而并发operation对象则可以使用这个block来产生最终的KVO通知。</p>
<p>调用 NSOperation 的 setCompletionBlock: 方法来设置一个completion block，你传递的block应该没有参数和返回值。</p>
<p>实现Operation对象的技巧</p>
<p>Operation对象的内存管理</p>
<p>operation对象需要良好的内存管理策略</p>
<p>创建你自己的Autorelease Pool</p>
<p>operation是Objective-C对象，你在实现任务的代码中应该创建一个autorelease pool，这样可以保护那些autorelease对象得到尽快地释放。虽然你的自定义代码执行时可能已经有了一个pool，但你不能依赖于这个行为，总是应该自己创建一个。</p>
<p>拥有自己的autorelease pool还能更加灵活地管理operation的内存。如果operation创建大量的临时对象，则可以考虑创建额外的pool，来清理不再使用的临时对象。在iOS<strong>*</strong>别需要注意，应迟早地清理不再使用的临时对象，避免内存警告。</p>
<ul>
<li>(void)main {<br>@try {<br>NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init]; </li>
</ul>
<p>// Do the main work of the operation here. </p>
<p>[pool release];<br>}<br>@catch(…) {<br>// Do not rethrow exceptions.<br>}<br>}<br>避免Per-Thread存储</p>
<p>虽然多数operation都在线程中执行，但对于非并发operation，通常由operation queue提供线程，这时候queue拥有该线程，而你的应用不应该去动这个线程。特别是不要关联任何数据到不是你创建和拥有的线程。这些线程由queue管理，根据系统和应用的需求创建或销毁。因此使用Per-Thread storage在operations之间传递数据是不可靠的，而且很有可能会失败。</p>
<p>对于operation对象，你完全没有理由使用Per-Thread Storage，应该在创建对象的时候就给它需要的所有数据。所有输入和输出数据都应该存储在operation对象中，最后再整合到你的应用，或者最终释放掉。</p>
<p>根据需要保留Operation对象的引用</p>
<p>由于operation对象异步执行，你不能创建完以后就完全不管。它们也是对象，需要你来分配和释放它们管理的任何资源，特别是如果你需要在operation对象完成后获取其中的数据。</p>
<p>由于queue总是尽最大可能快速地调度和执行operation，在你添加operation到queue时，可能立即就开始运行，当你稍后向queue请求operation对象的状态时，有可能queue已经执行完了相应的operation并从queue中删除了这个对象。因此你总是应该自己拥有operation对象的引用。</p>
<p>处理错误和异常</p>
<p>operation本质上是应用中独立的实体，因此需要自己负责处理所有的错误和异常。NSOperation默认的start方法并没有捕获异常。所以你自己的代码总是应该捕获并抑制异常。你还应该检查错误代码并适当地通知应用。如果你覆盖了start方法，你也必须捕获所有异常，阻止它离开底层线程的范围。</p>
<p>你需要准备好处理以下错误或异常：</p>
<p>检查并处理UNIX errno风格的错误代码</p>
<p>检查方法或函数显式返回的错误代码</p>
<p>捕获你的代码或系统frameworks抛出的异常</p>
<p>捕获NSOperation类自己抛出的异常，在以下情况NSOperation会抛出异常：</p>
<p>operation没有准备好，但是调用了start方法</p>
<p>operation正在执行或已经完成(可能被取消)，再次调用了start方法。</p>
<p>当你添加completion block到正在执行或已经完成的operation</p>
<p>当你试图获取已经取消 NSInvocationOperation 对象的结果</p>
<p>为Operation对象确定一个适当的范围</p>
<p>和任何对象一样，NSOperation对象也会消耗内存，执行时也会带来开销。因此如果operation对象只做很少的工作，但是却创建成千上万个小的operation对象，你就会发现更多的时间花在了调度operations而不是执行它们。</p>
<p>要高效地使用Operations，关键是在Operation执行的工作量和保持计算机繁忙之间，找到最佳的平衡。确保每个Operation都有一定的工作量可以执行。例如100个operations执行100次相同任务，可以考虑换成10个operations，每个执行10次。</p>
<p>你同样要避免向一个queue中添加过多的operations，或者持续快速地向queue中添加operation，超过queue所能处理的能力。这里可以考虑分批创建operations对象，在一批对象执行完之后，使用completion block告诉应用创建下一批operations对象。</p>
<p>执行Operations</p>
<p>应用需要执行Operations来处理相关的工作，你有几种方法来执行Operations对象。</p>
<p>添加Operations到Operation Queue</p>
<p>执行Operations最简单的方法是添加到operation queue，后者是 NSOperationQueue 对象。应用负责创建和维护自己使用的所有 NSOperationQueue 对象。</p>
<p>NSOperationQueue* aQueue = [[NSOperationQueue alloc] init];<br>调用 addOperation: 方法添加一个operation到queue，Mac OS X 10.6之后可以使用 addOperations:waitUntilFinished: 方法一次添加一组operations，或者也可以直接使用 addOperationWithBlock: 方法添加 block 对象到queue。</p>
<p>[aQueue addOperation:anOp]; // Add a single operation<br>[aQueue addOperations:anArrayOfOps waitUntilFinished:NO]; // Add multiple operations<br>[aQueue addOperationWithBlock:^{<br>/<em> Do something. </em>/<br>}];<br>Operations添加到queue后，通常短时间内就会得到运行。但是如果存在依赖，或者Operations挂起等原因，也可能需要等待。</p>
<p>注意Operations添加到queue之后，绝对不要再修改Operations对象。因为Operations对象可能会在任何时候运行，因此改变依赖或数据会产生不利的影响。你只能通过 NSOperation 的方法来查看操作的状态，是否正在运行、等待运行、已经完成等。</p>
<p>虽然 NSOperationQueue 类设计用于并发执行Operations，你也可以强制单个queue一次只能执行一个Operation。setMaxConcurrentOperationCount: 方法可以配置operation queue的最大并发操作数量。设为1就表示queue每次只能执行一个操作。不过operation执行的顺序仍然依赖于其它因素，像操作是否准备好和优先级等。因此串行化的operation queue并不等同于Grand Central Dispatch中的串行dispatch queue。</p>
<p>手动执行Operations</p>
<p>手动执行Operation，要求Operation已经准备好，isReady返回YES，此时你才能调用start方法来执行它。isReady方法与Operations依赖是结合在一起的。</p>
<p>调用start而不是main来手动执行Operation，因为start在执行你的自定义代码之前，会首先执行一些安全检查。而且start还会产生KVO通知，以正确地支持Operations的依赖机制。start还能处理Operations已经被取消的情况，此时会抛出一个异常。</p>
<p>手动执行Operation对象之前，还需要调用 isConcurrent 方法，如果返回NO，你的代码可以决定在当前线程同步执行这个Operation，或者创建一个独立的线程以异步执行。</p>
<p>下面方法演示了手动执行Operation，如果这个方法返回NO，表示不能执行，你需要设置一个定时器，稍后再次调用本方法，直到这个方法返回YES，表示已经执行Operation。</p>
<ul>
<li>(BOOL)performOperation:(NSOperation*)anOp<br>{<br>BOOL        ranIt = NO; </li>
</ul>
<p>if ([anOp isReady] &amp;&amp; ![anOp isCancelled])<br>{<br>if (![anOp isConcurrent])<br>[anOp start];<br>else<br>[NSThread detachNewThreadSelector:@selector(start)<br>toTarget:anOp withObject:nil];<br>ranIt = YES;<br>}<br>else if ([anOp isCancelled])<br>{<br>// If it was canceled before it was started,<br>//  move the operation to the finished state.<br>[self willChangeValueForKey:@”isFinished”];<br>[self willChangeValueForKey:@”isExecuting”];<br>executing = NO;<br>finished = YES;<br>[self didChangeValueForKey:@”isExecuting”];<br>[self didChangeValueForKey:@”isFinished”]; </p>
<p>// Set ranIt to YES to prevent the operation from<br>// being passed to this method again in the future.<br>ranIt = YES;<br>}<br>return ranIt;<br>}<br>取消Operations</p>
<p>一旦添加到operation queue，queue就拥有了这个对象并且不能被删除，唯一能做的事情是取消。你可以调用Operation对象的cancel方法取消单个操作，也可以调用operation queue的 cancelAllOperations 方法取消当前queue中的所有操作。</p>
<p>只有你确定不再需要Operations对象时，才应该取消它。发出取消命令会将Operations对象设置为”Canceled”状态，会阻止它被执行。由于取消也被认为是完成，依赖于它的其它Operations对象会收到适当的KVO通知，并清除依赖状态，然后得到执行。</p>
<p>因此常见的做法是当发生重大事件时，一次性取消queue中的所有操作，例如应用退出或用户请求取消操作。</p>
<p>等待Operations完成</p>
<p>为了最佳的性能，你应该尽量设计你的应用尽可能地异步操作，让应用在操作正在执行时可以去处理其它事情。</p>
<p>如果创建operation的代码需要处理operation完成后的结果，可以使用 NSOperation 的 waitUntilFinished 方法等待operation完成。通常我们应该避免编写这样的代码，阻塞当前线程可能是一种简便的解决方案，但是它引入了更多的串行代码，限制了整个应用的并发性，同时也降低了用户体验。</p>
<p>绝对不要在应用主线程中等待一个Operation，只能在第二或次要线程中等待。阻止主线程将导致应用无法响应用户事件，应用也将表现为无响应。</p>
<p>除了等待单个Operation完成，你也可以同时等待一个queue中的所有操作，使用 NSOperationQueue 的 waitUntilAllOperationsAreFinished 方法。注意在等待一个queue时，应用的其它线程仍然可以往queue中添加Operation，因此可能加长你线程的等待时间。</p>
<p>挂起和继续Queue</p>
<p>如果你想临时挂起Operations的执行，可以使用 setSuspended: 方法暂停相应的queue。不过挂起一个queue不会导致正在执行的Operation在任务中途暂停，只是简单地阻止调度新Operation执行。你可以在响应用户请求时，挂起一个queue，来暂停等待中的任务。稍后根据用户的请求，可以再次调用 setSuspended: 方法继续Queue中操作的执行。</p>
<p>Dispatch Queues</p>
<p>dispatch queues是执行任务的强大工具，允许你同步或异步地执行任意代码block。原先使用单独线程执行的所有任务都可以替换为使用dispatch queues。而dispatch queues最大的优点在于使用简单，而且更加高效。</p>
<p>dispatch queues任务的概念就是应用需要执行的一些工作，如计算、创建或修改数据结构、处理数据等等。我们使用函数或block对象来定义任务，并添加到dispatch queue。</p>
<p>dispatch queue是类似于对象的结构体，管理你提交给它的任务，而且都是先进先出的数据结构。因此queue中的任务总是以添加的顺序开始执行。Grand Central Disaptch提供了几种dispatch queues，不过你也自己创建。</p>
<p>类型    描述<br>串行    也称为private dispatch queue，每次只执行一个任务，按任务添加顺序执行。当前正在执行的任务在独立的线程中运行（不同任务的线程可能不同），dispatch queue管理了这些线程。通常串行queue主要用于对特定资源的同步访问。<br>你可以创建任意数量的串行queues，虽然每个queue本身每次只能执行一个任务，但是各个queue之间是并发执行的。<br>并发    也称为global dispatch queue，可以并发执行一个或多个任务，但是任务仍然是以添加到queue的顺序启动。每个任务运行于独立的线程中，dispatch queue管理所有线程。同时运行的任务数量随时都会变化，而且依赖于系统条件。<br>你不能创建并发dispatch queues。相反应用只能使用三个已经定义好的全局并发queues。<br>Main dispatch queue    全局可用的串行queue，在应用主线程中执行任务。这个queue与应用的 run loop 交叉执行。由于它运行在应用的主线程，main queue通常用于应用的关键同步点。<br>虽然你不需要创建main dispatch queue，但你必须确保应用适当地回收<br>应用使用dispatch queue，相比线程有很多优点，最直接的优点是简单，不用编写线程创建和管理的代码，让你集中精力编写实际工作的代码。另外系统管理线程更加高效，并且可以动态调控所有线程。</p>
<p>dispatch queue比线程具有更强的可预测性，例如两个线程访问共享资源，你可能无法控制哪个线程先后访问;但是把两个任务添加到串行queue，则可以确保两个任务对共享资源的访问顺序。同时基于queue的同步也比基于锁的线程同步机制更加高效。</p>
<p>应用有效地使用dispatch queue，要求尽可能地设计自包含、可以异步执行的任务。</p>
<p>dispatch queues的几个关键点：</p>
<p>dispatch queues相对其它dispatch queues并发地执行任务，串行化任务只能在同一个dispatch queue中实现。</p>
<p>系统决定了同时能够执行的任务数量，应用在100个不同的queues中启动100个任务，并不表示100个任务全部都在并发地执行(除非系统拥有100或更多个核)</p>
<p>系统在选择执行哪个任务时，会考虑queue的优先级。</p>
<p>queue中的任务必须在任何时候都准备好运行，注意这点和Operation对象不同。</p>
<p>private dispatch queue是引用计数的对象。你的代码中需要retain这些queue，另外dispatch source也可能添加到一个queue，从而增加retain的计数。因此你必须确保所有dispatch source都被取消，而且适当地调用release。</p>
<p>Queue相关的技术</p>
<p>除了dispatch queue，Grand Central Disaptch还提供几个相关的技术，使用queue来帮助你管理代码。</p>
<p>技术    描述<br>Dispatch group    用于监控一组block对象完成（你可以同步或异步地监控block）。Group提供了一个非常有用的同步机制，你的代码可以等待其它任务的完成<br>Dispatch semaphore    类似于传统的semaphore（信号量），但是更加高效。只有当调用线程由于信号量不可用，需要阻塞时，Dispatch semaphore才会去调用内核。如果信号量可用，就不会与内核进行交互。使用信号量可以实现对有限资源的访问控制<br>Dispatch source    Dispatch source在特定类型的系统事件发生时，会产生通知。你可以使用dispatch source来监控各种事件，如：进程通知、信号、描述符事件、等等。当事件发生时，dispatch source异步地提交你的任务到指定的dispatch queue，来进行处理。使用Block实现任务<br>Block可以非常容易地定义“自包含”的工作单元，尽管看上去非常类似于函数指针，block实际上由底层数据结构来表示，由编译器负责创建和管理。编译器对你的代码(和所有相关的数据)进行打包，封装为可以存在于堆中的格式，并在你的应用各个地方传递。</p>
<p>Block最关键的优点能够使用own lexical scope之外的变量，在函数或方法内部定义一个block时，block可以直接读取父scope中的变量。block访问的变量全部被拷贝到block在堆中的数据结构，这样block就能在稍后自由地访问这些变量。当block被添加到dispatch queue中时，这些变量通常是只读格式的。不过同步执行的Block对象，可以使用那些定义为__block的变量，对这些变量的修改会影响到调用scope。</p>
<p>Block的简单用法：</p>
<p>int x = 123;<br>int y = 456; </p>
<p>// Block declaration and assignment<br>void (^aBlock)(int) = ^(int z) {<br>    printf(“%d %d %d\n”, x, y, z);<br>}; </p>
<p>// Execute the block<br>aBlock(789);   // prints: 123 456 789 </p>
<p>设计Block时需考虑以下关键指导方针：</p>
<p>对于使用dispatch queue的异步Block，可以在Block中安全地捕获和使用父函数或方法中的scalar变量。但是Block不应该去捕获大型结构体或其它基于指针的变量，这些变量由Block的调用上下文分配和删除。在你的Block被执行时，这些指针引用的内存可能已经不存在。当然，你自己显式地分配内存(或对象)，然后让Block拥有这些内存的所有权，是安全可行的。</p>
<p>Dispatch queue对添加的Block会进行复制，在完成执行后自动释放。换句话说，你不需要在添加Block到Queue时显式地复制</p>
<p>尽管Queue执行小任务比原始线程更加高效，仍然存在创建Block和在Queue中执行的开销。如果Block做的事情太少，可能直接执行比dispatch到queue更加有效。使用性能工具来确认Block的工作是否太少</p>
<p>绝对不要针对底层线程缓存数据，然后期望在不同Block中能够访问这些数据。如果相同queue中的任务需要共享数据，应该使用dispatch queue的context指针来存储这些数据。</p>
<p>如果Block创建了大量Objective-C对象，考虑创建自己的autorelease pool，来处理这些对象的内存管理。虽然dispatch queue也有自己的autorelease pool，但不保证在什么时候会回收这些pool。</p>
<p>创建和管理Dispatch Queue</p>
<p>获得全局并发Dispatch Queue</p>
<p>并发dispatch queue可以同时并行地执行多个任务，不过并发queue仍然按先进先出的顺序来启动任务，并发queue会在之前任务完成之前就出列下一个任务并启动执行。并发queue同时执行的任务数量会根据应用和系统动态变化，各种因素包括：可用核数量、其它进程正在执行的工作数量、其它串行dispatch queue中优先任务的数量等。</p>
<p>系统给每个应用提供三个并发dispatch queue，所有应用全局共享，三个queue的区别是优先级。你不需要显式地创建这些queue，使用 dispatch_get_global_queue 函数来获取这三个queue：</p>
<p>dispatch_queue_t aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>除了默认优先级的并发queue，你还可以获得高和低优先级的两个，分别使用 DISPATCH_QUEUE_PRIORITY_HIGH 和 DISPATCH_QUEUE_PRIORITY_LOW 常量来调用上面函数。</p>
<p>虽然dispatch queue是引用计数的对象，但你不需要retain和release全局并发queue。因为这些queue对应用是全局的，retain和release调用会被忽略。</p>
<p>你也不需要存储这三个queue的引用，每次都直接调用 dispatch_get_global_queue 获得queue就行了。</p>
<p>创建串行Dispatch Queue</p>
<p>应用的任务需要按特定顺序执行时，就需要使用串行Dispatch Queue，串行queue每次只能执行一个任务。你可以使用串行queue来替代锁，保护共享资源或可变的数据结构。和锁不一样的是，串行queue确保任务按可预测的顺序执行。而且只要你异步地提交任务到串行queue，就永远不会产生死锁。</p>
<p>你必须显式地创建和管理所有你使用的串行queue，应用可以创建任意数量的串行queue，但不要为了同时执行更多任务而创建更多的串行queue。如果你需要并发地执行大量任务，应该把任务提交到全局并发Queue。</p>
<p>创建串行queue时，你需要明确自己的目的，如保护共享资源，或同步应用的某些关键行为。</p>
<p>dispatch_queue_create 函数创建串行queue，两个参数分别是queue名和一组queue属性。调试器和性能工具会显示queue的名字，便于你跟踪任务的执行。</p>
<p>dispatch_queue_t queue;<br>queue = dispatch_queue_create(“com.example.MyQueue”, NULL);<br>运行时获得公共Queue</p>
<p>Grand Central Disaptch提供函数，让应用访问几个公共dispatch queue：</p>
<p>使用 dispatch_get_current_queue 函数作为调试用途，或者测试当前queue的标识。在block对象中调用这个函数会返回block提交到的queue(这个时候queue应该正在执行中)。在block对象之外调用这个函数会返回应用的默认并发queue。</p>
<p>使用 dispatch_get_main_queue 函数获得应用主线程关联的串行dispatch queue。Cocoa 应用、调用了 dispatch_main 函数或配置了run loop(CFRunLoopRef 类型 或一个 NSRunLoop 对象)的应用，会自动创建这个queue。</p>
<p>使用 dispatch_get_global_queue 来获得共享的并发queue</p>
<p>Dispatch Queue的内存管理</p>
<p>Dispatch Queue和其它dispatch对象都是引用计数的数据类型。当你创建一个串行dispatch queue时，初始引用计数为1，你可以使用 dispatch_retain 和 dispatch_release 函数来增加和减少引用计数。当引用计数到达0时，系统会异步地销毁这个queue。</p>
<p>对dispatch对象(如queue)retain和release是很重要的，确保它们被使用时能够保留在内存中。和内存托管的Cocoa对象一样，通用的规则是如果你使用一个传递给你代码中的queue，你应该在使用前retain，使用完之后release。</p>
<p>你不需要retain或release全局dispatch queue，包括全局并发 dispatch queue和main dispatch queue。</p>
<p>即使你实现的是自动垃圾收集的应用，也需要retain和release你的dispatch queue和其它dispatch对象。Grand Central Disaptch不支持垃圾收集模型来回收内存。</p>
<p>在Queue中存储自定义上下文信息</p>
<p>所有dispatch对象(包括dispatch queue)都允许你关联custom context data。使用 dispatch_set_context 和 dispatch_get_context 函数来设置和获取对象的上下文数据。系统不会使用你的上下文数据，所以需要你自己在适当的时候分配和销毁这些数据。</p>
<p>对于Queue，你可以使用上下文数据来存储一个指针，指向Objective-C对象或其它数据结构，协助标识这个queue或代码的其它用途。你可以使用queue的finalizer函数来销毁(或解除关联)上下文数据。</p>
<p>为Queue提供一个清理函数</p>
<p>在创建串行dispatch queue之后，可以附加一个finalizer函数，在queue被销毁之前执行自定义的清理操作。使用 dispatch_set_finalizer_f 函数为queue指定一个清理函数，当queue的引用计数到达0时，就会执行该清理函数。你可以使用清理函数来解除queue关联的上下文数据，而且只有上下文指针不为NULL时才会调用这个清理函数。</p>
<p>下面例子演示了自定义finalizer函数的使用，你需要自己提供 myInitializeDataContextFunction 和 myCleanUpDataContextFunction 函数，用于初始化和清理上下文数据。</p>
<p>void myFinalizerFunction(void <em>context)<br>{<br>    MyDataContext</em> theData = (MyDataContext*)context; </p>
<pre><code><span class="comment">// Clean up the contents of the structure </span>
<span class="function">myCleanUpDataContextFunction</span>(theData); 

<span class="comment">// Now release the structure itself. </span>
<span class="function">free</span>(theData); 
</code></pre><p>} </p>
<p>dispatch_queue_t createMyQueue()<br>{<br>    MyDataContext<em>  data = (MyDataContext</em>) malloc(sizeof(MyDataContext));<br>    myInitializeDataContextFunction(data); </p>
<pre><code><span class="comment">// Create the queue and set the context data. </span>
dispatch_queue_t serialQueue <span class="subst">=</span> dispatch_queue_create(<span class="string">"com.example.CriticalTaskQueue"</span>, <span class="built_in">NULL</span>); 
<span class="keyword">if</span> (serialQueue) 
{ 
    dispatch_set_context(serialQueue, <span class="built_in">data</span>); 
    dispatch_set_finalizer_f(serialQueue, <span class="subst">&amp;</span>myFinalizerFunction); 
} 

<span class="keyword">return</span> serialQueue; 
</code></pre><p>}<br>添加任务到Queue</p>
<p>要执行一个任务，你需要将它dispatch到一个适当的dispatch queue，你可以同步或异步地dispatch一个任务，也可以单个或按组来dispatch。一旦进入到queue，queue会负责尽快地执行你的任务。</p>
<p>添加单个任务到Queue</p>
<p>你可以异步或同步地添加一个任务到Queue，尽可能地使用 dispatch_async 或 dispatch_async_f 函数异步地dispatch任务。因为添加任务到Queue中时，无法确定这些代码什么时候能够执行。因此异步地添加block或函数，可以让你立即调度这些代码的执行，然后调用线程可以继续去做其它事情。</p>
<p>特别是应用主线程一定要异步地dispatch任务，这样才能及时地响应用户事件。</p>
<p>少数时候你可能希望同步地dispatch任务，以避免竞争条件或其它同步错误。使用 dispatch_sync 和 dispatch_sync_f 函数同步地添加任务到Queue，这两个函数会阻塞，直到相应任务完成执行。</p>
<p>绝对不要在任务中调用 dispatch_sync 或 dispatch_sync_f 函数，并同步dispatch新任务到当前正在执行的queue。对于串行queue这一点特别重要，因为这样做肯定会导致死锁;而并发queue也应该避免这样做。</p>
<p>dispatch_queue_t myCustomQueue;<br>myCustomQueue = dispatch_queue_create(“com.example.MyCustomQueue”, NULL); </p>
<p>dispatch_async(myCustomQueue, ^{<br>    printf(“Do some work here.\n”);<br>}); </p>
<p>printf(“The first block may or may not have run.\n”); </p>
<p>dispatch_sync(myCustomQueue, ^{<br>    printf(“Do some more work here.\n”);<br>});<br>printf(“Both blocks have completed.\n”);<br>任务完成时执行Completion Block</p>
<p>dispatch到queue中的任务，通常与创建任务的代码独立运行。在任务完成时，应用可能希望得到通知并使用任务完成的结果数据。在传统的异步编程模型中，你可能会使用回调机制，不过dispatch queue允许你使用Completion Block。</p>
<p>Completion Block是你dispatch到queue的另一段代码，在原始任务完成时自动执行。调用代码在启动任务时通过参数提供Completion Block。任务代码只需要在完成工作时提交指定的Block或函数到指定的queue。</p>
<p>下面代码使用block实现了平均数，最后两个参数允许调用方指定一个queue和报告结果的block。在平均数函数完成计算后，会传递结果到指定的block，并dispatch到指定的queue。为了防止queue被过早地释放，必须首先retain这个queue，然后在dispatch这个Completion Block之后，再release这个queue。</p>
<p>void average_async(int *data, size_t len,<br>   dispatch_queue_t queue, void (^block)(int))<br>{<br>   // Retain the queue provided by the user to make<br>   // sure it does not disappear before the completion<br>   // block can be called.<br>   dispatch_retain(queue); </p>
<p>   // Do the work on the default concurrent queue and then<br>   // call the user-provided block with the results.<br>   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>      int avg = average(data, len);<br>      dispatch_async(queue, ^{ block(avg);}); </p>
<pre><code>// <span class="operator"><span class="keyword">Release</span> the <span class="keyword">user</span>-provided queue <span class="keyword">when</span> done 
dispatch_release(queue);</span> 
</code></pre><p>   });<br>}<br>并发地执行Loop Iteration</p>
<p>如果你使用循环执行固定次数的迭代，并发dispatch queue可能会提高性能。例如下面for循环：</p>
<p>for (i = 0; i &lt; count; i++) {<br>   printf(“%u\n”,i);<br>}<br>如果每次迭代执行的任务与其它迭代独立无关，而且循环迭代执行顺序也无关紧要的话，你可以调用 dispatch_apply 或 dispatch_apply_f 函数来替换循环。这两个函数为每次循环迭代将指定的block或函数提交到queue。当dispatch到并发queue时，就有可能同时执行多个循环迭代。</p>
<p>调用 dispatch_apply 或 dispatch_apply_f 时你可以指定串行或并发queue。并发queue允许同时执行多个循环迭代，而串行queue就没太大必要使用了。</p>
<p>和普通for循环一样，dispatch_apply 和 dispatch_apply_f 函数也是在所有迭代完成之后才会返回。因此在queue上下文执行的代码中再次调用这两个函数时，必须非常小心。如果你传递的参数是串行queue，而且正是执行当前代码的Queue，就会产生死锁。</p>
<p>另外这两个函数还会阻塞当前线程，因此在主线程中调用这两个函数同样必须小心，可能会阻止事件处理循环并无法响应用户事件。所以如果循环代码需要一定的时间执行，你可以考虑在另一个线程中调用这两个函数。</p>
<p>下面代码使用 dispatch_apply 替换了for循环，你传递的block必须包含一个参数，用来标识当前循环迭代。第一次迭代这个参数值为0，第二次时为1，最后一次值为count - 1。</p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); </p>
<p>dispatch_apply(count, queue, ^(size_t i) {<br>   printf(“%u\n”,i);<br>});<br>循环迭代执行的工作量需要仔细平衡，太多的话会降低响应性;太少则会影响整体性能，因为调度的开销大于实际执行代码。</p>
<p>在主线程中执行任务</p>
<p>Grand Central Disaptch提供一个特殊dispatch queue，可以在应用的主线程中执行任务。应用主线程设置了run loop(由CFRunLoopRef 类型或 NSRunLoop 对象管理)，就会自动创建这个queue，并且自动drain。非Cocoa应用如果不显式地设置run loop，就必须显式地调用dispatch_main 函数来显式地drain这个dispatch queue。否则虽然你可以添加任务到queue，但任务永远不会被执行。</p>
<p>调用 dispatch_get_main_queue 函数获得应用主线程的dispatch queue。添加到这个queue的任务由主线程串行化执行，因此你可以在应用的某些地方使用这个queue作为同步点。</p>
<p>任务中使用Objective-C对象</p>
<p>Grand Central Disaptch支持Cocoa内存管理机制，因此可以在提交到queue的block中自由地使用Objective-C对象。每个dispatch queue维护自己的autorelease pool确保释放autorelease对象，但是queue不保证这些对象实际释放的时间。在自动垃圾收集的应用中，Grand Central Disaptch会在垃圾收集系统中注册自己创建的每个线程。</p>
<p>如果应用消耗大量内存，并且创建大量autorelease对象，你需要创建自己的autorelease pool，用来及时地释放不再使用的对象。</p>
<p>挂起和继续queue</p>
<p>我们可以暂停一个queue以阻止它执行block对象，使用 dispatch_suspend 函数挂起一个dispatch queue;使用 dispatch_resume 函数继续dispatch queue。调用 dispatch_suspend 会增加queue的引用计数，调用 dispatch_resume 则减少queue的引用计数。当引用计数大于0时，queue就保持挂起状态。因此你必须对应地调用suspend和resume函数。</p>
<p>挂起和继续是异步的，而且只在执行block之间生效。挂起一个queue不会导致正在执行的block停止。</p>
<p>使用Dispatch Semaphore控制有限资源的使用</p>
<p>如果提交到dispatch queue中的任务需要访问某些有限资源，可以使用dispatch semaphore来控制同时访问这个资源的任务数量。dispatch semaphore和普通的信号量类似，唯一的区别是当资源可用时，需要更少的时间来获得dispatch semaphore。</p>
<p>使用dispatch semaphore的过程如下：</p>
<p>使用 dispatch_semaphore_create 函数创建semaphore，指定正数值表示资源的可用数量。</p>
<p>在每个任务中，调用 dispatch_semaphore_wait 来等待Semaphore</p>
<p>当上面调用返回时，获得资源并开始工作</p>
<p>使用完资源后，调用 dispatch_semaphore_signal 函数释放和signal这个semaphore</p>
<p>// Create the semaphore, specifying the initial pool size<br>dispatch_semaphore_t fd_sema = dispatch_semaphore_create(getdtablesize() / 2); </p>
<p>// Wait for a free file descriptor<br>dispatch_semaphore_wait(fd_sema, DISPATCH_TIME_FOREVER);<br>fd = open(“/etc/services”, O_RDONLY); </p>
<p>// Release the file descriptor when done<br>close(fd);<br>dispatch_semaphore_signal(fd_sema);<br>等待queue中的一组任务</p>
<p>Dispatch group用来阻塞一个线程，直到一个或多个任务完成执行。有时候你必须等待任务完成的结果，然后才能继续后面的处理。dispatch group也可以替代线程join。</p>
<p>基本的流程是设置一个组，dispatch任务到queue，然后等待结果。你需要使用 dispatch_group_async 函数，会关联任务到相关的组和queue。使用 dispatch_group_wait 等待一组任务完成。</p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>dispatch_group_t group = dispatch_group_create(); </p>
<p>// Add a task to the group<br>dispatch_group_async(group, queue, ^{<br>   // Some asynchronous work<br>}); </p>
<p>// Do some other work while the tasks execute. </p>
<p>// When you cannot make any more forward progress,<br>// wait on the group to block the current thread.<br>dispatch_group_wait(group, DISPATCH_TIME_FOREVER); </p>
<p>// Release the group when it is no longer needed.<br>dispatch_release(group);<br>Dispatch Queue和线程安全性</p>
<p>使用Dispatch Queue实现应用并发时，也需要注意线程安全性：</p>
<p>Dispatch queue本身是线程安全的。换句话说，你可以在应用的任意线程中提交任务到dispatch queue，不需要使用锁或其它同步机制。</p>
<p>不要在执行任务代码中调用 dispatch_sync 函数调度相同的queue，这样做会死锁这个queue。如果你需要dispatch到当前queue，需要使用 dispatch_async 函数异步调度</p>
<p>避免在提交到dispatch queue的任务中获得锁，虽然在任务中使用锁是安全的，但在请求锁时，如果锁不可用，可能会完全阻塞串行queue。类似的，并发queue等待锁也可能阻止其它任务的执行。如果代码需要同步，就使用串行dispatch queue。</p>
<p>虽然可以获得运行任务的底层线程的信息，最好不要这样做。</p>
<p>Dispatch Sources</p>
<p>现代系统通常提供异步接口，允许应用向系统提交请求，然后在系统处理请求时应用可以继续处理自己的事情。Grand Central Dispatch正是基于这个基本行为而设计，允许你提交请求，并通过block和dispatch queue报告结果。</p>
<p>dispatch source是基础数据类型，协调特定底层系统事件的处理。Grand Central Dispatch支持以下dispatch source：</p>
<p>Timer dispatch source：定期产生通知</p>
<p>Signal dispatch source：UNIX信号到达时产生通知</p>
<p>Descriptor dispatch source：各种文件和socket操作的通知</p>
<p>数据可读</p>
<p>数据可写</p>
<p>文件在文件系统中被删除、移动、重命名</p>
<p>文件元数据信息改变</p>
<p>Process dispatch source：进程相关的事件通知</p>
<p>当进程退出时</p>
<p>当进程发起fork或exec等调用</p>
<p>信号被递送到进程</p>
<p>Mach port dispatch source：Mach相关事件的通知</p>
<p>Custom dispatch source：你自己定义并自己触发</p>
<p>Dispatch source替代了异步回调函数，来处理系统相关的事件。当你配置一个dispatch source时，你指定要监测的事件、dispatch queue、以及处理事件的代码(block或函数)。当事件发生时，dispatch source会提交你的block或函数到指定的queue去执行</p>
<p>和手工提交到queue的任务不同，dispatch source为应用提供连续的事件源。除非你显式地取消，dispatch source会一直保留与dispatch queue的关联。只要相应的事件发生，就会提交关联的代码到dispatch queue去执行。</p>
<p>为了防止事件积压到dispatch queue，dispatch source实现了事件合并机制。如果新事件在上一个事件处理器出列并执行之前到达，dispatch source会将新旧事件的数据合并。根据事件类型的不同，合并操作可能会替换旧事件，或者更新旧事件的信息。</p>
<p>创建Dispatch Source</p>
<p>创建dispatch source需要同时创建事件源和dispatch source本身。事件源是处理事件所需要的native数据结构，例如基于描述符的dispatch source，你需要打开描述符;基于进程的事件，你需要获得目标程序的进程ID。</p>
<p>然后可以如下创建相应的dispatch source：</p>
<p>使用 dispatch_source_create 函数创建dispatch source</p>
<p>配置dispatch source：</p>
<p>为dispatch source设置一个事件处理器</p>
<p>对于定时器源，使用 dispatch_source_set_timer 函数设置定时器信息</p>
<p>为dispatch source赋予一个取消处理器(可选)调用 dispatch_resume 函数开始处理事件由于dispatch source必须进行额外的配置才能被使用，dispatch_source_create 函数返回的dispatch source将处于挂起状态。此时dispatch source会接收事件，但是不会进行处理。这时候你可以安装事件处理器，并执行额外的配置。</p>
<p>编写和安装一个事件处理器</p>
<p>你需要定义一个事件处理器来处理事件，可以是函数或block对象，并使用 dispatch_source_set_event_handler 或 dispatch_source_set_event_handler_f 安装事件处理器。事件到达时，dispatch source会提交你的事件处理器到指定的dispatch queue，由queue执行事件处理器。</p>
<p>事件处理器的代码负责处理所有到达的事件。如果事件处理器已经在queue中并等待处理已经到达的事件，如果此时又来了一个新事件，dispatch source会合并这两个事件。事件处理器通常只能看到最新事件的信息，不过某些类型的dispatch source也能获得已经发生以及合并的事件信息。</p>
<p>如果事件处理器已经开始执行，一个或多个新事件到达，dispatch source会保留这些事件，直到前面的事件处理器完成执行。然后以新事件再次提交处理器到queue。</p>
<p>函数事件处理器有一个context指针指向dispatch source对象，没有返回值。Block事件处理器没有参数，也没有返回值。</p>
<p>// Block-based event handler<br>void (^dispatch_block_t)(void)  </p>
<p>// Function-based event handler<br>void (<em>dispatch_function_t)(void </em>)<br>在事件处理器中，你可以从dispatch source中获得事件的信息，函数处理器可以直接使用参数指针，Block则必须自己捕获到dispatch source指针，一般block定义时会自动捕获到外部定义的所有变量。</p>
<p>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,<br>                                 myDescriptor, 0, myQueue);<br>dispatch_source_set_event_handler(source, ^{<br>   // Get some data from the source variable, which is captured<br>   // from the parent context.<br>   size_t estimated = dispatch_source_get_data(source); </p>
<p>   // Continue reading the descriptor…<br>});<br>dispatch_resume(source);<br>Block捕获外部变量允许更大的灵活性和动态性。当然，在Block中这些变量默认是只读的，虽然可以使用__block来修改捕获的变量，但是你最好不要在事件处理器中这样做。因为Dispatch source异步执行事件处理器，当事件处理器修改原始外部变量时，有可能这些变量已经不存在了。</p>
<p>下面是事件处理器能够获得的事件信息：</p>
<p>函数    描述<br>dispatch_source_get_handle    这个函数返回dispatch source管理的底层系统数据类型。</p>
<p>对于描述符dispatch source，函数返回一个int，表示关联的描述符</p>
<p>对于信号dispatch source，函数返回一个int，表示最新事件的信号数值</p>
<p>对于进程dispatch source，函数返回一个pid_t数据结构，表示被监控的进程</p>
<p>对于Mach port dispatch source，函数返回一个 mach_port_t 数据结构</p>
<p>对于其它dispatch source，函数返回的值未定义<br>dispatch_source_get_data    这个函数返回事件关联的所有未决数据。</p>
<p>对于从文件中读取数据的描述符dispatch source，这个函数返回可以读取的字节数</p>
<p>对于向文件中写入数据的描述符dispatch source，如果可以写入，则返回正数值</p>
<p>对于监控文件系统活动的描述符dispatch source，函数返回一个常量，表示发生的事件类型，参考 dispatch_source_vnode_flags_t 枚举类型</p>
<p>对于进程dispatch source，函数返回一个常量，表示发生的事件类型，参考 dispatch_source_proc_flags_t 枚举类型</p>
<p>对于Mach port dispatch source，函数返回一个常量，表示发生的事件类型，参考 dispatch_source_machport_flags_t 枚举类型</p>
<p>对于自定义dispatch source，函数返回从现有数据创建的新数据，以及传递给 dispatch_source_merge_data 函数的新数据。<br>dispatch_source_get_mask    这个函数返回用来创建dispatch source的事件标志</p>
<p>对于进程dispatch source，函数返回dispatch source接收到的事件掩码，参考 dispatch_source_proc_flags_t 枚举类型</p>
<p>对于发送权利的Mach port dispatch source，函数返回期望事件的掩码，参考 dispatch_source_mach_send_flags_t 枚举类型</p>
<p>对于自定义 “或” 的dispatch source，函数返回用来合并数据值的掩码。<br>安装一个取消处理器</p>
<p>取消处理器在dispatch soruce释放之前执行清理工作。多数类型的dispatch source不需要取消处理器，除非你对dispatch source有自定义行为需要在释放时执行。但是使用描述符或Mach port的dispatch source必须设置取消处理器，用来关闭描述符或释放Mach port。否则可能导致微妙的bug，这些结构体会被系统其它部分或你的应用在不经意间重用。</p>
<p>你可以在任何时候安装取消处理器，但通常我们在创建dispatch source时就会安装取消处理器。使用 dispatch_source_set_cancel_handler 或 dispatch_source_set_cancel_handler_f 函数来设置取消处理器。</p>
<p>下面取消处理器关闭描述符：</p>
<p>dispatch_source_set_cancel_handler(mySource, ^{<br>   close(fd); // Close a file descriptor opened earlier.<br>});<br>修改目标Queue</p>
<p>在创建dispatch source时可以指定一个queue，用来执行事件处理器和取消处理器。不过你也可以使用 dispatch_set_target_queue 函数在任何时候修改目标queue。修改queue可以改变执行dispatch source事件的优先级。</p>
<p>修改dispatch source的目标queue是异步操作，dispatch source会尽可能快地完成这个修改。如果事件处理器已经进入queue并等待处理，它会继续在原来的Queue中执行。随后到达的所有事件的处理器都会在后面修改的queue中执行。</p>
<p>关联自定义数据到dispatch source</p>
<p>和Grand Central Dispatch的其它类型一样，你可以使用 dispatch_set_context 函数关联自定义数据到dispatch source。使用context指针存储事件处理器需要的任何数据。如果你在context指针中存储了数据，你就应该安装一个取消处理器，在dispatch source不再需要时释放这些context自定义数据。</p>
<p>如果你使用block实现事件处理器，你也可以捕获本地变量，并在Block中使用。虽然这样也可以代替context指针，但是你应该明智地使用Block捕获变量。因为dispatch source长时间存在于应用中，Block捕获指针变量时必须非常小心，因为指针指向的数据可能会被释放，因此需要复制数据或retain。不管使用哪种方法，你都应该提供一个取消处理器，在最后释放这些数据。</p>
<p>Dispatch Source的内存管理</p>
<p>Dispatch Source也是引用计数的数据类型，初始计数为1，可以使用 dispatch_retain 和 dispatch_release 函数来增加和减少引用计数。引用计数到达0时，系统自动释放dispatch source数据结构。</p>
<p>dispatch source的所有权可以由dispatch source内部或外部进行管理。外部所有权时，另一个对象拥有dispatch source，并负责在不需要时释放它。内部所有权时，dispatch source自己拥有自己，并负责在适当的时候释放自己。虽然外部所有权很常用，当你希望创建自主dispatch source，并让它自己管理自己的行为时，可以使用内部所有权。例如dispatch source应用单一全局事件时，可以让它自己处理该事件，并立即退出。</p>
<p>Dispatch Source示例</p>
<p>创建一个定时器</p>
<p>定时器dispatch source定时产生事件，可以用来发起定时执行的任务，如游戏或其它图形应用，可以使用定时器来更新屏幕或动画。你也可以设置定时器，并在固定间隔事件中检查服务器的新信息。</p>
<p>所有定时器dispatch source都是间隔定时器，一旦创建，会按你指定的间隔定期递送事件。你需要为定时器dispatch source指定一个期望的定时器事件精度，也就是leeway值，让系统能够灵活地管理电源并唤醒内核。例如系统可以使用leeway值来提前或延迟触发定时器，使其更好地与其它系统事件结合。创建自己的定时器时，你应该尽量指定一个leeway值。</p>
<p>就算你指定leeway值为0，也不要期望定时器能够按照精确的纳秒来触发事件。系统会尽可能地满足你的需求，但是无法保证完全精确的触发时间。</p>
<p>当计算机睡眠时，定时器dispatch source会被挂起，稍后系统唤醒时，定时器dispatch source也会自动唤醒。根据你提供的配置，暂停定时器可能会影响定时器下一次的触发。如果定时器dispatch source使用 dispatch_time 函数或 DISPATCH_TIME_NOW 常量设置，定时器dispatch source会使用系统默认时钟来确定何时触发，但是默认时钟在计算机睡眠时不会继续。</p>
<p>如果你使用 dispatch_walltime 函数来设置定时器dispatch source，则定时器会根据挂钟时间来跟踪，这种定时器比较适合触发间隔相对比较大的场合，可以防止定时器触发间隔出现太大的误差。</p>
<p>下面是定时器dispatch source的一个例子，每30秒触发一次，leeway值为1，因为间隔相对较大，使用 dispatch_walltime 来创建定时器。定时器会立即触发第一次，随后每30秒触发一次。 MyPeriodicTask 和 MyStoreTimer 是自定义函数，用于实现定时器的行为，并存储定时器到应用的数据结构。</p>
<p>dispatch_source_t CreateDispatchTimer(uint64_t interval,<br>              uint64_t leeway,<br>              dispatch_queue_t queue,<br>              dispatch_block_t block)<br>{<br>   dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,<br>                                                     0, 0, queue);<br>   if (timer)<br>   {<br>      dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), interval, leeway);<br>      dispatch_source_set_event_handler(timer, block);<br>      dispatch_resume(timer);<br>   }<br>   return timer;<br>} </p>
<p>void MyCreateTimer()<br>{<br>   dispatch_source_t aTimer = CreateDispatchTimer(30ull <em> NSEC_PER_SEC,<br>                               1ull </em> NSEC_PER_SEC,<br>                               dispatch_get_main_queue(),<br>                               ^{ MyPeriodicTask(); }); </p>
<p>   // Store it somewhere for later use.<br>    if (aTimer)<br>    {<br>        MyStoreTimer(aTimer);<br>    }<br>}<br>虽然定时器dispatch source是接收时间事件的主要方法，你还可以使用其它选择。如果想在指定时间间隔后执行一个block，可以使用 dispatch_after 或 dispatch_after_f 函数。这两个函数非常类似于dispatch_async，但是只允许你指定一个时间值，时间一到就自动提交block到queue中执行，时间值可以指定为相对或绝对时间。</p>
<p>从描述符中读取数据</p>
<p>要从文件或socket中读取数据，需要打开文件或socket，并创建一个 DISPATCH_SOURCE_TYPE_READ 类型的dispatch source。你指定的事件处理器必须能够读取和处理描述符中的内容。对于文件，需要读取文件数据，并为应用创建适当的数据结构;对于网络socket，需要处理最新接收到的网络数据。</p>
<p>读取数据时，你总是应该配置描述符使用非阻塞操作，虽然你可以使用 dispatch_source_get_data 函数查看当前有多少数据可读，但在你调用它和实际读取数据之间，可用的数据数量可能会发生变化。如果底层文件被截断，或发生网络错误，从描述符中读取会阻塞当前线程，停止在事件处理器中间并阻止dispatch queue去执行其它任务。对于串行queue，这样还可能会死锁，即使是并发queue，也会减少queue能够执行的任务数量。</p>
<p>下面例子配置dispatch source从文件中读取数据，事件处理器读取指定文件的全部内容到缓冲区，并调用一个自定义函数来处理这些数据。调用方可以使用返回的dispatch source在读取操作完成之后，来取消这个事件。为了确保dispatch queue不会阻塞，这里使用了fcntl函数，配置文件描述符执行非阻塞操作。dispatch source安装了取消处理器，确保最后关闭了文件描述符。</p>
<p>dispatch_source_t ProcessContentsOfFile(const char* filename)<br>{<br>   // Prepare the file for reading.<br>   int fd = open(filename, O_RDONLY);<br>   if (fd == -1)<br>      return NULL;<br>   fcntl(fd, F_SETFL, O_NONBLOCK);  // Avoid blocking the read operation </p>
<p>   dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>   dispatch_source_t readSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,<br>                                   fd, 0, queue);<br>   if (!readSource)<br>   {<br>      close(fd);<br>      return NULL;<br>   } </p>
<p>   // Install the event handler<br>   dispatch_source_set_event_handler(readSource, ^{<br>      size_t estimated = dispatch_source_get_data(readSource) + 1;<br>      // Read the data into a text buffer.<br>      char<em> buffer = (char</em>)malloc(estimated);<br>      if (buffer)<br>      {<br>         ssize_t actual = read(fd, buffer, (estimated));<br>         Boolean done = MyProcessFileData(buffer, actual);  // Process the data. </p>
<pre><code>     // <span class="keyword">Release</span> the <span class="keyword">buffer</span> <span class="keyword">when</span> done. 
     free(<span class="keyword">buffer</span>); 

     // <span class="keyword">If</span> there <span class="keyword">is</span> no more data, cancel the source. 
     <span class="keyword">if</span> (done) 
        dispatch_source_cancel(readSource); 
  } 
}); 
</code></pre><p>   // Install the cancellation handler<br>   dispatch_source_set_cancel_handler(readSource, ^{close(fd);}); </p>
<p>   // Start reading the file.<br>   dispatch_resume(readSource);<br>   return readSource;<br>}<br>在这个例子中，自定义的 MyProcessFileData 函数确定读取到足够的数据，返回YES告诉dispatch source读取已经完成，可以取消任务。通常读取描述符的dispatch source在还有数据可读时，会重复调度事件处理器。如果socket连接关闭或到达文件末尾，dispatch source自动停止调度事件处理器。如果你自己确定不再需要dispatch source，也可以手动取消它。</p>
<p>向描述符写入数据</p>
<p>向文件或socket写入数据非常类似于读取数据，配置描述符为写入操作后，创建一个 DISPATCH_SOURCE_TYPE_WRITE 类型的dispatch source，创建好之后，系统会调用事件处理器，让它开始向文件或socket写入数据。当你完成写入后，使用 dispatch_source_cancel 函数取消dispatch source。</p>
<p>写入数据也应该配置文件描述符使用非阻塞操作，虽然 dispatch_source_get_data 函数可以查看当前有多少可用写入空间，但这个值只是建议性的，而且在你执行写入操作时可能会发生变化。如果发生错误，写入数据到阻塞描述符，也会使事件处理器停止在执行中途，并阻止dispatch queue执行其它任务。串行queue会产生死锁，并发queue则会减少能够执行的任务数量。</p>
<p>下面是使用dispatch source写入数据到文件的例子，创建文件后，函数传递文件描述符到事件处理器。MyGetData函数负责提供要写入的数据，在数据写入到文件之后，事件处理器取消dispatch source，阻止再次调用。此时dispatch source的拥有者需负责释放dispatch source。</p>
<p>dispatch_source_t WriteDataToFile(const char* filename)<br>{<br>    int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC,<br>                      (S_IRUSR | S_IWUSR | S_ISUID | S_ISGID));<br>    if (fd == -1)<br>        return NULL;<br>    fcntl(fd, F_SETFL); // Block during the write. </p>
<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); 
dispatch_<span class="built_in">source</span>_t writeSource = dispatch_<span class="built_in">source</span>_create(DISPATCH_SOURCE_TYPE_WRITE, 
                        fd, <span class="number">0</span>, queue); 
<span class="keyword">if</span> (!writeSource) 
{ 
    close(fd); 
    <span class="built_in">return</span> NULL; 
} 

dispatch_<span class="built_in">source</span>_<span class="built_in">set</span>_event_handler(writeSource, ^{ 
    size_t bufferSize = MyGetDataSize(); 
    void* buffer = malloc(bufferSize); 

    size_t actual = MyGetData(buffer, bufferSize); 
    write(fd, buffer, actual); 

    free(buffer); 

    // Cancel and release the dispatch <span class="built_in">source</span> when done. 
    dispatch_<span class="built_in">source</span>_cancel(writeSource); 
}); 

dispatch_<span class="built_in">source</span>_<span class="built_in">set</span>_cancel_handler(writeSource, ^{close(fd);}); 
dispatch_resume(writeSource); 
<span class="built_in">return</span> (writeSource); 
</code></pre><p>}<br>监控文件系统对象</p>
<p>如果需要监控文件系统对象的变化，可以设置一个 DISPATCH_SOURCE_TYPE_VNODE 类型的dispatch source，你可以从这个dispatch source中接收文件删除、写入、重命名等通知。你还可以得到文件的特定元数据信息变化通知。</p>
<p>在dispatch source正在处理事件时，dispatch source中指定的文件描述符必须保持打开状态。</p>
<p>下面例子监控一个文件的文件名变化，并在文件名变化时执行一些操作(自定义的 MyUpdateFileName 函数)。由于文件描述符专门为dispatch source打开，dispatch source安装了取消处理器来关闭文件描述符。这个例子中的文件描述符关联到底层的文件系统对象，因此同一个dispatch source可以用来检测多次文件名变化。</p>
<p>dispatch_source_t MonitorNameChangesToFile(const char* filename)<br>{<br>   int fd = open(filename, O_EVTONLY);<br>   if (fd == -1)<br>      return NULL; </p>
<p>   dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>   dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE,<br>                fd, DISPATCH_VNODE_RENAME, queue);<br>   if (source)<br>   {<br>      // Copy the filename for later use.<br>      int length = strlen(filename);<br>      char<em> newString = (char</em>)malloc(length + 1);<br>      newString = strcpy(newString, filename);<br>      dispatch_set_context(source, newString); </p>
<pre><code>// <span class="operator"><span class="keyword">Install</span> the <span class="keyword">event</span> <span class="keyword">handler</span> <span class="keyword">to</span> process the name <span class="keyword">change</span> 
dispatch_source_set_event_handler(source, ^{ 
      const <span class="built_in">char</span>*  oldFilename = (<span class="built_in">char</span>*)dispatch_get_context(source);</span> 
      MyUpdateFileName(oldFilename, fd); 
}); 

// <span class="operator"><span class="keyword">Install</span> a cancellation <span class="keyword">handler</span> <span class="keyword">to</span> free the <span class="keyword">descriptor</span> 
// <span class="keyword">and</span> the stored <span class="keyword">string</span>. 
dispatch_source_set_cancel_handler(source, ^{ 
    <span class="built_in">char</span>* fileStr = (<span class="built_in">char</span>*)dispatch_get_context(source);</span> 
    free(fileStr); 
    close(fd); 
}); 

// <span class="operator"><span class="keyword">Start</span> processing <span class="keyword">events</span>. 
dispatch_resume(source);</span> 
</code></pre><p>   }<br>   else<br>      close(fd); </p>
<p>   return source;<br>}<br>监测信号</p>
<p>应用可以接收许多不同类型的信号，如不可恢复的错误(非法指令)、或重要信息的通知(如子进程退出)。传统编程中，应用使用 sigaction 函数安装信号处理器函数，信号到达时同步处理信号。如果你只是想信号到达时得到通知，并不想实际地处理该信号，可以使用信号dispatch source来异步处理信号。</p>
<p>信号dispatch source不能替代 sigaction 函数提供的同步信号处理机制。同步信号处理器可以捕获一个信号，并阻止它中止应用。而信号dispatch source只允许你监测信号的到达。此外，你不能使用信号dispatch source获取所有类型的信号，如SIGILL, SIGBUS, SIGSEGV信号。</p>
<p>由于信号dispatch source在dispatch queue中异步执行，它没有同步信号处理器的一些限制。例如信号dispatch source的事件处理器可以调用任何函数。灵活性增大的代价是，信号到达和dispatch source事件处理器被调用的延迟可能会增大。</p>
<p>下面例子配置信号dispatch source来处理SIGHUP信号，事件处理器调用 MyProcessSIGHUP 函数，用来处理信号。</p>
<p>void InstallSignalHandler()<br>{<br>   // Make sure the signal does not terminate the application.<br>   signal(SIGHUP, SIG_IGN); </p>
<p>   dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>   dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGHUP, 0, queue); </p>
<p>   if (source)<br>   {<br>      dispatch_source_set_event_handler(source, ^{<br>         MyProcessSIGHUP();<br>      }); </p>
<pre><code><span class="comment">// Start processing signals </span>
dispatch_resume<span class="comment">(source)</span>; 
</code></pre><p>   }<br>}<br>监控进程</p>
<p>进程dispatch source可以监控特定进程的行为，并适当地响应。父进程可以使用dispatch source来监控自己创建的所有子进程，例如监控子进程的死亡;类似地，子进程也可以使用dispatch source来监控父进程，例如在父进程退出时自己也退出。</p>
<p>下面例子安装了一个进程dispatch source，监控父进程的终止。当父进程退出时，dispatch source设置一些内部状态信息，告知子进程自己应该退出。MySetAppExitFlag 函数应该设置一个适当的标志，允许子进程终止。由于dispatch source自主运行，因此自己拥有自己，在程序关闭时会取消并释放自己。</p>
<p>void MonitorParentProcess()<br>{<br>   pid_t parentPID = getppid(); </p>
<p>   dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>   dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC,<br>                                                      parentPID, DISPATCH_PROC_EXIT, queue);<br>   if (source)<br>   {<br>      dispatch_source_set_event_handler(source, ^{<br>         MySetAppExitFlag();<br>         dispatch_source_cancel(source);<br>         dispatch_release(source);<br>      });<br>      dispatch_resume(source);<br>   }<br>}<br>取消一个Dispatch Source</p>
<p>除非你显式地调用 dispatch_source_cancel 函数，dispatch source将一直保持活动，取消一个dispatch source会停止递送新事件，并且不能撤销。因此你通常在取消dispatch source后立即释放它：</p>
<p>void RemoveDispatchSource(dispatch_source_t mySource)<br>{<br>   dispatch_source_cancel(mySource);<br>   dispatch_release(mySource);<br>} </p>
<p>取消一个dispatch source是异步操作，调用 dispatch_source_cancel 之后，不会再有新的事件被处理，但是正在被dispatch source处理的事件会继续被处理完成。在处理完最后的事件之后，dispatch source会执行自己的取消处理器。</p>
<p>取消处理器是你最后的执行机会，在那里执行内存或资源的释放工作。例如描述符或mach port类型的dispatch source，必须提供取消处理器，用来关闭描述符或mach port</p>
<p>挂起和继续Dispatch Source</p>
<p>你可以使用 dispatch_suspend 和 dispatch_resume 临时地挂起和继续dispatch source的事件递送。这两个函数分别增加和减少dispatch 对象的挂起计数。因此，你必须每次 dispatch_suspend 调用之后，都需要相应的 dispatch_resume 才能继续事件递送。</p>
<p>挂起一个dispatch source期间，发生的任何事件都会被累积，直到dispatch source继续。但是不会递送所有事件，而是先合并到单一事件，然后再一次递送。例如你监控一个文件的文件名变化，就只会递送最后一次的变化事件。</p>
<p>Migrating Away from Threads</p>
<p>从现有的线程代码迁移到Grand Central Dispatch和Operation对象有许多方法，尽管可能不是所有线程代码都能够执行迁移，但是迁移可能提升性能，并简化你的代码。</p>
<p>使用dispatch queue和Operaiton queue相比线程拥有许多优点：</p>
<p>应用不再需要存储线程栈到内存空间</p>
<p>消除了创建和配置线程的代码</p>
<p>消除了管理和调度线程工作的代码</p>
<p>简化了你要编写的代码</p>
<p>使用Dispatch Queue替代线程</p>
<p>首先考虑应用可能使用线程的几种方式：</p>
<p>单一任务线程：创建一个线程执行单一任务，任务完成时释放线程</p>
<p>工作线程(Worker)：创建一个或多个工作线程执行特定的任务，定期地分配任务给每个线程</p>
<p>线程池：创建一个通用的线程池，并为每个线程设置run loop，当你需要执行一个任务时，从池中抓取一个线程，并分配任务给它。如果没有空闲线程可用，任务进入等待队列。</p>
<p>虽然这些看上去是完全不同的技术，但实际上只是相同原理的变种。应用都是使用线程来执行某些任务，区别在于管理线程和任务排队的代码。使用dispatch queue和operation queue，你可以消除所有线程、及线程通信的代码，集中精力编写处理任务的代码。</p>
<p>如果你使用了上面的线程模型，你应该已经非常了解应用需要执行的任务类型，只需要封装任务到Operation对象或Block对象，然后dispatch到适当的queue，就一切搞定!</p>
<p>对于那些不使用锁的任务，你可以直接使用以下方法来进行迁移：</p>
<p>单一任务线程，封装任务到block或operation对象，并提交到并发queue</p>
<p>工作线程，首先你需要确定使用串行queue还是并发queue，如果工作线程需要同步特定任务的执行，就应该使用串行queue。如果工作线程只是执行任意任务，任务之间并无关联，就应该使用并发queue</p>
<p>线程池，封装任务到block或operation对象，并提交到并发queue中执行</p>
<p>当然，上面只是简单的情况。如果任务会争夺共享资源，理想的解决方案当然是消除或最小化共享资源的争夺。如果有办法重构代码，消除任务彼此对共享资源的依赖，这是最理想的。</p>
<p>如果做不到消除共享资源依赖，你仍然可以使用queue，因为queue能够提供可预测的代码执行顺序。可预测意味着你不需要锁或其它重量级的同步机制，就可以实现代码的同步执行。</p>
<p>你可以使用queue来取代锁执行以下任务：</p>
<p>如果任务必须按特定顺序执行，提交到串行dispatch queue;如果你想使用Operation queue，就使用Operation对象依赖来确保这些对象的执行顺序。</p>
<p>如果你已经使用锁来保护共享资源，创建一个串行queue来执行任务并修改该资源。串行queue可以替换现有的锁，直接作为同步机制使用。</p>
<p>如果你使用线程join来等待后台任务完成，考虑使用dispatch group;也可以使用一个 NSBlockOperation 对象，或者Operation对象依赖，同样可以达到group-completion的行为。</p>
<p>如果你使用“生产者-消费者”模型来管理有限资源池，考虑使用 dispatch queue 来简化“生产者-消费者”</p>
<p>如果你使用线程来读取和写入描述符，或者监控文件操作，使用dispatch source</p>
<p>记住queue不是替代线程的万能药!queue提供的异步编程模型适合于延迟无关紧要的场合。虽然queue提供配置任务执行优先级的方法，但更高的优先级也不能确保任务一定能在特定时间得到执行。因此线程仍然是实现最小延迟的适当选择，例如音频和视频playback等场合。</p>
<p>消除基于锁的代码</p>
<p>在线程代码中，锁是传统的多个线程之间同步资源的访问机制。但是锁的开销本身比较大，线程还需等待锁的释放。</p>
<p>使用queue替代基于锁的线程代码，消除了锁带来的开销，并且简化了代码编写。你可以将任务放到串行queue，来控制任务对共享资源的访问。queue的开销要远远小于锁，因为将任务放入queue不需要陷入内核来获得mutex</p>
<p>将任务放入queue时，你做的主要决定是同步还是异步，异步提交任务到queue让当前线程继续运行;同步提交任务则阻塞当前线程，直到任务执行完成。两种机制各有各的用途，不过通常异步优先于同步。</p>
<p>实现异步锁</p>
<p>异步锁可以保护共享资源，而又不阻塞任何修改资源的代码。当代码的部分工作需要修改一个数据结构时，可以使用异步锁。使用传统的线程，你的实现方式是：获得共享资源的锁，做必要的修改，释放锁，继续任务的其它部分工作。但是使用dispatch queue，调用代码可以异步修改，无需等待这些修改操作完成。</p>
<p>下面是异步锁实现的一个例子，受保护的资源定义了自己的串行dispatch queue。调用代码提交一个block到这个queue，在block中执行对资源的修改。由于queue串行的执行所有block，对这个资源的修改可以确保按顺序进行;而且由于任务是异步执行的，调用线程不会阻塞。</p>
<p>dispatch_async(obj-&gt;serial_queue, ^{</p>
<p>// Critical section</p>
<p>});</p>
<p>同步执行临界区</p>
<p>如果当前代码必须等到指定任务完成，你可以使用 dispatch_sync 函数同步的提交任务，这个函数将任务添加到dispatch queue，并阻塞当前线程直到任务完成执行。dispatch queue本身可以是串行或并发queue，你可以根据具体的需要来选择使用。由于 dispatch_sync 函数会阻塞当前线程，你只应该在确实需要的时候才使用。</p>
<p>下面是使用 dispatch_sync 实现临界区的例子：</p>
<p>dispatch_sync(my_queue, ^{</p>
<p>// Critical section</p>
<p>});</p>
<p>如果你已经使用串行queue保护一个共享资源，同步提交到串行queue，并不能比异步提交提供更多的保护。同步提交的唯一理由是，阻止当前代码在临界区完成之前继续执行。如果当前代码不需要等待临界区完成，或者可以简单的提交接下来的任务到相同的串行queue，就应该使用异步提交。</p>
<p>改进循环代码</p>
<p>如果循环每次迭代执行的工作互相独立，可以考虑使用 dispatch_apply 或 dispatch_apply_f 函数来重新实现循环。这两个函数将循环的每次迭代提交到dispatch queue进行处理。结合并发queue使用时，可以并发地执行迭代以提高性能。</p>
<p>dispatch_apply 和 dispatch_apply_f 是同步函数，会阻塞当前线程直到所有循环迭代执行完成。当提交到并发queue时，循环迭代的执行顺序是不确定的。因此你用来执行循环迭代的Block对象(或函数)必须可重入(reentrant)。</p>
<p>下面例子使用dispatch来替换循环，你传递给 dispatch_apply 或 dispatch_apply_f 的Block或函数必须有一个整数参数，用来标识当前的循环迭代：</p>
<p>queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>
<p>dispatch_apply(count, queue, ^(size_t i) {</p>
<p>printf(“%u\n”, i);</p>
<p>});</p>
<p>你需要明智地使用这项技术，因为dispatch queue的开销虽然非常小，但仍然存在，你的循环代码必须拥有足够的工作量，才能忽略掉dispatch queue的这些开销。</p>
<p>提升每次循环迭代工作量最简单的办法是striding(跨步)，重写block代码执行多个循环迭代。从而减少了 dispatch_apply 函数指定的count值。</p>
<p>int stride = 137;</p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>
<p>dispatch_apply(count / stride, queue, ^(size_t idx){</p>
<p>size_t j = idx * stride;</p>
<p>size_t j_stop = j + stride;</p>
<p>do {</p>
<p>printf(“%u\n”, (unsigned int)j++);</p>
<p>}while (j &lt; j_stop);</p>
<p>});</p>
<p>// 执行剩余的循环迭代</p>
<p>size_t i;</p>
<p>for (i = count - (count % stride); i &lt; count; i++)</p>
<p>printf(“%u\n”, (unsigned int)i);</p>
<p>如果循环迭代次数非常多，使用stride可以提升性能。</p>
<p>替换线程Join</p>
<p>线程join允许你生成多个线程，然后让当前线程等待所有线程完成。线程创建子线程时指定为joinable，如果父线程在子线程完成之前不能继续处理，就可以join子线程。join会阻塞父线程直到子线程完成任务并退出，这时候父线程可以获得子线程的结果状态，并继续自己的工作。父线程可以一次性join多个子线程。</p>
<p>Dispatch Group提供了类似于线程join的语义，但拥有更多优点。dispatch group可以让线程阻塞直到一个或多个任务完成。和线程join不一样的是，dispatch goup同时等待所有子任务完成。而且由于dispatch group使用dispatch queue来执行任务，更加高效。</p>
<p>以下步骤可以使用dispatch group替换线程join：</p>
<p>使用 dispatch_group_create 函数创建一个新的dispatch group</p>
<p>使用 dispatch_group_async 或 dispatch_group_async_f 函数添加任务到Group，这些是你要等待完成的任务</p>
<p>如果当前线程不能继续处理任何工作，调用 dispatch_group_wait 函数等待这个group，会阻塞当前线程直到group中的所有任务执行完成。</p>
<p>如果你使用Operation对象来实现任务，可以使用依赖来实现线程join。不过这时候不是让父线程等待所有任务完成，而是将父代码移到一个Operation对象，然后设置父Operation对象依赖于所有子Operation对象。这样父Operation对象就会等到所有子Operation执行完成后才开始执行。</p>
<p>修改“生产者-消费者”实现</p>
<p>生产者-消费者 模型可以管理有限数量动态生产的资源。生产者生成新资源，消费者等待并消耗这些资源。实现生产者-消费者模型的典型机制是条件或信号量。</p>
<p>使用条件(Condition)时，生产者线程通常如下：</p>
<p>锁住与condition关联的mutex(使用pthread_mutex_lock)</p>
<p>生产资源(或工作)</p>
<p>Signal条件变量，通知有资源(或工作)可以消费(使用pthread_cond_signal)</p>
<p>解锁mutex(使用pthread_mutex_unlock)</p>
<p>对应的消费者线程则如下：</p>
<p>锁住condition关联的mutex(使用pthread_mutex_lock)</p>
<p>设置一个while循环[list=1]</p>
<p>检查是否有资源(或工作)</p>
<p>如果没有资源(或工作)，调用pthread_cond_wait阻塞当前线程，直到相应的condition触发</p>
<p>获得生产者提供的资源(或工作)解锁mutex(使用pthread_mutex_unlock)处理资源(或工作)使用dispatch queue，你可以简化生产者-消费者为一个调用：</p>
<p>dispatch_async(queue, ^{</p>
<p>// Process a work item.</p>
<p>});</p>
<p>当生产者有工作需要做时，只需要将工作添加到queue，并让queue去处理该工作。唯一需要确定的是queue的类型，如果生产者生成的任务需要按特定顺序执行，就使用串行queue;否则使用并发Queue，让系统尽可能多地同时执行任务。</p>
<p>替换Semaphore代码</p>
<p>使用信号量可以限制对共享资源的访问，你应该考虑使用dispatch semaphore来替换普通信号量。传统的信号量需要陷入内核，而dispatch semaphore可以在用户空间快速地测试状态，只有测试失败调用线程需要阻塞时才会陷入内核。这样dispatch semaphore拥有比传统semaphore快得多的性能。两者的行为是一致的。</p>
<p>替换Run-Loop代码</p>
<p>如果你使用run loop来管理一个或多个线程执行的工作，你会发现使用queue来实现和维护任务会简单许多。设置自定义run loop需要同时设置底层线程和run loop本身。run-loop代码则需要设置一个或多个run loop source，并编写回调来处理这些source事件到达。你可以创建一个串行queue，并dispatch任务到queue中，这样一行代码就能够替换原有的run-loop创建代码：</p>
<p>dispatch_queue_t myNewRunLoop = dispatch_queue_create(“com.apple.MyQueue”, NULL);</p>
<p>由于queue自动执行添加进来的任务，不需要编写额外的代码来管理queue。你也不需要创建和配置线程，更不需要创建或附加任何run-loop source。此外，你可以通过简单地添加任务就能让queue执行其它类型的任务，而run loop要实现这一点，必须修改现有run loop source，或者创建一个新的run loop source。</p>
<p>run loop的一个常用配置是处理网络socket异步到达的数据，现在你可以附加dispatch source到需要的queue中，来实现这个行为。dispatch source还能提供更多处理数据的选项，支持更多类型的系统事件处理。</p>
<p>与POSIX线程的兼容性</p>
<p>Grand Central Dispatch管理了任务和运行线程之间的关系，通常你应该避免在任务代码中使用POSIX线程函数，如果一定要使用，请小心。</p>
<p>应用不能删除或mutate不是自己创建的数据结构。使用dispatch queue执行的block对象不能调用以下函数：</p>
<p>pthread_detach</p>
<p>pthread_cancel</p>
<p>pthread_join</p>
<p>pthread_kill</p>
<p>pthread_exit</p>
<p>任务运行时修改线程状态是可以的，但你必须还原线程原来的状态。只要你记得还原线程的状态，下面函数是安全的：</p>
<p>pthread_setcancelstate</p>
<p>pthread_setcanceltype</p>
<p>pthread_setschedparam</p>
<p>pthread_sigmask</p>
<p>pthread_setspecific</p>
<p>特定block的执行线程可以在多次调用间会发生变化，因此应用不应该依赖于以下函数返回的信息：</p>
<p>pthread_self</p>
<p>pthread_getschedparam</p>
<p>pthread_get_stacksize_np</p>
<p>pthread_get_stackaddr_np</p>
<p>pthread_mach_thread_np</p>
<p>pthread_from_mach_thread_np</p>
<p>pthread_getspecific</p>
<p>Block必须捕获和禁止任何语言级的异常，Block执行期间的其它错误也应该由block处理，或者通知应用</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>iOS Concurrency Programming Guide</p>
<p>iOS 和 Mac OS 传统的并发编程模型是线程，不过线程模型伸缩性不强，而且编写正确的线程代码也不容易。Mac OS 和 iOS 采取 asynchronous design approa]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
