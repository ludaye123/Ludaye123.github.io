<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[大神的iOS开发博客]]></title>
  <subtitle><![CDATA[知识来源于分解]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://linfeng1009.gitcafe.io/"/>
  <updated>2016-01-27T13:01:31.000Z</updated>
  <id>http://linfeng1009.gitcafe.io/</id>
  
  <author>
    <name><![CDATA[大神]]></name>
    <email><![CDATA[1057105719@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iOS多线程总结之GCD]]></title>
    <link href="http://linfeng1009.gitcafe.io/2016/01/27/thread-summary-gcd/"/>
    <id>http://linfeng1009.gitcafe.io/2016/01/27/thread-summary-gcd/</id>
    <published>2016-01-27T13:01:31.000Z</published>
    <updated>2016-01-27T13:01:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Grand_Central_Dispatch_(GCD)">Grand Central Dispatch (GCD)</h2><h3 id="1-GCD概述">1.GCD概述</h3><p>GCD由语言特征、运行时库和系统提供的增强功能组成，综合提升多核硬件支持代码在iOS和OS X中并发执行。</p>
<h4 id="GCD对象和ARC">GCD对象和ARC</h4><p>当你使用OC语言构建应用编译时，所有的<code>dispatch</code>对象也是OC对象。同样的，在ARC的环境中，<code>dispatch</code>对象和任何其他OC对象一样会自动的<code>retain</code> 和 <code>release</code>。在MRC环境中时，使用<code>dispatch_retain</code>和<code>dispatch_release</code>函数(和OC语义相同)来保留或者释放派发对象，但是你不能使用<code>Core Foundation</code>的保留和释放函数。</p>
<hr>
<h3 id="2-创建和管理队列">2.创建和管理队列</h3><p>在GCD中，有两种队列，串行队列和并发队列，串行队列中根据FIFO的方式执行任务，但同时只能执行一个任务。并发队列也会根据FIFO的方式执行任务，但是同时可以执行多个任务。</p>
<p>1.<code>dispatch_queue_t dispatch_get_main_queue(void);</code><br>返回一个主队列，主队列通过系统自动创建并且和你的应用的主线程关联。</p>
<p>2.<code>dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);</code><br>返回一个全局的并发队列，任务提交到这个队列中会被安排与其他任务并发执行。</p>
<p>3.<code>dispatch_queue_t dispatch_queue_create( const char *label, dispatch_queue_attr_t attr);</code><br>创建一个新的调度队列，label参数为对列贴上一个唯一的标示符，官方推荐名为反向的域名(com.example.myqueue), attr参数指定为<code>DISPATCH_QUEUE_SERIAL</code>或者<code>NULL</code>创建一个串行队列，指定为<code>DISPATCH_QUEUE_CONCURRENT</code>创建一个并发队列。</p>
<p>4.<code>dispatch_queue_t dispatch_get_current_queue(void);</code><br>返回当前的队列，这个函数被定义永远都不会返回为NULL。当在提交的block上下文的外部调用时，这个函数会返回主队列如果是在主线程中调用。如果在其他任意的线程中调用，这个函数会返回默认的并发队列。</p>
<p>5.<code>const char * dispatch_queue_get_label(dispatch_queue_t queue);</code>获取指定代理的唯一标示，返回可能为空</p>
<hr>
<h3 id="3-等候任务调度">3.等候任务调度</h3><p>GCD提供和管理FIFO队列，你的应用可以block对象的形式提交任务。block提交到调度队列在一个系统全面管理的线程池上执行。不能保证线程执行一个任务。GCD提供3种类型的队列:<br>主队列: 在你应用的主线程上顺序执行任务<br>并发队列: 任务按照先入先出的方式移除队列，并发执行并且能够以任意顺序完成<br>串行队列: 按照先入先出的方式同时只能执行一个任务<br>主队列是自动创建的通过系统并且和你应用的主线程关联。你的应用使用下面三个方法的其中一个去调用提交到主队列的block</p>
<p>调用<code>dispatch_main</code><br>调用<code>UIApplicationMain</code>(iOS) 或 <code>NSApplicationMain</code>(OS X)<br>使用<code>CFRunLoopRef</code>在主线程 </p>
<p>使用并发队列同时执行多个任务。GCD自动创建四个并发调度队列，并且在应用中是全局的，它们之间的区别仅在于优先级。你的应用请求这些队列使用<code>dispatch_get_global_queue</code>函数。因为这些并发队列在你用中是全局的，所以一你不需要保留或者释放，保留或者释放方法的调用对于它们是可以忽略的。</p>
<p>使用串行队列可确保那些任务按照预期的方式执行。你的用用必须明确地创建和管理串行队列。如果有必要可以穿件多个串行队列，但是应该避免使用它们代替并发队列只是为了同时执行过个任务。</p>
<p>1.<code>void dispatch_async( dispatch_queue_t queue, dispatch_block_t block);</code><br>提交一个block异步执行在指定调度队列上，并且立刻返回。</p>
<p>2.<code>void dispatch_async_f( dispatch_queue_t queue, void *context, dispatch_function_t work);</code><br>再指定的队列上异步调用在应用中定义的方法，context为应用中自定义函数的参数，work为自定义函数的IMP<br>eg:</p>
<pre><code>dispatch_function_t fuction = (dispatch_function_t)custonFuction;
dispatch_async_f(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), (<span class="keyword">void</span> *)<span class="number">10</span>, fuction);

<span class="keyword">void</span> custonFuction(<span class="keyword">int</span> par)
{
       <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,par);
       <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);
}
</code></pre><p>3.<code>void dispatch_sync( dispatch_queue_t queue, dispatch_block_t block);</code><br>添加block到目标调度队列执行并且等待直到block执行完成，不像<code>dispatch_async</code>,这个函数不会返回直到block已经完成。调用这个函数并且目标队列为当前的队列会造成死锁。</p>
<p>4.<code>void dispatch_after( dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</code><br>指定时间执行block,通常用来延时执行某个操作，而不用NSTimer</p>
<p>5.<code>void dispatch_apply( size_t iterations, dispatch_queue_t queue, void (^block)( size_t));</code><br>多次执行block任务</p>
<p>6.<code>void dispatch_once( dispatch_once_t *predicate, dispatch_block_t block);</code><br>在整个应用生命周期内仅仅执行一次block任务，通常实现单例模式</p>
<p>eg:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">       </span><br><span class="line"><span class="built_in">NSString</span> *url = <span class="string">@"http://tao.goulew.com/users/upfile/201504/201504081150270big.jpg"</span>;</span><br><span class="line">        <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc] initWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:url]];</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(image)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-使用调度组">4.使用调度组</h3><p>调度组: 在应用中向调度队列中添加多个任务block，使用调度组可以追踪当所有的任务完成时，即便它们处于不同的队列中。<br>1.<code>void dispatch_group_async( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</code><br>提交一个block到调度队列并且使这个block与指定的调度组相关联</p>
<p>2.<code>dispatch_group_t dispatch_group_create( void);</code><br>创建一个调度组</p>
<p>3.<code>void dispatch_group_notify( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</code><br>调度一个block对象提交到队列中当之前提交的block对象已经完成时</p>
<p>eg:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">       </span><br><span class="line">    NSLog<span class="list">(@<span class="string">"%@任务1"</span>,[NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">           </span><br><span class="line">    NSLog<span class="list">(@<span class="string">"%@任务2"</span>,[NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">       </span><br><span class="line">    NSLog<span class="list">(@<span class="string">"%@任务3"</span>,[NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog<span class="list">(@<span class="string">"所有的任务完成"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Grand_Central_Dispatch_(GCD)">Grand Central Dispatch (GCD)</h2><h3 id="1-GCD概述">1.GCD概述</h3><p>GCD由语言特征、运行时库和系统提供的增强功能组成，综合提升多核硬件支持代]]>
    </summary>
    
      <category term="iOS多线程" scheme="http://linfeng1009.gitcafe.io/tags/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解析WebKit]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/12/29/WebKit%E8%A7%A3%E6%9E%90/"/>
    <id>http://linfeng1009.gitcafe.io/2015/12/29/WebKit解析/</id>
    <published>2015-12-29T09:14:43.000Z</published>
    <updated>2016-01-02T10:10:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>在iOS8之前，在APP内使用UIWebView内存嵌web应用，会有一些严重的性能效果，尤其是比较复杂的Web应用。对用户体验也产生了一定影响,不管是对开发者还是用户说，都希望能有一个更好的方案来代替UIWebView,在iOS中自带Safari浏览器，打开web应用，表现比UIWebView要优秀很多。很高兴的是，在iOS8的到来，apple发布了webkit，在性能和速度方面接近了原生的Safari。下面介绍下iOS中Webkit的一些新特性:<br>1.平滑滚动: Apple在这方面做了很大的努力，之前，滚动的性能表现极差。现在，Webkit利用CoreAnimation和硬件加速提供了非常好的性能优化，尤其是当你滚动页面的时候。<br>2.手势: WebKit可以支持触摸板的手势，例如可以滑动返回，挤压缩放等(在iOS上好像没有多大意义哈)。<br>3.KVO: 可以监听网页加载的进度，进度，标题和URL可以通过WKWebView的属性观察。所以，你可以在任意假定的时刻确定WebView的状态，来更新UI。<br>4.原生交互:这是一个最显著的特征。当初iOS7发布的时候，JavascriptCore可以使JS与OC之间交流，但是它主要是集中在桥接这两种语言的缺口。在iOS8中，提供了两个新的API:用户脚本和脚本消息，用户脚本可以是你注入JS代码到Web页面中，然后在页面指定地方运行。脚本消息能够是原生的代码去接收从用户脚本注入Web页面的回调—有点NSNotifications通知的思想，只是它来自于web页面。</p>
<h1 id="介绍WKWebView">介绍WKWebView</h1><p>实现一个简单的网页展示Demo来介绍WKWebView的使用。包括如何实例化配置，怎样加载URL和监听加载进度。<br>具体你要实现以下功能：</p>
<p>1.通过URL加载网页<br>2.显示网页加载进度<br>3.根据访问的历史状态，可以向前或向后操作更新页面<br>4.取消加载网页<br>5.重新加载网页<br>6.自适应布局(运行不同设备上要适配 如:iPhone和iPad)</p>
<p>新建一个工程WebKitDemo,布局界面如下:<br><img src="http://7xkpsz.com1.z0.glb.clouddn.com/layout.png" alt=""></p>
<h2 id="基本显示">基本显示</h2><p>在ViewController.m中添加一个WKWebView的webView属性, 然后初始化webView添加到当前的view上并设置自动布局约束。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (WKWebView *)webViewBaiscUse</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.inputURLField</span><span class="variable">.text</span> = <span class="string">@"https://www.baidu.com"</span>;</span><br><span class="line">    <span class="keyword">return</span> [[WKWebView alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (WKWebView *)webView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_webView)</span><br><span class="line">    &#123;</span><br><span class="line">        _webView = [<span class="keyword">self</span> webViewBaiscUse];</span><br><span class="line"><span class="comment">//        _webView = [self webViewWithUserScript];</span></span><br><span class="line"><span class="comment">//        _webView = [self webViewWithScriptMessage];</span></span><br><span class="line">        _webView<span class="variable">.translatesAutoresizingMaskIntoConstraints</span> = <span class="literal">NO</span>;</span><br><span class="line">        _webView<span class="variable">.navigationDelegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _webView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.forwardButton</span><span class="variable">.enabled</span> = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.backwardButton</span><span class="variable">.enabled</span> = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    self.inputURLField.text = @"http://www.raywenderlich.com/u/funkyboy";  // default page</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.inputURLField</span><span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.barBackGroundView</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span>), <span class="number">30.0</span>);</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:<span class="keyword">self</span><span class="variable">.webView</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> insertSubview:<span class="keyword">self</span><span class="variable">.webView</span> belowSubview:<span class="keyword">self</span><span class="variable">.progressView</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:<span class="keyword">self</span><span class="variable">.webView</span> attribute:<span class="built_in">NSLayoutAttributeWidth</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span><span class="variable">.view</span> attribute:<span class="built_in">NSLayoutAttributeWidth</span> multiplier:<span class="number">1.0</span> constant:<span class="number">0.0</span>]];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:<span class="keyword">self</span><span class="variable">.webView</span> attribute:<span class="built_in">NSLayoutAttributeHeight</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span><span class="variable">.view</span> attribute:<span class="built_in">NSLayoutAttributeHeight</span> multiplier:<span class="number">1.0</span> constant:-<span class="number">44.0</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// load the default page</span></span><br><span class="line">    [<span class="keyword">self</span> loadReuqest];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)loadReuqest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span><span class="variable">.inputURLField</span><span class="variable">.text</span>];</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.webView</span> loadRequest:request];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，效果如下:</p>
<p><img src="http://7xkpsz.com1.z0.glb.clouddn.com/Simulator%20Screen%20Shot%20Jan%202%2C%202016%2C%2017.34.24.png" alt=""></p>
<h2 id="页面加载进度">页面加载进度</h2><p>WkWebView支持KVO，你可以监听loading和estimatedProgress属性来实现页面的加载进度，这里我们用一个进度条控件来显示当前的进度。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// observer the webview loading and estimatedprogress property</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.webView</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"loading"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.webView</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"estimatedProgress"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>([keyPath isEqualToString:<span class="string">@"loading"</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.networkActivityIndicatorVisible</span> = <span class="keyword">self</span><span class="variable">.webView</span><span class="variable">.loading</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">self</span><span class="variable">.webView</span><span class="variable">.loading</span> == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.inputURLField</span><span class="variable">.text</span> = [<span class="keyword">self</span><span class="variable">.webView</span><span class="variable">.URL</span> absoluteString];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>([keyPath isEqualToString:<span class="string">@"estimatedProgress"</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.progressView</span><span class="variable">.hidden</span> = <span class="keyword">self</span><span class="variable">.webView</span><span class="variable">.estimatedProgress</span> == <span class="number">1</span>;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.progressView</span> setProgress:<span class="keyword">self</span><span class="variable">.webView</span><span class="variable">.estimatedProgress</span> animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，效果如下:</p>
<p><img src="http://7xkpsz.com1.z0.glb.clouddn.com/Simulator%20Screen%20Shot%20Jan%202%2C%202016%2C%2017.45.04.png" alt=""></p>
<h2 id="前进后退操作">前进后退操作</h2><p>WKWebView提供goForward和goBack实例方法来实现前进和后退操作。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (IBAction)<span class="tag">handleForward</span>:(id)<span class="tag">sender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[self.webView goForward]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (IBAction)<span class="tag">handleBack</span>:(id)<span class="tag">sender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[self.webView goBack]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取消和重新加载">取消和重新加载</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)handleRefresh:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span><span class="variable">.webView</span><span class="variable">.loading</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.webView</span> stopLoading];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:<span class="keyword">self</span><span class="variable">.webView</span><span class="variable">.URL</span>];</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.webView</span> loadRequest:request];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="协议方法">协议方法</h1><p>可以通过navigationDelegate属性设置WKWebView的代理对象。协议方法会在不同情况下调用对应的方法来处理相关的事物。</p>
<ul>
<li>-(void)webView:(WKWebView <em>)webView didCommitNavigation:(null_unspecified WKNavigation </em>)navigation; // 开始加载时调用</li>
<li>-(void)webView:(WKWebView <em>)webView didFailProvisionalNavigation:(null_unspecified WKNavigation </em>)navigation withError:(NSError *)error; // 加载URL出错的时调用</li>
<li>-(void)webView:(WKWebView <em>)webView didFinishNavigation:(null_unspecified WKNavigation </em>)navigation; // 加载完成时调用</li>
<li>-(void)webView:(WKWebView <em>)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation </em>)navigation; // 服务器重定向时调用</li>
<li>-(void)webView:(WKWebView <em>)webView didFailNavigation:(null_unspecified WKNavigation </em>)navigation withError:(NSError *)error; // 加载网页出错时调用</li>
</ul>
<h1 id="用户脚本">用户脚本</h1><p>可以通过自定义的js脚本来注入当前加载的页面中，Demo中是将网页上的作者个人信息屏蔽处。注入js脚本可以通过WKUserScript的实例来加载js文件,然后WKWebView的addUserScript来添加。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (WKWebView *)webViewWithUserScript</span><br><span class="line">&#123;</span><br><span class="line">    self.inputURLField.text = @<span class="string">"http://www.raywenderlich.com/u/funkyboy"</span>;</span><br><span class="line">    </span><br><span class="line">    WKWebViewConfiguration *conf = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">    NSString *jsPath = [[NSBundle mainBundle] <span class="string">pathForResource:</span>@<span class="string">"hideBio"</span> <span class="string">ofType:</span>@<span class="string">"js"</span>];</span><br><span class="line">    NSString *hideBioJS = [NSString <span class="string">stringWithContentsOfFile:</span>jsPath <span class="string">encoding:</span>NSUTF8StringEncoding <span class="string">error:</span>nil];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// inject user script</span></span><br><span class="line">    WKUserScript *hideBioUserScript = [[WKUserScript alloc] <span class="string">initWithSource:</span>hideBioJS <span class="string">injectionTime:</span>WKUserScriptInjectionTimeAtDocumentStart <span class="string">forMainFrameOnly:</span>NO];</span><br><span class="line">    [conf.userContentController <span class="string">addUserScript:</span>hideBioUserScript];</span><br><span class="line">    </span><br><span class="line">    WKWebView *webView = [[WKWebView alloc] <span class="string">initWithFrame:</span>CGRectZero <span class="string">configuration:</span>conf];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> webView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="脚本方法">脚本方法</h1><p>接收当前js的回调方法，由WKScriptMessageHandler协议中的userContentController:(WKUserContentController <em>)userContentController didReceiveScriptMessage:(WKScriptMessage </em>)message方法来接收js的回调处理。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (WKWebView *)webViewWithScriptMessage</span><br><span class="line">&#123;</span><br><span class="line">    self.inputURLField.text = @<span class="string">"http://www.raywenderlich.com/about"</span>;</span><br><span class="line">    </span><br><span class="line">    WKWebViewConfiguration *conf = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">    NSString *scriptURL = [[NSBundle mainBundle] <span class="string">pathForResource:</span>@<span class="string">"fetchAuthors"</span> <span class="string">ofType:</span>@<span class="string">"js"</span>];</span><br><span class="line">    NSString *jsScript = [NSString <span class="string">stringWithContentsOfFile:</span>scriptURL <span class="string">encoding:</span>NSUTF8StringEncoding <span class="string">error:</span>nil];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// inject user script</span></span><br><span class="line">    WKUserScript *fetchAuthorsScript = [[WKUserScript alloc] <span class="string">initWithSource:</span>jsScript <span class="string">injectionTime:</span>WKUserScriptInjectionTimeAtDocumentStart <span class="string">forMainFrameOnly:</span>NO];</span><br><span class="line">    [conf.userContentController <span class="string">addUserScript:</span>fetchAuthorsScript];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// inject script message</span></span><br><span class="line">    [conf.userContentController <span class="string">addScriptMessageHandler:</span>self <span class="string">name:</span>kMessageHandler];</span><br><span class="line">    </span><br><span class="line">    WKWebView *webView = [[WKWebView alloc] <span class="string">initWithFrame:</span>CGRectZero <span class="string">configuration:</span>conf];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> webView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1><p>详细的内容可以去Demo中查看,在<a href="https://github.com/ludaye123/WKWebViewDemo" target="_blank" rel="external">这里下载</a>。如果什么问题，你可以在下方留下你的疑问，我会尽快回复你。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>在iOS8之前，在APP内使用UIWebView内存嵌web应用，会有一些严重的性能效果，尤其是比较复杂的Web应用。对用户体验也产生了一定影响,不管是对开发者还是用户说，都希望能有一个更好的方案来代替UIWebView,在iOS中自带]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[生产者与消费模式]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/12/22/ProducterAndCustomerMode/"/>
    <id>http://linfeng1009.gitcafe.io/2015/12/22/ProducterAndCustomerMode/</id>
    <published>2015-12-22T05:18:20.000Z</published>
    <updated>2015-12-22T05:32:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="生产者与消费者问题">生产者与消费者问题</h1><p>前段时间一个朋友问到这个问题，这是一个典型的多线程例子,记得以前在大学上操作系统这门课程有学习过,在此记录下我的实现方式。</p>
<p>这个问题有两个要求：<br>1.生产者在仓库未满的情况下生产，否则停止生产<br>2.消费者仅在仓库有产品时才能消费，否则等待生产</p>
<p>实现方式1: 利用iOS GCD中dispatch_semaphore_t信号转化实现</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *buffer = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">   <span class="built_in">NSArray</span> *nums = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>,@<span class="number">5</span>];</span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">   dispatch_semaphore_t semaphoere = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 生产者线程</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">           <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span>(buffer<span class="variable">.count</span> == MAX_SIZE)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">NSLog</span>(<span class="string">@"缓存已满,等待消耗"</span>);</span><br><span class="line">                   <span class="keyword">if</span>(dispatch_semaphore_wait(semaphoere, DISPATCH_TIME_FOREVER))</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">id</span> num = nums[arc4random_uniform((u_int32_t)nums<span class="variable">.count</span>)];</span><br><span class="line">               [buffer addObject:num];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@"Producter: %@"</span>,num);</span><br><span class="line"></span><br><span class="line">               dispatch_semaphore_signal(semaphoere)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 消费者线程</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">           <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span>(buffer<span class="variable">.count</span> == <span class="number">0</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">NSLog</span>(<span class="string">@"缓存为空,等待生产"</span>);</span><br><span class="line">                  <span class="keyword">if</span>(dispatch_semaphore_wait(semaphoere, DISPATCH_TIME_FOREVER))</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">id</span> num = [buffer firstObject];</span><br><span class="line">               [buffer removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@"Customer: %@"</span>,num);</span><br><span class="line">               dispatch_semaphore_signal(semaphoere)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>实现方式2: 利用pthread中的mutex和cond实现</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *buffer = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    pthread_mutex_t *mutex = (pthread_mutex_t *)malloc(<span class="keyword">sizeof</span>(pthread_mutex_t));</span><br><span class="line">    pthread_mutex_init(mutex, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_cond_t *cond = (pthread_cond_t *)malloc(<span class="keyword">sizeof</span>(pthread_cond_t));</span><br><span class="line">    pthread_cond_init(cond, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *nums = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>,@<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生产者线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            pthread_mutex_lock(mutex);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(buffer<span class="variable">.count</span> == MAX_SIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"缓存已满,等待消耗"</span>);</span><br><span class="line">                pthread_cond_wait(cond, mutex);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">id</span> num = nums[arc4random_uniform((u_int32_t)nums<span class="variable">.count</span>)];</span><br><span class="line">            [buffer addObject:num];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Producter: %@"</span>,num);</span><br><span class="line">            pthread_cond_signal(cond);</span><br><span class="line">            pthread_mutex_unlock(mutex);</span><br><span class="line">            </span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:arc4random_uniform(<span class="number">2</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消费者线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_lock(mutex);</span><br><span class="line">            <span class="keyword">if</span>(buffer<span class="variable">.count</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"缓存为空,等待生产"</span>);</span><br><span class="line">                pthread_cond_wait(cond, mutex);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">id</span> num = [buffer firstObject];</span><br><span class="line">            [buffer removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Customer: %@"</span>,num);</span><br><span class="line">            pthread_cond_signal(cond);</span><br><span class="line">            pthread_mutex_unlock(mutex);</span><br><span class="line">            </span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:arc4random_uniform(<span class="number">3</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>最开始我是Pythond实现的，也记录下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread,Condition</span><br><span class="line">import <span class="tag">time</span></span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">buffer = []</span><br><span class="line">condition = <span class="function"><span class="title">Condition</span><span class="params">()</span></span></span><br><span class="line">MAX_NUM = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">class <span class="function"><span class="title">ProducerThread</span><span class="params">(Thread)</span></span>:</span><br><span class="line">    def <span class="function"><span class="title">run</span><span class="params">(self)</span></span>:</span><br><span class="line">        nums = <span class="function"><span class="title">range</span><span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line">        global buffer</span><br><span class="line">        while True:</span><br><span class="line">            num = random.<span class="function"><span class="title">choice</span><span class="params">(nums)</span></span></span><br><span class="line">            condition.<span class="function"><span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line">            <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(buffer)</span></span> == MAX_NUM:</span><br><span class="line">                <span class="function"><span class="title">print</span><span class="params">(<span class="string">"缓存已满,等待消耗"</span>)</span></span></span><br><span class="line">                condition.<span class="function"><span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">            buffer.<span class="function"><span class="title">append</span><span class="params">(num)</span></span></span><br><span class="line">            <span class="function"><span class="title">print</span><span class="params">(<span class="string">"Procuder %d"</span>%num)</span></span></span><br><span class="line">            condition.<span class="function"><span class="title">notify</span><span class="params">()</span></span></span><br><span class="line">            condition.<span class="function"><span class="title">release</span><span class="params">()</span></span></span><br><span class="line">            <span class="tag">time</span>.<span class="function"><span class="title">sleep</span><span class="params">(random.random()</span></span>)</span><br><span class="line"></span><br><span class="line">class <span class="function"><span class="title">CustomerThread</span><span class="params">(Thread)</span></span>:</span><br><span class="line">    def <span class="function"><span class="title">run</span><span class="params">(self)</span></span>:</span><br><span class="line">        global buffer</span><br><span class="line">        while True:</span><br><span class="line">            condition.<span class="function"><span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line">            <span class="keyword">if</span> not buffer:</span><br><span class="line">                <span class="function"><span class="title">print</span><span class="params">(<span class="string">"缓存为空,等待生产"</span>)</span></span></span><br><span class="line">                condition.<span class="function"><span class="title">wait</span><span class="params">()</span></span></span><br><span class="line">            num = buffer.<span class="function"><span class="title">pop</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line">            <span class="function"><span class="title">print</span><span class="params">(<span class="string">"Customer %d"</span>%num)</span></span></span><br><span class="line">            condition.<span class="function"><span class="title">notify</span><span class="params">()</span></span></span><br><span class="line">            condition.<span class="function"><span class="title">release</span><span class="params">()</span></span></span><br><span class="line">            <span class="tag">time</span>.<span class="function"><span class="title">sleep</span><span class="params">(random.random()</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="function"><span class="title">ProducerThread</span><span class="params">()</span></span>.<span class="function"><span class="title">start</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="title">CustomerThread</span><span class="params">()</span></span>.<span class="function"><span class="title">start</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="生产者与消费者问题">生产者与消费者问题</h1><p>前段时间一个朋友问到这个问题，这是一个典型的多线程例子,记得以前在大学上操作系统这门课程有学习过,在此记录下我的实现方式。</p>
<p>这个问题有两个要求：<br>1.生产者在仓库未满的情况下生产，否则停止]]>
    </summary>
    
      <category term="多线程" scheme="http://linfeng1009.gitcafe.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[默认实现Swift协议方法]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/12/09/protocol-default-imp/"/>
    <id>http://linfeng1009.gitcafe.io/2015/12/09/protocol-default-imp/</id>
    <published>2015-12-09T08:33:53.000Z</published>
    <updated>2015-12-10T02:24:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="协议方法默认实现">协议方法默认实现</h2><p>用OC定义的协议方法无法默认实现，这样造成的影响就会出现许多冗余的代码。如下情况(本例用Swift代替)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protocol TeamRecord &#123;  <span class="variable"><span class="keyword">var</span> wins</span>: <span class="typename">Int</span> &#123; <span class="keyword">get</span> &#125;  <span class="variable"><span class="keyword">var</span> losses</span>: <span class="typename">Int</span> &#123; <span class="keyword">get</span> &#125;  func winningPercentage() -&gt; <span class="typename">Double</span>&#125;struct BaseballRecord: TeamRecord &#123;  <span class="variable"><span class="keyword">var</span> wins</span>: <span class="typename">Int</span>  <span class="variable"><span class="keyword">var</span> losses</span>: <span class="typename">Int</span>  let seasonLength = <span class="number">162</span>  func winningPercentage() -&gt; <span class="typename">Double</span> &#123;    <span class="keyword">return</span> <span class="typename">Double</span>(wins) / (<span class="typename">Double</span>(wins) + <span class="typename">Double</span>(losses))  &#125;&#125;struct BasketballRecord: TeamRecord &#123;  <span class="variable"><span class="keyword">var</span> wins</span>: <span class="typename">Int</span>  <span class="variable"><span class="keyword">var</span> losses</span>: <span class="typename">Int</span>  let seasonLength = <span class="number">82</span>  func winningPercentage() -&gt; <span class="typename">Double</span> &#123;    <span class="keyword">return</span> <span class="typename">Double</span>(wins) / (<span class="typename">Double</span>(wins) + <span class="typename">Double</span>(losses))  &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>其中BaseballRecord类和BasketballRecord类都遵循了TeamRecord协议，但是实现winningPercentage的方法，其实现的内容是一致的，出现过多冗余的代码会给后期的维护增加难度，但好在是在Swift中提供了一中可以默认实现协议方法,扩展当前的协议，然后实现想要默认实现的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TeamRecord</span> </span>&#123;  <span class="keyword">var</span> wins: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;  <span class="keyword">var</span> losses: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;  <span class="func"><span class="keyword">func</span> <span class="title">winningPercentage</span><span class="params">()</span></span> -&gt; <span class="type">Double</span>&#125;<span class="class"><span class="keyword">extension</span> <span class="title">TeamRecord</span> </span>&#123;  <span class="func"><span class="keyword">func</span> <span class="title">winningPercentage</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;    <span class="keyword">return</span> <span class="type">Double</span>(wins) / (<span class="type">Double</span>(wins) + <span class="type">Double</span>(losses))  &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>经过上述修改后，代码如下,在遵循协议的类中，省去了冗余协议方法的实现，代码简洁了不少，有木有！！哈哈！！！</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct BaseballRecord: TeamRecord &#123;  <span class="variable"><span class="keyword">var</span> wins</span>: <span class="typename">Int</span>  <span class="variable"><span class="keyword">var</span> losses</span>: <span class="typename">Int</span>  let seasonLength = <span class="number">162</span>&#125;struct BasketballRecord: TeamRecord &#123;  <span class="variable"><span class="keyword">var</span> wins</span>: <span class="typename">Int</span>  <span class="variable"><span class="keyword">var</span> losses</span>: <span class="typename">Int</span>  let seasonLength = <span class="number">82</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协议扩展方法调">协议扩展方法调</h2><p>默认实现协议的方法有一定的好处，但是在开发项目中，默认实现的方法并不能满足所有的情况，有时必须要实现协议的方法，如果一个在遵循某个协议的类中，实现了该协议的方法，但是该协议又扩展实现了方法的默认实现，在这种情况下，该调用哪个方法呢？ </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyProtocol</span></span>&#123;   </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span>: <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello Sunday"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化MyType，然后调用test方法</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> type: MyType = <span class="function"><span class="title">MyType</span><span class="params">()</span></span></span><br><span class="line">type.<span class="function"><span class="title">test</span><span class="params">()</span></span>   <span class="comment">// 打印的结果是 Hello Sunday</span></span><br></pre></td></tr></table></figure>
<p>当然我们也可以实例化MyType给MyProtocol类型变量</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> type1: MyProtocol = <span class="function"><span class="title">MyType</span><span class="params">()</span></span></span><br><span class="line">type1.<span class="function"><span class="title">test</span><span class="params">()</span></span> <span class="comment">// 打印的结果是 Hello Sunday</span></span><br></pre></td></tr></table></figure>
<p>这两种情况的结果是一样的，没什么区别，但是如果修改一下Myprotocol方法的定义，让其方法在扩展中实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span></span>&#123;</span><br><span class="line">  <span class="comment">//  func test()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyProtocol</span></span>&#123;   </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span>: <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello Sunday"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再打印结果</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> type: MyType = <span class="function"><span class="title">MyType</span><span class="params">()</span></span></span><br><span class="line">type.<span class="function"><span class="title">test</span><span class="params">()</span></span>   <span class="comment">// 打印的结果是 Hello Sunday</span></span><br><span class="line"><span class="tag">var</span> type1: MyProtocol = <span class="function"><span class="title">MyType</span><span class="params">()</span></span></span><br><span class="line">type1.<span class="function"><span class="title">test</span><span class="params">()</span></span> <span class="comment">// 打印的结果是 Hello World</span></span><br></pre></td></tr></table></figure>
<p>从其结果可以知道，如果协议中的方法未在该协议中定义，而是在其扩展中定义实现，当实例化遵循改协议的类给该协议变量时，调用协议的方法不是在该类中实现的，而是实现默认的方法.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="协议方法默认实现">协议方法默认实现</h2><p>用OC定义的协议方法无法默认实现，这样造成的影响就会出现许多冗余的代码。如下情况(本例用Swift代替)</p>
<figure class="highlight kotlin"><table><tr><td c]]>
    </summary>
    
      <category term="iOS,Swift" scheme="http://linfeng1009.gitcafe.io/tags/iOS-Swift/"/>
    
      <category term="Swift" scheme="http://linfeng1009.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发-ARC理解]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/11/10/memory-arc/"/>
    <id>http://linfeng1009.gitcafe.io/2015/11/10/memory-arc/</id>
    <published>2015-11-10T08:32:36.000Z</published>
    <updated>2015-12-20T05:13:39.000Z</updated>
    <content type="html"><![CDATA[<p>ARC是一个编译器的特征,提供自动管理对Objective-C对象的分配内存,而不是总是思索什么时候<code>retain</code>和什么时候<code>release</code>操作，ARC会让你把更多地精力集中在编码上。<br><img src="https://developer.apple.com/library/prerelease/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Art/ARC_Illustration.jpg" alt=""></p>
<h2 id="ARC概述">ARC概述</h2><hr>
<p>ARC可以让你没必要记住什么时候使用<code>retain</code>,<code>release</code>和<code>autorelease</code>方法,ARC会预估对象的生命周期并且在编译时自动插入合适的内存管理方法，也会生成合适的dealloc方法。<br>一个完整正确实现的Person类可能是这样的：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Person </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> NSString *firstName;</span><br><span class="line"><span class="variable">@property</span> NSString *lastName;</span><br><span class="line"><span class="variable">@property</span> NSNumber *yearOfBirth;</span><br><span class="line"><span class="variable">@property</span> Person *spouse;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">@implementation</span> Person</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="attribute">TODO</span>: 属性默认是Strong引用</span><br></pre></td></tr></table></figure>
<p>使用ARC，实现contrived方法</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="atom">void</span>)<span class="atom">contrived</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="name">Person</span> *<span class="atom">aPerson</span> = [[<span class="name">Person</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">    [<span class="atom">aPerson</span> <span class="atom">setFirstName</span>:@<span class="string">"William"</span>];</span><br><span class="line">    [<span class="atom">aPerson</span> <span class="atom">setLastName</span>:@<span class="string">"Dudney"</span>];</span><br><span class="line">    [<span class="atom">aPerson</span> <span class="atom">setYearOfBirth</span>:[[<span class="name">NSNumber</span> <span class="atom">alloc</span>] <span class="atom">initWithInteger</span>:<span class="number">2011</span>]];</span><br><span class="line">    <span class="name">NSLog</span>(@<span class="string">"aPerson: %@"</span>, <span class="atom">aPerson</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARC会负责内存管理，所以Person和NSNumber对象都不会有内存泄露。<br>你也可以安全的实现Person类的takeLastNameFrom:方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)takeLastNameFrom:(Person *)person </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *oldLastname = [<span class="keyword">self</span> lastName];</span><br><span class="line">    [<span class="keyword">self</span> setLastName:[person lastName]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Lastname changed from %@ to %@"</span>, oldLastname, [<span class="keyword">self</span> lastName]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARC确保oldLastname在NSLog语句前不会释放。</p>
<h2 id="ARC规则">ARC规则</h2><hr>
<p>1.不能明确地调用<code>dealloc</code>,实现或调用<code>retain</code>,<code>release</code>,<code>retainCount</code>或<code>autorelease</code>方法，禁止扩充使用<code>@selector(retain), @selector(release)</code>等等。内存管理是编译器的工作，因此没有必要再使用内存管理的方法。如果你非得在ARC环境下使用内存管理的方法,那你会得到这样一个错误。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">error</span>:<span class="value"> ARC forbids explicit message send of <span class="string">'release'</span></span><br><span class="line">	[obj release]</span></span>;</span><br></pre></td></tr></table></figure>
<p>2.不要显示调用<code>dealloc</code>方法，不管是在ARC或者是MRC环境下，只要对象的所有者不持有该对象，该对象就会被废弃，并且都会调用对象的<code>dealloc</code>方法。<br>3.自定义<code>dealloc</code>方法在ARC中是没有必要调用<code>[super dealloc]</code>(其实会编译错误)。在自定义<code>dealloc</code>方法内有使用到C语言库，在该库内分配缓存时，需要通过<code>free</code>来释放内存。还有适用于移除已注册的代理或观察者对象。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">dealloc</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr_selector">[[NSNotificationCenter defaultCenter]</span> <span class="tag">removeObserver</span><span class="pseudo">:self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.可以直接使用<code>CFRetain</code>,<code>CFRelease</code>，以及其他与CoreFoundation风格类似对象关联的方法。(CF对象需要手动管理内存)<br>5.你不能使用<code>NSAllocateObject</code>或<code>NSDeallocateObject</code>,创建对象使用<code>alloc</code>运行时会负责释放对象。<br>6.你不能结构体中使用对象指针，你可以创建一个Objective-C类来替代管理数据。<br>7.<code>id</code>和<code>void *</code>显示转化需告诉编译器关于对象的生命周期。在MRC中，id变量强制转换void*变量并不会出现问题。如下示例:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [][<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = obj;</span><br><span class="line"><span class="keyword">id</span> obj1 = p;</span><br><span class="line">[ojb1 relase];</span><br></pre></td></tr></table></figure>
<p>但是在ARC环境下就会引起编译错误。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error</span>: implict conversion <span class="keyword">of</span> an Objective-C pointer <span class="keyword">to</span> 'void *' <span class="keyword">is</span> disallowed <span class="keyword">with</span> ARC</span><br><span class="line">void *p = obj;</span><br><span class="line"><span class="keyword">error</span>: implicit conversion <span class="keyword">of</span> an Objective-C piinter <span class="keyword">to</span> 'void *' <span class="keyword">is</span> disallowed <span class="keyword">with</span> ARC </span><br><span class="line"><span class="property">id</span> obj1 = p;</span><br></pre></td></tr></table></figure></p>
<p>id型或者对象型变量赋值给void*或者逆向赋值时都需要进行特定的转换。如果只想单纯地赋值操作，可以使用<code>__bridge</code>转化。ARC环境下会有提示。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p= (__bridge <span class="keyword">void</span> *)obj;</span><br><span class="line"><span class="keyword">id</span> obj1 = (__bridge <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure>
<p>虽然<code>id</code>和<code>void*</code>通过<code>__bridge</code>相互转化，但是转换为<code>void*</code>的<code>__bridge</code>转换，其安全性与赋值给<code>__unsafe_unretained</code>修饰的变量类似，甚至会更低。如果管理时没有注意到赋值对象的所有者,就会因悬挂指针导致程序Crash。说到<strong>bridge转化，还有其他两种转换方式，`</strong>bridge_retained<code>和</code>__bridge_transfer`转化。如下示例分别说明:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = (__bridge_retained)obj;</span><br></pre></td></tr></table></figure>
<p><code>__bridge_retained</code>转换可以使要转换赋值的变量也持有所赋值的对象。在MRC环境下源代码实现如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = obj;</span><br><span class="line">[(<span class="keyword">id</span>)p retain];</span><br></pre></td></tr></table></figure>
<p>__bridge_retained转换变为了retain,也就是说obj和变量p同时持有对象。再看下面的示例:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">	p = (__bridge_retained <span class="keyword">void</span> *)obj; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[(__bridge <span class="keyword">id</span>)p class]);</span><br><span class="line"><span class="comment">// 打印结果为：NSObject</span></span><br></pre></td></tr></table></figure>
<p>变量作用域结束的时，虽然随着持有强引用的变量obj失效，对象也会随之释放，但由于<code>__bridge_retained</code>转换使得变量p持有该对象，因此该对象并不会被废弃。下面比较一下MRC代码:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init]; <span class="comment">// retainCount -&gt; 1</span></span><br><span class="line">	p = [obj retain];  <span class="comment">// retainCount -&gt; 2</span></span><br><span class="line">	[obj release];  <span class="comment">// retainCount -&gt; 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时retainCount为1，对象仍然存在</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[(__bridge <span class="keyword">id</span>)p class]);</span><br></pre></td></tr></table></figure></p>
<p><code>__bridge_transfer</code>转换提供与此相反的操作,被转换得变量所持有的对象在该变量被赋值给转换目标变量之后会被释放。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">id</span> obj = (__bridge_transfer <span class="property">id</span>)p;</span><br></pre></td></tr></table></figure>
<p>在MRC的表述如下:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">id</span> obj = (<span class="property">id</span>)p;</span><br><span class="line">p retain];</span><br><span class="line">[(<span class="property">id</span>)p release];</span><br></pre></td></tr></table></figure>
<p>同<code>__bridge_retained</code>转换与<code>retain</code>类似,<code>__bridge_transfer</code>转换与release相似。在给id obj赋值时retain即相当于__strong修饰符的变量。通过上面的两种转换，那么不使用id型或对象型变量也可以生成、持有以及释放对象。虽然可以这么做，但在ARC并不推荐。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)[[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[(__bridge <span class="keyword">id</span>) class]);</span><br><span class="line">(<span class="keyword">void</span>)(__bridge_transfer <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure>
<p>上面代码等同于在MRC的如下代码:</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">id</span> <span class="atom">p</span> = [[<span class="name">NSObject</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line"><span class="name">NSLog</span>(@<span class="string">"%@"</span>,[<span class="atom">p</span> <span class="atom">class</span>]);</span><br><span class="line">[<span class="atom">p</span> <span class="atom">release</span>];</span><br></pre></td></tr></table></figure>
<p>这些转换大多使用在Objective-C对象与Core Foundation对象之间的转换。</p>
<p>8.不能使用<code>NSAutoreleasePool</code>对象，ARC提供<code>@autoreleasepool</code>block来代替。这种方式比<code>NSAutoreleasePool</code>效率更高。<br>9.你不能使用区域，再也没有必要使用<code>NSZone</code>，它们被现在的Objective-C运行时忽略。<br>10.为了兼容手动<code>retain-release</code>代码，ARC强加了约束对于方法命名,在MRC中，用于对象生成/持有的方法必须遵守以下的命名规则。</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>以上述名称开头的方法在返回对象时,必须返回给调用方所应当持有的对象。在ARC中也是如此，返回的对象完全没有改变，只是在ARC有效时要追加一条命名规则。</p>
<ul>
<li>init</li>
</ul>
<p>以<code>init</code>开头的方法的规则比alloc/new/copy/mutableCopy更严格。该方法必须是实例方法，并且必须要返回对象，返回的对象应为id型/instancetype型/方法生命类的对象类型,还有就是该类的基类或子类型。该返回对象并不注册到autoreleasepool上，基本上只是对<code>alloc</code>方法返回值得对象进行初始化处理并返回该对象。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure></p>
<p>如此代码所示,init方法会初始化alloc方法返回的对象，然后再返回给调用方。<br>下面我们来看看以init开头的方法的命名规则。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">id</span>)<span class="rule"><span class="attribute">initWithDictionary</span>:<span class="value">(NSDictionary *)dict</span></span>;</span><br></pre></td></tr></table></figure>
<p>该方法遵守了命名规则，但想下面的两个方法虽然也以init开头，但是没有返回对象，因此不能使用。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="list">(<span class="keyword">void</span>)</span>initWithObject<span class="comment">;</span></span><br><span class="line">- <span class="list">(<span class="keyword">void</span>)</span>initialize<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>还有不能给一个访问器的命名以<code>new</code>开头。如果声明一个属性它的命名以<code>new</code>开头，除非你指定一个不同的getter方法，否则不能正常运行。</p>
<pre><code><span class="comment">// Won't work:</span>
<span class="variable">@property</span> NSString *newTitle;

<span class="comment">// Works:</span>
<span class="variable">@property</span> (getter=theNewTitle) NSString *newTitle;
</code></pre><h2 id="ARC生命周期修饰符">ARC生命周期修饰符</h2><hr>
<p>ARC给对象提供几个生命周期修饰符，一个弱引用(weak)不会延伸它所指向对象的生命周期，当没有强引用这个对象时，它会自动变为nil,合理的使用weak将帮助你确保不会创建循环引用。</p>
<h3 id="Property修饰">Property修饰</h3><p><code>weak</code>和<code>strong</code>关键字被引用修饰新声明的属性,如下所示:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的声明与 @property(retain) MyClass *myObject;同义</span></span><br><span class="line"><span class="comment">// ARC环境下，对象默认的修饰是strong</span></span><br><span class="line"><span class="variable">@property</span>(strong) MyClass *myObject;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下面的声明与 "@property(assign) MyClass *myObject;"类似</span></span><br><span class="line"><span class="comment">// 除了MyClass 实例被释放，这个属性的值被设置为nil代替保留一个悬挂指针</span></span><br><span class="line"><span class="variable">@property</span>(weak) MyClass *myObject;</span><br></pre></td></tr></table></figure>
<h3 id="变量修饰符">变量修饰符</h3><p>你可以用下面几个生命周期修饰符修饰变量:</p>
<pre><code>__<span class="keyword">strong</span>
__<span class="keyword">weak</span>
__unsafe_unretained
__autoreleasing
</code></pre><p><strong>strong是默认的，对象的一直存在，直到没有其他的strong对象引用。
</strong>weak不会保持引用对象的生命，当指向的变量没有被其他strong对象引用，所指向的队形被设置为nil。<br><strong>unsafe_unretained 指定一个引用，不会保持引用对象的生命，当没有其他strong变量引用所指的对象，它所引用不会设置为nil。如果它所引用的对象被释放了，会指向一个悬挂指针(野指针)。
</strong>autoreleasing 通常用来暗示参数，传递引用在返回时自动释放。</p>
<p>你应该正确修饰变量，格式如下:<br><code>ClassName * qualifier variableName;</code></p>
<p>eg:</p>
<pre><code>MyClass <span class="keyword">*</span> __weak myWeakReference;    
MyClass <span class="keyword">*</span> __unsafe_unretained myUnsafeReference;
</code></pre><p>注意当使用__weak变量在栈上时，思考下面的示例:</p>
<pre><code>NSString * __weak <span class="built_in">string</span> = <span class="string">[[NSString alloc] initWithFormat:@"First Name: %@", [self firstName]]</span>;
NSLog(@<span class="string">"string: %@"</span>, <span class="built_in">string</span>);
</code></pre><p>虽然string被赋值了一个字符串对象，但是由于字符串对象没有其他强引用对象引用，因此生成后会立刻释放，打印语句显示的内容为null</p>
<p>你也需要通过引用传递对象，下面代码能正常运行</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">BOOL</span> OK = [myObject performOperationWithError:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (!OK) &#123;</span><br><span class="line">    <span class="comment">// Report the error.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>然而，error的隐式声明为:</p>
<pre><code><span class="title">NSError</span> * __strong <span class="built_in">error</span>;
</code></pre><p>方法的声明为:</p>
<pre><code><span class="tag">-</span>(<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">performOperationWithError</span>:<span class="value">(NSError * __autoreleasing *)error</span></span>;
</code></pre><p>编译器因此会重写代码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> * __<span class="keyword">strong</span> error;</span><br><span class="line"><span class="built_in">NSError</span> * __autoreleasing tmp = error;</span><br><span class="line"><span class="built_in">BOOL</span> OK = [myObject performOperationWithError:&amp;tmp];</span><br><span class="line">error = tmp;</span><br><span class="line"><span class="keyword">if</span> (!OK) &#123;</span><br><span class="line">    <span class="comment">// Report the error.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>局部变量的声明(<strong>strong)与参数(_</strong>autoreleasing)之间不匹配造成编译器创建临时变量。像这样传递参数，可以直接手动声明变量为__autoreleasing,没有必要让编译器再生成中间变量。</p>
<h3 id="使用生命周期修饰符来避免强应用循环">使用生命周期修饰符来避免强应用循环</h3><p>你可以使用生命周期修饰符来避免强引用循环,例如，如果一个视图对象安排在父子层级，并且父对象需要指向子对象，反之亦然。你让父对象与子对象强关联，子对象与父对象弱关联。其他情况可能更微妙,特别是涉及block对象。</p>
<p>在MRC环境中，<strong>block id x;x没有保留。在ARC环境中，</strong>block id x;默认是保留x。为了在ARC下获得MRC的行为，你可以使用<strong>unsafe_unretained </strong>block id x;正如名字<strong>unsafe_unretained </strong>block id x;所示。然而，没有保留的变量是很危险的因此不推荐，两个更好的选择是用<strong>weak或者是设置</strong>block的值为nil打破循环引用。</p>
<p>下面的代码片段说明了这个问题,myController对象对completionHandler强引用，而在completionHandler中对myController对象也强引用，很明显会出现内存泄露。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyViewController</span> *myController = [[<span class="type">MyViewController</span> alloc] init…];</span><br><span class="line">// ...</span><br><span class="line">myController.completionHandler =  ^(<span class="type">NSInteger</span> <span class="literal">result</span>) &#123;</span><br><span class="line">   [myController dismissViewControllerAnimated:<span class="type">YES</span> completion:<span class="keyword">nil</span>];</span><br><span class="line">&#125;;</span><br><span class="line">[self presentViewController:myController animated:<span class="type">YES</span> completion:^&#123;</span><br><span class="line">   [myController release];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>解决方案1：可以使用__block修饰符并且设置myController变量为空在block中</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyViewController</span> * __block myController = [[<span class="type">MyViewController</span> alloc] init…];</span><br><span class="line">// ...</span><br><span class="line">myController.completionHandler =  ^(<span class="type">NSInteger</span> <span class="literal">result</span>) &#123;</span><br><span class="line">    [myController dismissViewControllerAnimated:<span class="type">YES</span> completion:<span class="keyword">nil</span>];</span><br><span class="line">    myController = <span class="keyword">nil</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解决方案2: 可以使用一个临时的weak变量</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyViewController</span> *myController = [[<span class="type">MyViewController</span> alloc] init…];</span><br><span class="line">// ...</span><br><span class="line"><span class="type">MyViewController</span> * __weak weakMyViewController = myController;</span><br><span class="line">myController.completionHandler =  ^(<span class="type">NSInteger</span> <span class="literal">result</span>) &#123;</span><br><span class="line">    [weakMyViewController dismissViewControllerAnimated:<span class="type">YES</span> completion:<span class="keyword">nil</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于非一般的循环，你应该使用:</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyViewController</span> *myController = [[<span class="type">MyViewController</span> alloc] init…];</span><br><span class="line">// ...</span><br><span class="line"><span class="type">MyViewController</span> * __weak weakMyController = myController;</span><br><span class="line">myController.completionHandler =  ^(<span class="type">NSInteger</span> <span class="literal">result</span>) &#123;</span><br><span class="line">    <span class="type">MyViewController</span> *strongMyController = weakMyController;</span><br><span class="line">    <span class="keyword">if</span> (strongMyController) &#123;</span><br><span class="line">        // ...</span><br><span class="line">        [strongMyController dismissViewControllerAnimated:<span class="type">YES</span> completion:<span class="keyword">nil</span>];</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        // <span class="type">Probably</span> nothing...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这种情况下,已经有一个弱引用的weakMyController，但是为什么在block中还要声明一个强引用strongMyController的局部变量呢？在某些情况下,如果myController在block调用之前被释放了，那么继续执行block的中的内容是,那么就会crash，用一个强引用的局部变量可以保证在block中myController在存在的。<br>在某些情况下,您可以使用<strong>unsafe_unretained如果类不兼容</strong>weak。然而,这也可能成为严重不切实际的周期,因为很难或不可能验证__unsafe_unretained指针仍然有效,仍然指向同一个对象。</p>
<h3 id="ARC管理AutoReleasePool">ARC管理AutoReleasePool</h3><p>使用ARC，你不能管理自动释放池直接使用<code>NSAutoreleasePool</code>，你可以使用@autoreleasepool block代替:</p>
<pre><code><span class="variable">@autoreleasepool</span> {
     <span class="comment">// Code, such as a loop that creates a large number of temporary objects.</span>
}
</code></pre><p>这个简单的结构允许编译器推断引用技术的状态。在入口点，一个自动释放池被Push，正常退出(brek,return,goto,fall-through等等)自动释放池被Pop。为了兼容现在的代码，如果退出是由于异常，那么自动释放池不会Pop。</p>
<h3 id="AutoReleasePool实际应用">AutoReleasePool实际应用</h3><p>在ARC的实际应用中，之前遇到过一种情况，就是对于大量数据处理的时候，如果不进行手动销毁释放池，那将会出现一个非常非常严重的内存问题和性能问题。下面示例说明:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *imagePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"IMG_5401"</span> ofType:<span class="string">@"JPG"</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithContentsOfFile:imagePath];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在没有手动销毁外循环内的自动释放池的情况下:<br><img src="http://7xkpsz.com1.z0.glb.clouddn.com/demo1.png" alt=""><br>手动销毁的情况:<br><img src="http://7xkpsz.com1.z0.glb.clouddn.com/8F9A8A26-1067-4CF3-B21E-2CB1479560C1.png" alt=""></p>
<h3 id="栈变量初始化为nil">栈变量初始化为nil</h3><p>使用ARC,strong,weak和autoreleasing栈变量会隐式的初始化为nil。</p>
<pre><code>- (<span class="keyword">void</span>)myMethod {
    <span class="built_in">NSString</span> *name;
    <span class="built_in">NSLog</span>(<span class="string">@"name: %@"</span>, name);
}
</code></pre><p>将会打印null而不是崩溃</p>
<h3 id="使用编译标志启用或禁用ARC">使用编译标志启用或禁用ARC</h3><p>启用ARC使用<code>-fobjc-arc</code>编译标志，禁用ARC的编译标致<code>-fno-objc-arc</code></p>
<h2 id="Toll-Free_Bridging(无缝桥接)">Toll-Free Bridging(无缝桥接)</h2><hr>
<p>在许多Cocoa应用中，你需要使用Core Foundation风格的对象，例如Core Foundation，CoreGraphics等等。编译器不会自动管理Core Foundation对象的生命周期，你必须调用CFRetain和CFRelease来管理Core Foundation对象的生命周期。</p>
<p>编译器必须知道由谁来负责释放转换后的对象,如果你把一个NSObject当作 Core Foundation 对象来使用,则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图,编译器没办法自己做主。同样如果你创建一个Core Foundation对象并把它转换为NSObject对象,你也必须告诉ARC占据对象的所有权,并在适当的时候释放该对象。这就是所谓的 bridging casts。</p>
<p>__bridge 改变Objective-C和Core Foundation对象的之间的类型转化，不改变对象的所有权。</p>
<p>__bridge_retained or CFBridgingRetain 将Objective-C对象转变为Core Foundation对象，并且所有权转变给Core Foundation,由程序员管理内存。</p>
<p>__bridge_transfer or CFBridgingRelease 将非Objective-C对象转变为Objective-C对象，所有权转变给ARC，由系统管理。</p>
<p>eg:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>logFirstNameOfPerson:<span class="params">(<span class="variable">ABRecordRef</span>)</span>person &#123;</span><br><span class="line"> </span><br><span class="line">    NSString *name = <span class="params">(<span class="variable">NSString</span> *)</span>ABRecordCopyValue<span class="params">(person, k<span class="variable">ABPersonFirstNameProperty</span>)</span>;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"Person's first name: %@"</span>, name)</span>;</span><br><span class="line">    [name release];</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>替换:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>logFirstNameOfPerson:<span class="params">(<span class="variable">ABRecordRef</span>)</span>person &#123;</span><br><span class="line"> </span><br><span class="line">    NSString *name = <span class="params">(<span class="variable">NSString</span> *)</span>CFBridgingRelease<span class="params">(<span class="variable">ABRecordCopyValue</span>(person, k<span class="variable">ABPersonFirstNameProperty</span>)</span>);</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"Person's first name: %@"</span>, name)</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>ARC是一个编译器的特征,提供自动管理对Objective-C对象的分配内存,而不是总是思索什么时候<code>retain</code>和什么时候<code>release</code>操作，ARC会让你把更多地精力集中在编码上。<br><img src="https:/]]>
    </summary>
    
      <category term="内存管理" scheme="http://linfeng1009.gitcafe.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cocoa Framework 生成脚本]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/10/29/Cocoa-Framework-%E7%94%9F%E6%88%90%E8%84%9A%E6%9C%AC/"/>
    <id>http://linfeng1009.gitcafe.io/2015/10/29/Cocoa-Framework-生成脚本/</id>
    <published>2015-10-29T06:53:23.000Z</published>
    <updated>2015-10-29T06:56:45.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sets the target folders and the final framework product.</span></span><br><span class="line">FMK_NAME=<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install dir will be the final output to the framework.</span></span><br><span class="line"><span class="comment"># The following line create it in the root folder of the current project.</span></span><br><span class="line">INSTALL_DIR=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;FMK_NAME&#125;</span>.framework</span><br><span class="line"></span><br><span class="line"><span class="comment"># Working dir will be deleted after the framework creation.</span></span><br><span class="line">WRK_DIR=build</span><br><span class="line">DEVICE_DIR=<span class="variable">$&#123;WRK_DIR&#125;</span>/Release-iphoneos/<span class="variable">$&#123;FMK_NAME&#125;</span>.framework</span><br><span class="line">SIMULATOR_DIR=<span class="variable">$&#123;WRK_DIR&#125;</span>/Release-iphonesimulator/<span class="variable">$&#123;FMK_NAME&#125;</span>.framework</span><br><span class="line"></span><br><span class="line"><span class="comment"># -configuration $&#123;CONFIGURATION&#125;</span></span><br><span class="line"><span class="comment"># Clean and Building both architectures.</span></span><br><span class="line">xcodebuild -configuration <span class="string">"Release"</span> -target <span class="string">"<span class="variable">$&#123;FMK_NAME&#125;</span>"</span> -sdk iphoneos clean build</span><br><span class="line">xcodebuild -configuration <span class="string">"Release"</span> -target <span class="string">"<span class="variable">$&#123;FMK_NAME&#125;</span>"</span> -sdk iphonesimulator clean build</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cleaning the oldest.</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="operator">-d</span> <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">cp -R <span class="string">"<span class="variable">$&#123;DEVICE_DIR&#125;</span>/"</span> <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.</span></span><br><span class="line">lipo -create <span class="string">"<span class="variable">$&#123;DEVICE_DIR&#125;</span>/<span class="variable">$&#123;FMK_NAME&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;SIMULATOR_DIR&#125;</span>/<span class="variable">$&#123;FMK_NAME&#125;</span>"</span> -output <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>/<span class="variable">$&#123;FMK_NAME&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">rm -r <span class="string">"<span class="variable">$&#123;WRK_DIR&#125;</span>"</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class=]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[3D Touch实践——Quick Action]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/10/20/3D-Touch%E5%AE%9E%E8%B7%B5/"/>
    <id>http://linfeng1009.gitcafe.io/2015/10/20/3D-Touch实践/</id>
    <published>2015-10-20T07:17:25.000Z</published>
    <updated>2015-12-18T08:09:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="3D_Touch简介">3D Touch简介</h2><p>随着iOS9以及iPhone 6s和iPhone 6s plus的发布，苹果添加一种立体的用户界面:<br>用户在主屏幕上不需要打开APP，按压图标就可以快速访问APP提供的一些功能。<br>在APP内，用户按压界面就可以预览更多地内容，获得加速访问的特征。</p>
<h2 id="主屏幕Quick_Action">主屏幕Quick Action</h2><p><img src="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/maps_directions_home_2x.png" alt=""></p>
<p>快速选项(Quick Action)可以让用户预见并加速与APP交互，iOS9SDK提供的官方API可以使你定义静态或者动态的快速选项，以及检测当前设备快速选项的可用性。</p>
<p>1.定义静态快速选项选项在APP工程的<code>Info.plist</code>文件中添加<code>UIApplicationShortcutItems</code>数组。<br>2.定义动态快速选项使用<code>UIApplicationShortcutItem</code>和相关的API，然后给应用程序的共享对象<code>UIApplication</code>使用<code>shortcutItems</code>这个属性添加动态的快速选项。</p>
<h3 id="静态快速选项">静态快速选项</h3><p><code>UIApplicationShortcutItems</code>(iOS数组)给APP指定静态主屏幕的快速选项，这个键包含了一个字典数组，每个字典包含关于一个快速选项的详细信息。<br>你可以指定静态快速选项给你的APP用一个字典数组。当用户在支持3D Touch的设备上按压主屏幕图标时，在主屏幕上显示快速选项的数量是由系统决定的(只能显示4个)。<br>静态快速选项你在<code>Info.plist</code>文件中定义显示在主屏幕上以同样地顺序出现在文件中。下面是一个Demo:<br><img src="http://7xkpsz.com1.z0.glb.clouddn.com/3dtouchInfoplist.png" alt=""></p>
<p>然后的AppDelegate.m文件中添加<code>application:performActionForShortcutItem:completionHandler:</code>代理方法，根据<code>UIApplicationShortcutItem</code>的type属性和之前在info.plist设置<code>UIApplicationShortcutItemType</code>对应的在值来判断，用户点击的是哪个快速选项。这个方法当用户通过选择一条接近激活应用时就会调用，除了<code>-application:willFinishLaunchingWithOptions: or -application:didFinishLaunchingWithOptions returns NO.</code>这种情况。在<code>-application:didFinishLaunchingWithOptions</code>中可以通过<code>UIApplicationLaunchOptionsShortcutItemKey</code>键来获取当前接收快速选项的<code>UIApplicationShortcutItem</code>对象，来处理用户的意图。<br>demo运行结果:<br><img src="http://7xkpsz.com1.z0.glb.clouddn.com/3dtouchquickaction.gif" alt=""></p>
<p><img src="http://7xkpsz.com1.z0.glb.clouddn.com/D1CAC8C1-A43C-4E11-B382-96D1270FD133.png" alt=""></p>
<p>静态定义快速在运行时常用的key:<br>UIApplicationShortcutItemType (必须使用) 用来区分与其他快速选项的分类<br>UIApplicationShortcutItemTitle (必须使用) 快速选项显示的标题<br>UIApplicationShortcutItemSubtitle  快速选项显示的子标题<br>UIApplicationShortcutItemIconType  图片类型由系统提供<br>UIApplicationShortcutItemIconFile  自定义的图标<br>UIApplicationShortcutItemUserInfo  附加信息</p>
<p>Demo地址: <a href="https://github.com/ludaye123/3DTouch-Static-QuickActions.git" target="_blank" rel="external">GitHub</a></p>
<h3 id="动态快速选项">动态快速选项</h3><p>定义动态快速选项使用<code>UIApplicationShortcutItem</code>和相关的API，然后给应用程序的共享对象<code>UIApplication</code>使用<code>shortcutItems</code>这个属性添加动态的快速选项。示例代码如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupApplicationShortcutItems</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIcon</span> *homeIcon = [<span class="built_in">UIApplicationShortcutIcon</span> iconWithType:<span class="built_in">UIApplicationShortcutIconTypeCompose</span>];</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIcon</span> *messageIcon = [<span class="built_in">UIApplicationShortcutIcon</span> iconWithTemplateImageName:<span class="string">@"message"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo1 = @&#123;<span class="string">@"key"</span>:<span class="string">@"home"</span>&#125;;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo2 = @&#123;<span class="string">@"key"</span>:<span class="string">@"message"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIMutableApplicationShortcutItem</span> *homeShortcutItem = [[<span class="built_in">UIMutableApplicationShortcutItem</span> alloc] initWithType:<span class="string">@"io.gitcafe.linfeng1009.main"</span> localizedTitle:<span class="string">@"主页"</span> localizedSubtitle:<span class="string">@"跳转主页"</span> icon:homeIcon userInfo:userInfo1];</span><br><span class="line">    <span class="built_in">UIMutableApplicationShortcutItem</span> *messageShortcutItem = [[<span class="built_in">UIMutableApplicationShortcutItem</span> alloc] initWithType:<span class="string">@"io.gitcafe.linfeng1009.message"</span> localizedTitle:<span class="string">@"消息"</span> localizedSubtitle:<span class="string">@"跳转消息"</span> icon:messageIcon userInfo:userInfo2];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *items = @[homeShortcutItem,messageShortcutItem];</span><br><span class="line">    <span class="built_in">NSArray</span> *exsitItems = [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.shortcutItems</span>;</span><br><span class="line">    <span class="built_in">NSArray</span> *updateItems = [exsitItems arrayByAddingObjectsFromArray:items];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.shortcutItems</span> = updateItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果:</p>
<p><img src="http://7xkpsz.com1.z0.glb.clouddn.com/2C7B34D8-D1B0-4AEA-98D9-D4DF3C812743.png" alt=""></p>
<h3 id="动态_VS_静态快速选项">动态 VS 静态快速选项</h3><p>定义主屏幕动态快速选项使用这个类(UIApplicationShortcutItem),代码创建快速选项，并且在运行时注册它们给应用程序对象。<br>定义主屏幕静态快速在运行时用<code>UIApplicationShortcutItems</code>数组在Xcode工程的<code>info.plist</code>文件中，当你的应用被安装时系统注册静态快速选项。<br>系统限制了快速在运行时显示的数量，当用户按压主屏幕上的图标，在限制显示的快速在运行时的标题内，静态快速在运行时具有优先显示(demo中可以看出)，开始显示在列表的顶部位置。如果你的静态快速在运行时没有超过限定显示的数量，并且也动态定义了快速在运行时，那么动态创建的快速在运行时也会显示。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="3D_Touch简介">3D Touch简介</h2><p>随着iOS9以及iPhone 6s和iPhone 6s plus的发布，苹果添加一种立体的用户界面:<br>用户在主屏幕上不需要打开APP，按压图标就可以快速访问APP提供的一些功能。<br>在APP内，]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 对象解析]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/10/19/object-parse/"/>
    <id>http://linfeng1009.gitcafe.io/2015/10/19/object-parse/</id>
    <published>2015-10-19T08:31:02.000Z</published>
    <updated>2015-10-19T08:31:02.000Z</updated>
    <content type="html"><![CDATA[<p>Apple开源库: <a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">点击这里</a>，当前版本为最新版本:objc4-647.tar.gz</p>
<p><img src="http://blog.leichunfeng.com/images/object_model.png" alt=""></p>
<h2 id="Object">Object</h2><hr>
<p>在Objective-C中，除了一些基本类型外，基本上都可以称之为对象。首先从类的实例进行分析：<br>打开刚刚下载源码的工程：<br>找到objc_private.h这个文件，在文件的上面部分可以看到Class和id的定义</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到Class和id分为objc_class和objc_object类型的指针，Command+左键查看下objc_object的定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    isa_t isa;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由此可以得知，其实oc对象实质上就是一个objc_object结构体的对象，仅包含一个isa的成员变量，isa所对应的内容就是对象所属的类。id在运行时通过isa可以指向任意的oc对象。</p>
<h2 id="Class">Class</h2><hr>
<p>对象发送一个消息时，所需的数据和方法都是由其所属类提供的，类描述了对象占用空间大小，成员变量的类型以及描述对象的行为。实质就是对象发送消息以及所需的数据是通过isa找到其所属的类，类来提供其对象所需的一切。<br>类的定义如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="keyword">uint32_t</span> info;</span><br><span class="line">    <span class="keyword">uint32_t</span> instance_size;</span><br><span class="line">    <span class="keyword">struct</span> old_ivar_list *ivars;</span><br><span class="line">    <span class="keyword">struct</span> old_method_list **methodLists;</span><br><span class="line">    Cache cache;</span><br><span class="line">    <span class="keyword">struct</span> old_protocol_list *protocols;</span><br><span class="line">    <span class="comment">// CLS_EXT only</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ivar_layout;</span><br><span class="line">    <span class="keyword">struct</span> old_class_ext *ext;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  more</span></span><br><span class="line">    	...</span><br><span class="line">   <span class="comment">// more</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在类的定义中，可以得出类实质上也是对象，它也包含isa成员变量，成员变量列表，方法列表以及协议列表。<br>那么类对象的isa对应的值又是什么呢？ 带着个这个问题继续。</p>
<h2 id="Meta_Class">Meta Class</h2><hr>
<p>通过上面类的定义得知类其实也是对象，既然是对象那就有对应的所属类，这个类称之为元类(Meta Class)，元类保存了静态方法列表。<br>我们在创建一个对象时，经常会使用某个类调用alloc或者new方法，例如[UIView new],给类对象发送一个new消息，和对象发送消息一样，类对象也要通过其isa找到对应的所属类，去查找响应的方法。<br>那么问题来了？元类是不是也是对象呢？ 没错，元类也是对象，叫做元类对象，那么它的isa对应的所属类又是什么？元类对象对应的所属类叫做根元类(Root Meta Class)。那么根元类理所当然也是一个对象，isa对应的值就是其本身。至于元类，在开发中并不能显示的调用而且也没用必要。</p>
<h2 id="总结">总结</h2><hr>
<p>1.类的对象发送消息时，根据isa找到其所属类，然后从类提供的方法去查找，如果当前类找不到，再从其父类中查找，直到找到，否则异常(不能识别方法)。<br>2.类对象发送消失时，根据isa找到元类，然后从元类提供的方法去查找，如果当前类找不到，在从其父类中查找，直到找到，否则异常。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Apple开源库: <a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">点击这里</a>，当前版本为最新版本:objc4-647.tar.gz</p>
<p]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/10/13/git-commad/"/>
    <id>http://linfeng1009.gitcafe.io/2015/10/13/git-commad/</id>
    <published>2015-10-13T07:23:24.000Z</published>
    <updated>2015-10-13T07:23:24.000Z</updated>
    <content type="html"><![CDATA[<p>1.初始化仓库 git init<br>2.添加文件到仓库<br>    git add <file><br>    git commit</file></p>
<p>3.查看仓库当前分支状态 git status<br>4.对比文件  git diff <file><br>5.查看提交记录 git log<br>6.查看命令记录 git reflog<br>7.回滚到上一个版本 git reset —hard HEAD^ 上上个版本git reset —hard HEAD^^<br>8.回滚到上20个版本 git reset —hard HEAD~20<br>9.修改了工作区文件，想放弃修改 git checkout — <file><br>10.修改了工作区文件，摒弃commit到缓存区，想放弃修改<br>  git reset HEAD <file><br>  git checkout — <file><br>11.添加到缓存区的文件<br>    rm <file><br>    工作区和版本库不一致<br>    两个选择<br>    从版本库中删除: git rm <file> ,git commit -m “说明”<br>    恢复文件: git checkout — <file><br>12.添加远程库 git remote add origin 仓库地址<br>远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来<br>之后推送使用 git push origin master， 拉取文件 git pull origin master<br>13.克隆远程库 git clone 仓库地址<br>14.查看分支 git branch (-a 包括远程分支)<br>15.创建分支 git branch <name><br>16.切换分支 git checkout <name><br>17.创建并切换分支 git checkout -b <name><br>18.在当前分支合并其他分支  git merge <name><br>19.删除分支 git branch -d <name><br>20.合并分支禁用Fast forward git merge —no-ff -m “合并说明” <name><br>21.保存当前工作区 git stash<br>22.查看缓存工作区列表 git stash list<br>22.恢复工作区 git stash pop<br>23.查看远程库信息 git remote -v；<br>24.本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致;建立本地分支和远程分支的关联，使用git branch —set-upstream branch-name origin/branch-name,从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</name></name></name></name></name></name></file></file></file></file></file></file></file></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1.初始化仓库 git init<br>2.添加文件到仓库<br>    git add <file><br>    git commit</file></p>
<p>3.查看仓库当前分支状态 git status<br>4.对比文件  git diff <file><br]]>
    </summary>
    
      <category term="Git" scheme="http://linfeng1009.gitcafe.io/tags/Git/"/>
    
      <category term="Git" scheme="http://linfeng1009.gitcafe.io/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIStackView Tutorial:介绍堆栈视图(译)]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/10/08/stack-view/"/>
    <id>http://linfeng1009.gitcafe.io/2015/10/08/stack-view/</id>
    <published>2015-10-08T09:54:03.000Z</published>
    <updated>2015-10-19T09:03:01.000Z</updated>
    <content type="html"><![CDATA[<p>英文原文: <a href="http://www.raywenderlich.com/114552/uistackview-tutorial-introducing-stack-views" target="_blank" rel="external">UIStackView Tutorial: Introducing Stack Views</a></p>
<p>我们都在那里，有个新的需求，你需要在运行时添加或者移除一个视图，并且也需要调整邻近的视图的位置。<br>你采用什么方法？你给约束添加输出口在故事板上这样你就能激活或者禁用某些吗?或者你使用第三方库？或根据复杂性也许你能在代码中做一切。<br>也许这次你的视图层次没有必要在运行时改变，但是你必须考虑如何把一个新视图嵌入到你的故事板。你有没有最终只是清除所有的约束并从头开始重新添加它们，因为它比执行复杂的约束操作更加容易吗？<br>随着UIStackView的引入，上面的任务变得非常简单。堆栈视图提供一种水平或者垂直布局多个视图方式。通过配置一些简单的属性，例如: <code>alignment</code>,<code>distribution</code>和<code>spacing</code>.你可以定义包含的视图如何去调整自己可用的空间。</p>
<h2 id="开始">开始</h2><p>在这篇UIStackView的引导，你运行的APP叫做<code>Vacation Spots</code>.它是一个简单的APP,向你展示一个为了摆脱烦恼的地名的列表。<br>但是不要收拾包裹就走人，因为这里有一些问题你将通过使用堆栈视图来修复，比你单独使用自动布局更加简单的一种方式.<br>开始下载<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip" target="_blank" rel="external">初始工程</a>作为引导，运行它在iPhone6模拟器上，你将看到你可能去度假的地名列表.<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/01-table-view-is-now-correct_750x1334-281x500.png" alt=""><br>去London的信息界面通过点击London单元.<br>初略一看，这个视图好像没什么问题，但是它有一些问题.<br>1.看到视图底部的排列的按钮.它们之间当前的位置有一个固定的空间值，所以它们没有适配屏幕的宽度。为了全面的看到问题，临时旋转模拟器屏幕到横屏方向通过按下Command和left按键(左方向箭头).<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/02-issues-visible-in-landscape-view_1334x750-480x270.png" alt=""><br>2.点击靠近<code>WEATHER</code>的<code>Hide</code>按钮，成功隐藏文字，但是没有重新调整它下面部分的位置，留下一块空白空间。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/03-hide-weather-issue_750x1334-281x500.png" alt=""><br>3.每节段的顺序能够改善，将会有更多逻辑，如果<code>what to see</code>这部分位置放置到<code>why visit</code>这部分后面，在<code>weather</code>它们之间。<br>4.底部的按钮有点太靠近视图底部边缘在横屏模式下。最好是如果你可以减少不同部分之间的间距——但只有在横向模式。</p>
<p>现在,你有一个想法你会做改善,是时候进入这个项目。<br>打开<code>Main.storyboard</code>并且查看<code>Spot Info View Controller</code>场景，有一些颜色在你的堆栈视图中。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/04-colorful-scene-in-storyboard_504x636-396x500.png" alt=""></p>
<p>这些标签和按钮已经设置了各种背景颜色在运行时会被清除。在故事板中，它们简单的可视帮助显示如何改变堆视图的各种属性从而影响内嵌视图的结构.<br>你现在不需要这样做,但是如果在任何时候你想看到背景颜色在运行应用程序时,可以暂时注释掉以下行在 SpotInfoViewController内的viewDidLoad方法。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clear background colors from labels and buttons</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">view</span> <span class="keyword">in</span> backgroundColoredViews &#123;</span><br><span class="line">  <span class="keyword">view</span>.backgroundColor = UIColor.clearColor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，任意输出口连接的标签有占位符文本，那些设置的输出口变量的名称为了使它们连接。这使得更简单告诉标签将更新它们的文本在运行时。例如，标签随着文本<whyvisitlabel>被连接为：</whyvisitlabel></p>
<pre><code><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> whyVisitLabel: <span class="type">UILabel</span>!
</code></pre><p>需要注意的另一件事是，故事板的场景不是默认600x600的方块当使用size classes.<br>size classes一直可用，但初始导航控制器的大小设置为iPhone 4英寸以下模拟指标部分在属性检查器。这一点容易使用故事板;模拟指标属性在运行时没有任何影响——视图将为不同的设备调整。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/05-simulated-metrics-iphone-4-inch_639x173.png" alt=""></p>
<h2 id="你的第一个堆视图">你的第一个堆视图</h2><hr>
<p>第一件事你将通过使用堆视图修复底部排列按钮之间的空隙。堆栈视图可以分发其视图沿其轴以不同的方式,与等量的方法之一是每个视图之间的间距。<br>幸运地是，嵌入已存在的视图到新堆视图中并不是火箭科学。首先，选择所有的按钮底部的位置<code>Spot Info View Controller</code>场景通过点击一个,然后按住Command键点击另外两个:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/06-select-bottom-row-of-buttons_420x80.png" alt=""><br>如果大纲视图不是已经打开,继续打开它通过显示文档大纲按钮左下角的画布:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/07-document-outline-button_120x40.png" alt=""><br>验证所有三个按钮选择通过检查他们的大纲视图:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/08-verify-button-selection_360x90.png" alt=""><br>他们并不都是选择,你也可以在大纲视图命令点击每个按钮来选择他们。一旦选中,单击新的堆栈按钮底部的工具栏自动布局正确的故事板的画布上:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/09-stack_button_outlined_148x52.png" alt=""><br>这些按钮将被嵌入新的堆栈视图中:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/10-bottom-row-is-now-in-stack-view_640x100.png" alt=""><br>这些按钮现在整齐彼此连靠着-你很快就会解决。<br>虽然堆栈视图负责定位按钮,但是你还需要添加自动布局约束位置堆栈视图本身。<br>嵌入一个视图在堆栈视图时,约束其他视图删除。例如,嵌入在堆栈视图按钮之前,<code>Submit Rating</code>按钮的顶部有一个垂直间距约束连接它的底部<code>Rating</code>标签:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/11-prior-constraint_420x90.png" alt=""><br>点击<code>Submit Rating</code>按钮,它不再有任何约束附加到它:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/12-no-more-constraints_400x80.png" alt=""><br>验证约束消失的另一种方法是通过查看尺寸检查器(⌥⌘5):<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/13-check-size-inspector_640x80.png" alt=""><br>为了约束添加到堆栈视图本身,您首先需要选择。在故事板中选择一个堆栈视图很棘手,如果其视图完全填满堆栈视图。一个简单的方法是在大纲视图选择堆栈视图:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/14-stack-view-document-outline-selection_660x80.png" alt=""><br>另一个技巧是按住Shift键和右键单击任何堆栈视图的视图,或者Control-Shift-click如果你使用触控板。你会得到一个上下文菜单,显示了视图层次结构在你点击的位置,和你只是选择堆栈视图菜单中点击它。现在,选择堆栈视图使用Shift-Right-click方法:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/15-select-stack-view-in-view-hierarchy-menu_400x280.png" alt=""><br>现在，点击Pin按钮在自动布局工具栏上给它添加约束:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/16-pin-button_142x57.png" alt=""><br>First add a check to Constrain to margins. Then add the following constraints to the edges of your stack view:<br>首先添加一个检查约束边缘。然后添加以下约束你的边缘堆栈视图:</p>
<pre><code><span class="string">Top:</span> <span class="number">20</span>, <span class="string">Leading:</span> <span class="number">0</span>, <span class="string">Trailing:</span> <span class="number">0</span>, <span class="string">Bottom:</span> <span class="number">0</span>
</code></pre><p>仔细检查上面的数字,上下左右的约束,确保焊接层选择。然后点击添加4约束:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/17-bottom-stack-view-constraints_264x364.png" alt=""><br>堆栈的视图是正确的大小,但它已经扩大了第一个按钮填充任何额外的空间:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/18-first-button-is-stretched_400x80.png" alt=""><br>属性决定了一个堆栈视图列出了其观点沿轴分布性质。目前,它的设置来填补,这意味着所包含的视图将完全填补堆栈视图沿其轴。为此,堆栈视图只会扩大它的一个视图来填补这一额外的空间,具体地说,它扩展了视图内容紧凑优先级最低的水平,或者如果所有优先级相等,它扩展了第一个视图。<br>然而,你不是寻找按钮完全填满堆栈视图——你希望他们是等距的。确保堆栈视图仍然选择和属性检查器。改变填充等于间距的分布:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/19-change-distribution-to-equal-spacing_640x148.png" alt=""><br>现在编译和运行,点击任何单元,旋转模拟器(⌘→)。你会发现底部按钮现在空间本身同样!<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/20-now-buttons-are-equally-spaced_1334x750-480x270.png" alt=""><br>为了解决这个问题不使用堆栈视图,您将不得不使用间隔的视图,每一对按钮之间。你必须添加等宽约束到所有的间隔的视图以及大量的额外约束。<br>它会看起来像下面这样。为了在截图中可见,间隔的视图有一个浅灰色背景:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/21-alternate-solution-1_346x76.png" alt=""><br>这不是太多的问题如果你只有这一次的故事板,但许多视图是动态的。这不是一个简单的任务在运行时来添加一个新按钮或隐藏或删除现有的按钮，由于相邻间隔视图和约束，为了隐藏一个视图在堆栈视图,所有你要做的就是设置包含视图的隐藏属性为true和堆栈视图处理其余的。这就是你会修理间隔在<code>WEATHER</code>下面标签当用户隐藏文本。您将在本教程稍后做一旦天气部分标签添加到一个堆栈视图。</p>
<h2 id="转化部分">转化部分</h2><hr>
<p>你会把所有的其他部分在SpotInfoViewController使用堆栈视图。这将使您可以轻松地完成剩下的任务。接下里你将转化评级部分。</p>
<h3 id="评级部分">评级部分</h3><p>正如上面你刚刚创建堆栈视图，选择旁边的<code>Rating</code>标签和<code>Star</code>标签:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/22-select-rating-label-and-stars-label_640x74.png" alt=""><br>然后单击栈上的按钮来将它们嵌入在堆栈视图:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/23-after-clicking-stack-button_640x74.png" alt=""><br>现在点击Pin按钮，勾选<code>Constrain to margins</code>并且添加下面三个约束:<br>Top: 20, Leading: 0, Bottom: 20<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/24-add-second-stack-view-constraints_264x171.png" alt=""><br>现在去属性检查器设置间隔为8:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/25-set-spacing-to-8_259x87.png" alt=""><br>有可能你会看到一个错误的观点警告,看到这样<code>stars</code>标签已经超出界限的视图:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/26-stars-label-weirdly-stretched_640x85.png" alt=""><br>有时Xcode可能暂时显示警告或堆栈视图位置不正确,但警告将会消失,你让其他更新。您通常可以忽略这些。然而,立即修复它,你能说服堆栈视图布局通过将其框架由一个点和背部或临时改变它的一个布局属性。为了说明这一点,改变从填补顶部对齐,然后回到填补。现在你会看到星星标签位置正确:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/27-change-alignment-to-top-and-back_640x85.png" alt=""><br>构建和运行验证一切看起来和之前一模一样。</p>
<h3 id="取消嵌入堆栈视图">取消嵌入堆栈视图</h3><p>在你走得太远之前,最好有一些基本的“急救”培训。有时你可能会发现自己与你不再需要额外的堆栈视图,可能是因为实验、重构或只是偶然。幸运的是,有一个简单的方法来从堆栈视图unembed视图。首先,你要选择你想要删除的堆栈视图。然后按住Option键,点击栈上的按钮。在出现的上下文菜单中点击Unembed:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/28-how-to-unembed_186x71.png" alt=""><br>另一个方法是选择堆栈视图,然后从菜单中选择Editor\ Unembed。</p>
<h3 id="你的第一个垂直堆栈视图">你的第一个垂直堆栈视图</h3><p>现在，你将创建你的第一个垂直堆栈视图，选择<code>WHY VISIT</code>标签和<code>&lt;whyVisitLabel&gt;</code>如下:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/29-select-why-visit-labels_640x90.png" alt=""><br>Xcode将正确推断,这应该是一个垂直堆栈视图基于标签的位置。单击堆栈按钮嵌入这两个堆栈视图:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/30-embed-why-visit-labels_640x90.png" alt=""><br>较低的标签以前约束将视图的右边距,但约束时被嵌入在堆栈视图。目前,堆栈视图没有约束,所以采用的固有宽度最大的视图。<br>随着堆栈视图被选择，点击Pin按钮，勾选<code>Constrain to margins</code>,设置上，左和右的约束为0.<br>然后,单击下拉底部约束和选择<code>WEATHER</code>(当前距离=20)：<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/31-dont-select-nearest-neighbor-constraint_463x417.png" alt=""><br>默认情况下,显示最近的邻居的约束,这为约束隐藏按钮底部的距离15。你真需要约束下面的<code>WEATHER</code>标签。最后,点击 Add 4 Constraints。您现在应该看到如下:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/32-why-visit-stack-view-stretched_640x90.png" alt=""><br>您现在有了一个扩展堆栈视图右边固定在右边距的视图。然而,底部标签还是一样的宽度。你会解决这个问题通过更新堆栈视图对齐属性。</p>
<h2 id="对齐属性">对齐属性</h2><hr>
<p>对齐属性决定了一个堆栈视图列出了其视图垂直于轴。垂直堆栈视图,可能的值<code>Fill</code>,<code>Leading</code>、<code>Center</code>和<code>Trailing</code>。可能水平堆栈视图对齐值略有不同:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/33-horizontal-and-vertical-alignment_594x171.png" alt=""><br><code>.Top</code>代替<code>.Leading</code>,<code>Bottom</code>代替<code>.Trailing</code>,也有两个属性,只在水平方向上是有效的。<code>.FirstBaseline</code>, <code>.LastBaseline</code>。<br>选择每个值,看看它如何影响标签的位置垂直堆栈视图:<br>Fill:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/34-alignment-fill_640x64.png" alt=""><br>Leading:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/35-alignment-leading_640x64.png" alt=""><br>Center:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/36-alignment-center_640x64.png" alt=""><br>Trailing:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/37-alignment-trailing_640x64.png" alt=""><br>当你完成测试每个值,设置对齐来填充:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/38-now-select-alignment-fill_640x64.png" alt=""><br>然后构建和运行验证一切看起来不错,没有退化。</p>
<p>指定<code>Fill</code>意味着你想要的所有视图完全填满堆栈视图垂直于它的轴。这导致<code>WHY VISIT</code>标签来扩大自己的右边缘。<br>但如果你只想要底部标签扩大自身优势?<br>现在,没关系因为标签在运行时将有一个透明的背景,但它将很重要当你转化<code>weather</code>部分时。<br>您将了解如何完成,使用一个额外的堆栈视图。</p>
<h2 id="转化WHAT_TO_SEE部分">转化WHAT TO SEE部分</h2><hr>
<p>这个部分非常类似于前面,所以这里的说明是短暂的。<br>1.首先，选择<code>WHAT TO SEE</code>标签和下面的<code>&lt;whatToSeeLabel&gt;</code><br>2.点击堆栈按钮<br>3.点击Pin按钮<br>4.勾选<code>Constrain to margin</code>,并且添加下面四个约束:<br>Top: 20, Leading: 0, Trailing: 0, Bottom: 20<br>5.设置堆栈视图的对齐方式为Fill<br>你的故事板现在看起来应该是这样的:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/39-after-what-to-see-section_640x308.png" alt=""><br>构建和运行验证一切看起来仍然一样。<br>这使得你只有<code>WEATHER</code>部分了。</p>
<h2 id="转化WEATHER部分">转化WEATHER部分</h2><p>WEATHER部分比其他部分更加复杂，由于包含隐藏按钮。<br>一种方法你可以用将创建一个嵌套的堆栈视图通过将天气标签和隐藏按钮嵌入到一个水平堆栈视图,然后嵌入水平堆栈视图和<code>&lt;weatherInfoLabel&gt;</code>垂直堆栈视图。<br>看起来像这样的:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/40-weather-stack-in-stack_640x92.png" alt=""><br>注意<code>WEATHER</code>标签已经扩大到等于<code>Hide</code>按钮的高度。这并不是理想的方法,因为这将导致基线之间的有额外的空间<code>WEATHER</code>标签和它下面的文本。<br>记住,<code>alignment</code>指定定位垂直堆栈视图。所以,你可以设置<code>alignment</code>到<code>Bottom</code>:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/41-weather-stack-in-stack-alignment-bottom_640x92.png" alt=""><br>但你真的不想<code>Hide</code>按钮的高度决定堆栈视图的高度。<br>您将实际的方法是有<code>Hide</code>按钮不会在天气的堆栈视图部分,或任何其他堆栈视图。<br>它仍将是一个顶层视图的子视图,您将添加一个约束<code>WEATHER</code>标签——这将会在堆栈视图。没错,你会从一个按钮添加一个约束之外的一个堆栈视图标签在一个堆栈视图!<br>选择<code>WEATHER</code>标签和它下面的<code>&lt;weatherInfoLabel&gt;</code>：<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/42-select-weather-and-info-label_640x92.png" alt=""><br>点击堆栈按钮:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/43-weather-click-stack-button_640x92.png" alt=""><br>点击Pin按钮，勾选<code>Constrain to margins</code>，添加下面四个约束:<br>Top: 20, Leading: 0, Trailing: 0, Bottom: 20<br>设置堆栈视图的对齐方式为Fill:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/44-weather-alignment-fill_640x92.png" alt=""><br>你需要<code>Hide</code>按钮的左边缘和<code>WEATHER</code>标签的右边缘之间的约束,因此天气标签填补堆栈视图不能工作。<br>但是,你希望<code>&lt;weatherInfoLabel&gt;</code>填补堆栈底部视图<br>。你可以做到这一点通过嵌入<code>WEATHER</code>标签到垂直堆栈视图。记住,一个垂直堆栈视图的一致性可以设置<code>.Leading</code>,如果堆栈视图是超出其内在的宽度,其包含的视图仍将是其主要方面保持一致。<br>选择<code>WEATHER</code>标签使用文档大纲,或通过使用Control-Shift-click方法:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/45-select-just-the-weather-label_640x92.png" alt=""><br>然后点击堆栈按钮:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/46-weather-in-horizontal-stack_640x92.png" alt=""><br>设置<code>Alignment</code>为<code>Leading</code>,确保<code>Axis</code>设置为<code>Vertical</code>：<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/47-vertical-and-leading_640x92.png" alt=""><br>很完美!你有外堆栈视图拉伸内部堆栈视图来填补宽度,但内部堆栈视图允许标签保持原来的宽度!<br>构建和运行。为什么是闲逛的<code>Hide</code>按钮在文本中间呢?<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/48-hide-label-incorrect-position_750x573-419x320.png" alt=""><br>这是因为当你嵌入天气标签在堆栈视图,和它之间的任何约束,<code>Hide</code>按钮被移除。<br>添加新的约束从隐藏按钮<code>control - drag``WEATHER</code>标签:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/49-drag-to-weather-label_380x94.png" alt=""><br>然后按住Shift选择多个选项,并选择水平间距和基线。然后点击添加约束:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/50-add-multiple-constraints_380x224.png" alt=""><br>构建和运行。隐藏按钮现在应该正确定位,因为被设置为隐藏的标签是嵌入在一个堆栈视图,紧迫的隐藏隐藏标签,并调整它下面的视图-—一切无需手动调整任何约束。<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/51-hide-button-works_750x732-328x320.png" alt=""><br>现在所有的部分都是独特的堆栈视图,你将它们嵌入到外部堆栈视图,这将使最后的两个任务微不足道。</p>
<h2 id="顶层堆栈视图">顶层堆栈视图</h2><hr>
<p>命令点击选择所有五个顶级堆栈视图在大纲视图:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/52-select-all-stack-views-in-outline_640x260.png" alt=""><br>然后点击堆栈按钮:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/53-stack-all-the-views_640x185.png" alt=""><br>点击Pin按钮，勾选<code>Constrain to margins</code>,添加所有边缘的约束为0。设置<code>Spacing</code>为20，<code>Alignment</code>为<code>Fill</code>,你的故事板场景看起来像这样:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/54-set-the-spacing-to-20-and-alignment-to-fill_640x300.png" alt=""><br>编译运行:<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/55-hide-button-lost-again_750x487-480x312.png" alt=""><br>哎呀!看起来<code>Hide</code>按钮再次失去了约束当<code>WEATHER</code>堆栈视图是嵌入在外层堆栈视图。没问题,再加上约束以同样的方式。<br>从<code>Hide</code>按钮<code>control - drag``WEATHER</code>标签,然后按住<code>Shift</code>,选择水平间距和基线。然后点击添加约束:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/56-add-constraints-to-button-again_380x223.png" alt=""><br>编译运行，<code>Hide</code>按钮现在的位置是正确的。</p>
<h2 id="重新定位视图">重新定位视图</h2><hr>
<p>现在,所有的部分都是在一个顶级堆栈视图中,您将修改<code>WHAT TO SEE</code>部分的位置到<code>WEATHER</code>部分上面。<br>从大纲视图选择中间堆栈视图,并将其拖动到第一和第二的视图之间。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:保持堆栈的指针稍微往左视图之间你拖动它,这样它仍然是一个外堆栈视图的子视图。蓝色小圆应该定位在两个堆栈视图之间的左边缘,而不是在正确的边缘:</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/57-drag-and-drop-to-reposition-section_639x130.png" alt=""><br>现在<code>WEATHER</code>部分是第三节从顶部起,但自从<code>Hide</code>按钮不是堆栈视图的一部分,它不会被移动,所以它的结构将会错位。<br>点击<code>Hide</code>按钮选择它:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/58-hide-button-not-moved_640x130.png" alt=""><br>然后单击解决自动布局问题中的三角形形状的按钮自动布局工具栏和下所选视图部分,点击update frame:<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/59-resolve-auto-layout-issues_356x269.png" alt=""><br><code>Hide</code>按钮将会返回正确的位置:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/60-hide-button-back-to-correct-position_640x130.png" alt=""><br>很好，用自动布局重新定位视图和重新添加约束就不会是你做过的最困难的事。</p>
<h2 id="Size_Class基本配置">Size Class基本配置</h2><hr>
<p>最后,你就可以把注意力转移到一个剩余的任务列表。在横屏模式中,垂直空间是非常珍贵的,所以你想将堆栈视图的部分更紧密地联系在一起。要做到这一点,您将使用大小类顶级堆栈视图的间距设置为10,而不是20时,垂直类是紧凑的大小。<br>选择顶级堆栈视图,单击+按钮旁边的<code>Spacing</code>:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/61-select-plus-button_260x120.png" alt=""><br>选择<code>Any Width &gt; Compact Height</code>:<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/62-anywidth-compact-height_403x108.png" alt=""><br>设置<code>Spacing</code>为10在新的<code>wAny hC</code>区域:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/63-set-spacing-to-10_260x160.png" alt=""><br>编译和运行。竖屏模式的间距应该保持不变。旋转模拟器(⌘←)和注意,部分减少之间的间距和按钮现在有充裕的空间从底部的视图:<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/64-spacing-in-iphone-landscape_1334x750-480x270.png" alt=""><br>如果你没有添加一个顶级堆栈视图中,您仍然可以使用大小类的垂直间距设置为10的四个约束条件,单独的五个部分,但它不是更好的设置在一个地方吗?<br>你和你的时间有更好的事情要做,例如动画!</p>
<h2 id="动画">动画</h2><hr>
<p>目前,有点突兀,隐藏和显示天气信息。您将添加一些动画平滑过渡。<br>堆栈视图与UIView动画引擎完全兼容。这意味着动画安排子视图的外观/消失,很简单,其切换动画块内部隐藏的属性。<br>是时候写些代码了，打开<code>SpotInfoViewController.swift</code>看到<code>updateWeatherInfoViews(hideWeatherInfo:animated:).</code><br>你看到这个方法的尾部这行</p>
<pre><code>weatherInfoLabel<span class="class">.hidden</span> = shouldHideWeatherInfo
</code></pre><p>用下面的方法代替它:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> animated &#123;</span><br><span class="line">  UIView.animateWithDuration(<span class="number">0.3</span>) &#123;</span><br><span class="line">    self.weatherInfoLabel.<span class="variable">hidden =</span> shouldHideWeatherInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  weatherInfoLabel.<span class="variable">hidden =</span> shouldHideWeatherInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译和运行,点击隐藏或显示按钮。动画感觉不是更好?<br>除了动画隐藏的属性视图中包含堆栈视图中,您还可以动画属性堆栈视图本身,如<code>alignment</code>、<code>distribution</code>、<code>spacing</code>和<code>axis</code>。</p>
<h2 id="从这里去哪里?">从这里去哪里?</h2><p>你可以下载完成的代码<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip" target="_blank" rel="external">在这里</a><br>在这UIStackView教程中,您学到了很多关于堆栈视图以及堆栈视图使用的各种属性定位它的子视图。堆栈视图是高度可配置的,而且可能有一个以上的方式实现相同的结果。<br>最好的方法是建立在你学过的东西自己尝试各种属性。而不是设置属性和移动,请参阅玩其他属性如何影响视图中的堆栈视图的布局。<br>本教程是一个缩写版的第六章,“UIStackView和自动布局变化”和第七章“中间UIStackView”从iOS 9教程。如果你想了解更多关于UIStackView和其他新特性在iOS 9请看看这本书!<br>与此同时,如果你有任何问题或评论本教程或堆栈视图,请加入以下论坛讨论!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文原文: <a href="http://www.raywenderlich.com/114552/uistackview-tutorial-introducing-stack-views" target="_blank" rel="external">UIStackVi]]>
    </summary>
    
      <category term="iOS9" scheme="http://linfeng1009.gitcafe.io/tags/iOS9/"/>
    
      <category term="iOS翻译" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Associated Objects实现用Block代替UIAlertView代理方法]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/09/23/associated-object/"/>
    <id>http://linfeng1009.gitcafe.io/2015/09/23/associated-object/</id>
    <published>2015-09-23T04:05:34.000Z</published>
    <updated>2015-09-23T04:05:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>之前在一个项目中，有多个地方要用到UIAlertView，每次都要遵循UIAlertView协议，实现代理方法，使得代码过于分散。在iOS8以后，官方提供了UIAlertController类，通过闭包终于可以甩掉之前的代理方法了，但是在iOS8一下，同样想实现这样的功能，首先想到的是通过创建一个category，但是在category中并不能添加属性。在官方文档中有看到 objc_setAssociatedObject 和 objc_getAssociatedObject运行时方法可以动态关联对象,那么这样就没问题了。</p>
<h3 id="1-AssociatedObject_API简介">1.AssociatedObject API简介</h3><h4 id="objc_setAssociatedObject">objc_setAssociatedObject</h4><hr>
<p><code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</code><br>设置一个关联值对于一个给定对象使用给定的key和关联策略</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>object</td>
<td>关联的对象</td>
</tr>
<tr>
<td>key</td>
<td>关联的key</td>
</tr>
<tr>
<td>value</td>
<td>关联对象关联的key对于的value</td>
</tr>
<tr>
<td>policy</td>
<td>关联策略</td>
</tr>
</tbody>
</table>
<p>关联策略类似于定于属性时的修饰(strong,weak,nonatomic)</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_ASSIGN</span> = <span class="number">0</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_RETAIN_NONATOMIC</span> = <span class="number">1</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_COPY_NONATOMIC</span> = <span class="number">3</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_RETAIN</span> = <span class="number">01401</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_COPY</span> = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="objc_getAssociatedObject">objc_getAssociatedObject</h4><hr>
<p><code>id objc_getAssociatedObject(id object, void *key)</code><br>通过对象用指定的key获取value</p>
<h4 id="objc_removeAssociatedObjects">objc_removeAssociatedObjects</h4><hr>
<p><code>void objc_removeAssociatedObjects(id object)</code><br>移除关联对象所有关联的内容</p>
<h3 id="2-使用AssociatedObject用Block代替UIAlertView的代理方法">2.使用AssociatedObject用Block代替UIAlertView的代理方法</h3><hr>
<h4 id="2-1_定义AlertAction">2.1 定义AlertAction</h4><p>1.新建一个继承NSObject的DSAlertAction<br>2.定义一个title属性和block<br>3.定义一个初始化方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^DSAlertActionHandler) ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DSAlertAction</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) DSAlertActionHandler alertActionHandler;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)actionWithTitle:(<span class="built_in">NSString</span> *)title handler:(DSAlertActionHandler)alertActionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2_UIAlertView分类">2.2 UIAlertView分类</h4><hr>
<p>1.初始化方法，注意在初始化方法中otherAlertActions是可变参数</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">-<span class="params">(id)</span>initWithTitle:<span class="params">(<span class="variable">NSString</span> *)</span>title message:<span class="params">(<span class="variable">NSString</span> *)</span>message cancelAlertAction:<span class="params">(<span class="variable">DSAlertAction</span> *)</span>cancelAlertAction otherAlertActions:<span class="params">(<span class="variable">DSAlertAction</span> *)</span>otherAlertActions, </span>... <span class="variable">NS_REQUIRES_NIL_TERMINATION</span>;</span><br></pre></td></tr></table></figure>
<p>2.添加一个addAction方法，用来添加操作<br>3.设置关联对象,初始化方法中otherAlertActions是可变参数，关联一个数组对象，用来存储这些参数，稍后会在其代理方法中使用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *)alertActions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *alertActions = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">void</span> *)ALERT_ACTIONS);</span><br><span class="line">    <span class="keyword">if</span>(!alertActions)</span><br><span class="line">    &#123;</span><br><span class="line">        alertActions = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">void</span> *)ALERT_ACTIONS, alertActions, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> alertActions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.在代理方法中，调用在初始化方法中传递的操作</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(buttonIndex &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	TODO: 从关联数组中取出对应的操作对象，然后调用其block</span><br><span class="line">        <span class="built_in">NSArray</span> *alertActions = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">void</span> *)ALERT_ACTIONS);</span><br><span class="line">        DSAlertAction *alertAction = alertActions[buttonIndex];</span><br><span class="line">        <span class="keyword">if</span>(alertAction<span class="variable">.alertActionHandler</span>)</span><br><span class="line">            alertAction<span class="variable">.alertActionHandler</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">void</span> *)ALERT_ACTIONS, <span class="literal">nil</span>, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">    TODO: 在完成操作后，切记将关联key对象的值置空，防止内存泄露</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，UIActionSheet可以这样实现。<br>具体代码已上传至GitHub: <a href="https://github.com/ludaye123/DSAlertView-Blocks" target="_blank" rel="external">https://github.com/ludaye123/DSAlertView-Blocks</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="前言">前言</h3><p>之前在一个项目中，有多个地方要用到UIAlertView，每次都要遵循UIAlertView协议，实现代理方法，使得代码过于分散。在iOS8以后，官方提供了UIAlertController类，通过闭包终于可以甩掉之前的代理方法了，但是]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS多线程总结之NSOperation 和 NSOperationQueue]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/09/22/thread-summary-nsoperate/"/>
    <id>http://linfeng1009.gitcafe.io/2015/09/22/thread-summary-nsoperate/</id>
    <published>2015-09-22T05:11:32.000Z</published>
    <updated>2015-09-22T05:11:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="NSOperation">NSOperation</h2><h3 id="1-NSOperation概述">1.NSOperation概述</h3><p><code>NSOperation</code>类是一个抽象类，你用来封装代码和数据与单一任务关联。因为它是抽象的，不能直接使用这个类，但可以直接子类化或者是使用系统定义好的子类(<code>NSInvocationOperation</code> or <code>NSBlockOperation</code>)去执行实际任务。尽管是抽象的，<code>NSOperation</code>基本实现包括了重要的逻辑确保安全执行你的任务。这些内建的逻辑允许你集中精力在实际实现的任务中，而不是粘合代码来确保它和系统其他的对象正常运行。</p>
<p>一个操作对象是一个单一的对象，它只执行任务一次并且不能用来重复执行。你执行操作通过把它们加入到一个操作队列(<code>NSOperationQueue</code>的对象)中，操作队列中的操作就会直接执行在一个不同的线程，间接的使用<code>libdispatch</code>库(通常讲的GCD)</p>
<h3 id="2-NSOperation的子类">2.NSOperation的子类</h3><p><code>NSOperation</code>是一个抽象类，系统预先给我们提供了两个子类，分别是:<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>.</p>
<h4 id="2-1_NSInvocationOperation">2.1 NSInvocationOperation</h4><p><code>NSInvocationOperation</code>类是<code>NSOperation</code>的具体子类，管理执行单一封装的任务，你可以使用这个类去启动一个操作，由指定的对象调用选择器。这个类实现非并发操作。</p>
<h4 id="2-1-1_使用方法">2.1.1 使用方法</h4><p>初始化方法，返回一个<code>NSInvocationOperation</code>对象，指定的目标对象和选择器进行初始化</p>
<pre><code><span class="pp">- <span class="params">(instancetype)</span>initWithTarget:<span class="params">(id)</span>target
                  selector:<span class="params">(<span class="variable">SEL</span>)</span>sel
                    object:<span class="params">(id)</span>arg</span>
</code></pre><p>eg:</p>
<pre><code>- (<span class="keyword">void</span>)viewDidLoad
{
    [<span class="keyword">super</span> viewDidLoad];
     <span class="built_in">NSInvocationOperation</span> *invocaitonOperation = [[<span class="built_in">NSInvocationOperation</span> alloc]
     initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(downLoadTask) object:<span class="literal">nil</span>];
   <span class="comment">// [invocaitonOperation start];</span>
       <span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];
    [operationQueue addOperation:invocaitonOperation];
}    

- (<span class="keyword">void</span>)downLoadTask
{
      <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);
      TODO: &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fc8cb502b60</span>&gt;{number = <span class="number">1</span>, name = main}
      这里打印出当成线程的信息，是主线程，也就是说如果直接调用其start方法并不会去创建一个新的线程执
      行任务，只是在当前线程中执行
   TODO: &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fb18a59a410</span>&gt;{number = <span class="number">2</span>, name = (null)}
   修改上面的代码，把操作添加到操作队列后，在操作队列中会自动调用start,并且产生新的线程
   <span class="built_in">NSBlockOperation</span> 同样如此
}
</code></pre><h4 id="2-2_NSBlockOperation">2.2 NSBlockOperation</h4><p><code>NSBlockOperation</code>是<code>NSOperation</code>的另一个具体的子类，管理并发执行的一个或多个block。你可以使用这个对象立马执行多个block，并没有为每个block创建一个单独操作对象。当执行超过一个block时，这个操作本身会考虑只有当所有的block执行完成后才会结束。Blocks增加到一个block操作中会分发一个默认的优先级的工作队列，block本身不应该设想关于配置它们执行的环境。</p>
<h4 id="2-2-1_使用方法">2.2.1 使用方法</h4><p>指定一个block创建并返回<code>NSBlockOperation</code>对象</p>
<pre><code>+ (instancetype)<span class="string">blockOperationWithBlock:</span>(<span class="typename">void</span> (^)(<span class="typename">void</span>))block
- (<span class="typename">void</span>)<span class="string">addExecutionBlock:</span>(<span class="typename">void</span> (^)(<span class="typename">void</span>))block  <span class="comment">// 增加多个block</span>
</code></pre><p>eg: </p>
<pre><code><span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^{

    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);

}];

<span class="comment">//    [blockOperation start];</span>
<span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];
[operationQueue addOperation:blockOperation];
</code></pre><h4 id="2-3_自定义NSOperation">2.3 自定义NSOperation</h4><p>对于非并发的操作，你仅重载一个main方法即可，在这个方法中，你放置需要执行所给任务的代码，当然你也可以自定义一个初始化方法来构造和创建自定义类的对象。也许你可能想要定义getter和setter方法来访问数据从这个操作中，然而，如果你自定义的getter和setter方法，你必须确保这些方法能被安全的调用从多线程中。</p>
<p>如果你想要创建一个并发操作，你至少需要重载下面的方法和属性。</p>
<pre><code><span class="built_in">start</span>
asynchronous
executing
finished
</code></pre><p>对于一个并发操作，你的<code>start</code>方法是负责启动异步操作的方式。是否生产一个线程或者调用一个异步方法，你要从这个方法实现。在开始操作，你的<code>start</code>方法应该更新这个操作的执行状态通过<code>executing</code>属性记录。做这个操作是通过发送KVO通知给<code>executing</code>关键路径，这让其他与这个操作有联系的对象知道这个操作现在已经在运行，你的<code>executing</code>属性必须在线程安全的方式下提供状态变化。</p>
<h3 id="3-NSOperation_依赖">3.NSOperation 依赖</h3><p>依赖是一种便捷的方式去执行操作按照指定的命令。你能添加和移除依赖给一个操作使用<code>addDependency:</code>和<code>removeDependency:</code>方法。默认情况，一个操作对象的依赖不认为是准备好的直到所有的依赖操作对象都完成执行。一旦最后一个依赖操作完成，这个依赖操作对象变成准备状态并且能够被执行。举个例子来说，有两个操作operation1和operation2，如果operation1依赖operation2,那么需要等operation2完成后，operation1才可以执行。</p>
<p>eg: </p>
<pre><code>  <span class="built_in">NSBlockOperation</span> *downOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^{
    <span class="comment">// 开始下载任务，例如下载一个一张图片</span>
    <span class="built_in">NSLog</span>(<span class="string">@"下载图片"</span>);
}];

<span class="built_in">NSBlockOperation</span> *processOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^{
    <span class="comment">// 下载完成后，处理图片</span>
    <span class="built_in">NSLog</span>(<span class="string">@"处理图片"</span>);
}];

[processOperation addDependency:downOperation];
<span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];
[operationQueue addOperation:downOperation];
[operationQueue addOperation:processOperation];
TODO: 不要把操作设置依赖为自己本身，如果这样做会造成死循环，并且这个操作不会执行
</code></pre><h2 id="NSOperationQueue">NSOperationQueue</h2><h3 id="1-NSOperationQueue的概述">1.NSOperationQueue的概述</h3><p><code>NSOperationQueue</code>类管理执行操作对象的集合，操作对象加入到队列后会保留在队列中直到它已经明确的取消或者完成执行任务。操作在队列内(但尚未执行)它们自己有组织的根据优先级和互相依赖的对象相应的去执行。一个应用可以创建多个操作队列并且可以提交操作到多个操作队列中的任何一个。<br>相互依赖的对象提供了一个绝对执行的命令给这些操作对象，甚至这个操作位于不同的操作队列中。一个操作对象不被考虑准备执行直到所有的依赖操作已经完成执行。对于准备执行的操作对象，操作队列总是先执行高优先级相对其他已准备的操作。<br>你不能直接移除一个操作从队列中在它被加入后。一个操作保留在队中直到它记录操作已经完成了任务。完成了任务并不意味着操作执行的任务也完成了。一个操作能够被取消。取消一个操作对象在队列中离开的对象通知对象尽可能快的中止任务。对于当前正在执行的操作，这意味着操作对象工作的执行代码必须检查取消状态，停止一切正在做的事情，并且标记它已经完成。对于排队但尚未执行的操作，队列必须调用操作对象的<code>start</code>方法，以便它可以处理取消事件并且标记它已完成。</p>
<h3 id="2-NSOperationQueue常用方法和属性">2.NSOperationQueue常用方法和属性</h3><h4 id="2-1_方法">2.1 方法</h4><p><code>+ (NSOperationQueue *)currentQueue</code> 获取当前队列<br><code>+ (NSOperationQueue *)mainQueue</code>  获取与主线程相关联的操作队列<br><code>- (void)addOperation:(NSOperation *)operation</code> 添加一个操作<br><code>- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops
    waitUntilFinished:(BOOL)wait</code> 添加一个操作的数组，wait为YES会阻塞当前线程，直到所有的操作完成<br><code>- (void)addOperationWithBlock:(void (^)(void))block</code> 将一单一的block封装到一个操作对象内添加到队列<br><code>- (void)cancelAllOperations</code>  取消队列中所有执行的操作，这个方法会调用队列中所有操作对象的<code>cancel</code>方法<br><code>- (void)waitUntilAllOperationsAreFinished</code> 阻塞当前线程直到所有排队或者执行的操作完成执行</p>
<h4 id="2-2_属性">2.2 属性</h4><p><code>@property NSInteger maxConcurrentOperationCount</code> 队列中能够同时执行的最大操作个数，默认没有限制<br><code>@property(getter=isSuspended) BOOL suspended</code> 队列是否处于活动状态 </p>
<h3 id="3-NSOperationQueue的使用">3.NSOperationQueue的使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocationOperation</span> *operation1 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(processOperation) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *operation2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作2"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">[operationQueue addOperation:operation1];</span><br><span class="line">[operationQueue addOperation:operation2];</span><br><span class="line">[operationQueue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作3"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)processOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"操作1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSOperation_class/index.html" target="_blank" rel="external">NSOperation</a><br><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSInvocationOperation_Class/index.html" target="_blank" rel="external">NSInvocationOperation</a><br><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSBlockOperation_class/index.html#//apple_ref/doc/uid/TP40008157-CH1-SW2" target="_blank" rel="external">NSBlockOperation</a><br><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSOperationQueue_class/" target="_blank" rel="external">NSOperationQueue</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="NSOperation">NSOperation</h2><h3 id="1-NSOperation概述">1.NSOperation概述</h3><p><code>NSOperation</code>类是一个抽象类，你用来封装代码和数据与单一任务关联。因为它是抽]]>
    </summary>
    
      <category term="iOS多线程" scheme="http://linfeng1009.gitcafe.io/tags/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS多线程总结之NSThread]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/09/16/thread-summary-nsthread/"/>
    <id>http://linfeng1009.gitcafe.io/2015/09/16/thread-summary-nsthread/</id>
    <published>2015-09-16T01:54:02.000Z</published>
    <updated>2015-09-16T01:54:02.000Z</updated>
    <content type="html"><![CDATA[<p>iOS开发中，实现线程的方式总体有三种<br>1.NSThread<br>2.NSOperate 和 NSOperateQueue<br>3.GCD<br>还有一种更加底层的API,用pthread来实现</p>
<h3 id="NSThread">NSThread</h3><p>一个NSThread对象控制一条线程的执行。用这个类当你想要让一个OC方法运行在它自己的执行线程中。线程特别有用 当你需要执行一个漫长的任务时,但是又不想阻塞应用中其他部分的执行。另外,你能够用线程去避免阻塞应用的主线程,处理用户界面和相关的事件操作。线程也能别用来把一个大的任务分解成多个小得任务,从而引领性能提升在多核计算机上。</p>
<h4 id="1-NSThread的使用">1.NSThread的使用</h4><p>创建一个NSThread对象，官方提供了两个方法</p>
<pre><code><span class="pp">- <span class="params">(instancetype)</span>initWithTarget:<span class="params">(id)</span>target
                  selector:<span class="params">(<span class="variable">SEL</span>)</span>selector
                    object:<span class="params">(id)</span>argument

+ <span class="params">(void)</span>detachNewThreadSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector
                   toTarget:<span class="params">(id)</span>aTarget
                 withObject:<span class="params">(id)</span>anArgument</span>
</code></pre><h4 id="2-参数">2.参数</h4><p>target:    指定对象的消息通过选择器发送<br>selector: 选择器指定发送给目标对象的消息，这个选择器最多只有一个参数并且必须没有返回值<br>argument: 传给目标对象的单一参数，可以为空</p>
<h4 id="3-区别">3.区别</h4><p><code>NSThread</code>提供成员方法和静态方法来创建其对象，前者跟后者的区别在于启动线程的时候，前者需要调用<code>start</code>方法来启动，后者会自动启动。</p>
<h4 id="4-NSObject方法">4.NSObject方法</h4><p>用NSObject提供的<code>performSelectorInBackground</code>的方法隐式创建线程,通过<code>performSelectorOnMainThread</code>方法在主线程上的更新。</p>
<pre><code><span class="pp">- <span class="params">(void)</span>performSelectorInBackground:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>arg
- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait</span>
</code></pre><h4 id="5-常用属性和方法">5.常用属性和方法</h4><p>1.<code>sleepUntilDate</code> 睡眠直到指定的时间(<code>NSDate</code>)<br>2.<code>sleepForTimeInterval</code> 睡眠给定一个指定的时长(单位为秒)<br>3.<code>exit</code> 退出当前线程<br>4.<code>cancel</code> 取消当前线程<br>5.<code>isMainThread</code> 是否是主线程<br>6.<code>mainThread</code> 获取主线程<br>7.<code>currentThread</code> 获取当前线程<br>8.<code>executing</code> 是否正在执行(Bool)<br>9.<code>finished</code> 是否完成执行(Bool)<br>10.<code>cancelled</code> 是否取消(Bool)</p>
<h4 id="6-通知">6.通知</h4><p><code>NSDidBecomeSingleThreadedNotification</code>  暂时没有实现<br><code>NSThreadWillExitNotification</code>  当线程将要退出的时候会发送此通知<br><code>NSWillBecomeMultiThreadedNotification</code> 当且仅当第一个线程从当前线程中派发的时候会发送此通知<br>通知中的object就是这个当前发送通知的传递的线程对象，这个通知不会包含userinfo字典内容</p>
<h4 id="7-eg">7.eg</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    [NSThread detachNewThreadSelector:self toTarget:@selector(downloadTask) withObject:nil];</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(downloadTask) object:<span class="literal">nil</span>];    </span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadTask</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">///////////////////////</span></span><br><span class="line">    <span class="comment">// 开始执行比较耗时的是操作</span></span><br><span class="line">    <span class="comment">// 执行完成后，到主线程中进行刷新操作</span></span><br><span class="line">     <span class="built_in">NSString</span> *url = <span class="string">@"http://tao.goulew.com/users/upfile/201504/201504081150270big.jpg"</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc] initWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:url]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(updateUI:) withObject:image waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)updateUI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 更新页面操作</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单下载图片的例子，效果如下</p>
<p><img src="http://7xkpsz.com1.z0.glb.clouddn.com/Simulator%20Screen%20Shot%20Sep%2015,%202015,%2012.54.59.png?imageView2/2/w/320/h/568" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>iOS开发中，实现线程的方式总体有三种<br>1.NSThread<br>2.NSOperate 和 NSOperateQueue<br>3.GCD<br>还有一种更加底层的API,用pthread来实现</p>
<h3 id="NSThread">NSThread</h3]]>
    </summary>
    
      <category term="iOS多线程" scheme="http://linfeng1009.gitcafe.io/tags/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[制作pod库并提交到Cocoapods]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/08/20/create-pods/"/>
    <id>http://linfeng1009.gitcafe.io/2015/08/20/create-pods/</id>
    <published>2015-08-20T05:35:14.000Z</published>
    <updated>2015-09-09T02:32:41.000Z</updated>
    <content type="html"><![CDATA[<p>摘自:<a href="http://yulingtianxia.com/blog/2014/05/26/publish-your-pods-on-cocoapods-with-trunk/" target="_blank" rel="external">玉令天下</a></p>
<p>简介<br>2014年5月20日，CocoaPods不再接受向CocoaPods/Specs的pull request，官方的说法是为了安全考虑，防止每个人的pod被其他人修改，于是CocoaPods团队开发了trunk服务，这样每个人都是其发布的pod的owner，没有权限的人无法修改，这样更安全。<br>更改后的提交架构是这样的：(来自官方图片)</p>
<p><img src="http://blog.cocoapods.org/assets/blog_img/trunk/architecture-diagram.png" alt=""></p>
<p>以前的podspec文件都是ruby格式，而trunk为我们带来了更轻便的json格式，你后你可以用json来配置你的pod了。不用担心过去我们发布的pod，他们依然健在，并且trunk会将podspec文件转化为podspec.json文件。<br>这里给出一个官方的介绍链接：<a href="http://blog.cocoapods.org/CocoaPods-Trunk/#transition" target="_blank" rel="external">http://blog.cocoapods.org/CocoaPods-Trunk/#transition</a><br>废话不多说，简要介绍下如何使用trunk新建我们的pod：<br>开始注册<br>trunk需要CocoaPods 0.33版本以上，用pod —version命令查看版本，如果版本低，需要升级：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gem <span class="keyword">install</span> cocoapods</span><br><span class="line">pod setup</span><br></pre></td></tr></table></figure></p>
<p>然后会一直卡在Setting up CocoaPods master repo这里，这条命令用于跟新本地电脑上的保存的Pods依赖库tree。由于每天有很多人会创建或者更新Pods依赖库，这条命令执行的时候会相当慢，还请耐心等待。我们需要经常执行这条命令，否则有新的Pods依赖库的时候执行pod search命令是搜不出来的。再开启一个终端，通过cd ~/.cocoapods命令进入cocoapods根目录，然后通过du -sh *命令查看总的文件大小，如果隔一阵子会增加，那么说明一切正常，下载速度取决于你的网络。<br>更新完成后，下一步是注册trunk，这一步需要自备梯子，否则就会出现这种问题<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pod</span> trunk register yulingtianxia<span class="variable">@gmail</span>.com <span class="string">'Yang Xiaoyu'</span> --description=<span class="string">'macbook pro'</span> --verbose</span><br></pre></td></tr></table></figure></p>
<p>上面的命令是我注册时使用的，你需要把邮箱和名字以及描述替换成你的，加上—verbose可以输出详细debug信息，方便出错时查看。<br>注册后CocoaPods会给你的邮箱发送验证链接，点击后就注册成功了，可以用pod trunk me命令查看自己的注册信息：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bogon:YXYNumberAnimationLabel yangxiaoyu$ pod trunk me</span><br><span class="line">  -<span class="ruby"> <span class="constant">Name</span><span class="symbol">:</span>     <span class="constant">Yang</span> <span class="constant">Xiaoyu</span></span><br><span class="line"></span>  -<span class="ruby"> <span class="constant">Email</span><span class="symbol">:</span>    yulingtianxia<span class="variable">@gmail</span>.com</span><br><span class="line"></span>  -<span class="ruby"> <span class="constant">Since</span><span class="symbol">:</span>    <span class="constant">May</span> <span class="number">25</span>th, <span class="number">20</span><span class="symbol">:</span><span class="number">27</span></span><br><span class="line"></span>  -<span class="ruby"> <span class="constant">Sessions</span><span class="symbol">:</span> </span><br><span class="line"></span>    -<span class="ruby"> <span class="constant">May</span> <span class="number">25</span>th, <span class="number">20</span><span class="symbol">:</span><span class="number">27</span> - <span class="constant">September</span> <span class="number">30</span>th, <span class="number">22</span><span class="symbol">:</span><span class="number">41</span>. <span class="constant">IP</span><span class="symbol">:</span> <span class="number">23.228</span>.<span class="number">209.171</span></span><br><span class="line"></span>  Description: macbook pro</span><br></pre></td></tr></table></figure></p>
<p>上面是我的注册信息，CocoaPods不通过密码来验证用户，而是通过一个session token。<br>部署你的Pod<br>首先你需要建立一个podspec文件，这是我的podspec文件：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib <span class="keyword">create</span> <span class="keyword">Library</span></span><br></pre></td></tr></table></figure>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.<span class="built_in">new</span> <span class="built_in">do</span> |s|</span><br><span class="line">  s.name         = <span class="string">"YXYNumberAnimationLabel"</span></span><br><span class="line">  s.<span class="built_in">version</span>      = <span class="string">"1.0.1"</span></span><br><span class="line">  s.summary      = <span class="string">"一个可以动起来的数字Label"</span></span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line">                    通过设置数字变化的插值来展现动画效果</span><br><span class="line">                   DESC</span><br><span class="line">  s.homepage     = <span class="string">"https://github.com/yulingtianxia/YXYNumberAnimationLabel"</span></span><br><span class="line">  </span><br><span class="line">  s.license      = <span class="string">'MIT'</span></span><br><span class="line">  s.author       = &#123; <span class="string">"YangXiaoyu"</span> =&gt; <span class="string">"yulingtianxia@gmail.com"</span> &#125;</span><br><span class="line">  s.social_media_url = <span class="string">"http://twitter.com/yulingtianxia"</span></span><br><span class="line">  s.source       = &#123; :git =&gt; <span class="string">"https://github.com/yulingtianxia/YXYNumberAnimationLabel.git"</span>, :tag =&gt; s.<span class="built_in">version</span>.to_s &#125;</span><br><span class="line"></span><br><span class="line">  s.<span class="built_in">platform</span>     = :ios, <span class="string">'6.0'</span></span><br><span class="line">  s.requires_arc = <span class="constant">true</span></span><br><span class="line"></span><br><span class="line">  s.source_files = <span class="string">'YXYNumberAnimationLabel/*'</span></span><br><span class="line">  s.frameworks = <span class="string">'Foundation'</span>, <span class="string">'UIKit'</span></span><br><span class="line">  <span class="comment">#s.private_header_files = 'Classes/ios/private/*.h'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#s.dependency 'FLKAutoLayout', '~&gt; 0.1'</span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>具体配置什么的大家走很熟悉，这里只是讲述使用trunk后需要注意的地方和新的操作<br>在验证和上传你的podspec文件到trunk之前，需要将你的源码push到Github上，tag一个版本号并发布一个release版本，这样podspec文件中的s.source的值才能是准确的：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add -A &amp;&amp; git <span class="operator"><span class="keyword">commit</span> -m <span class="string">"Release 1.0.1."</span>  </span><br><span class="line">git tag <span class="string">'1.0.1'</span>  </span><br><span class="line">git push <span class="comment">--tags  </span></span><br><span class="line">git push origin <span class="keyword">master</span></span></span><br></pre></td></tr></table></figure></p>
<p>这两条命令是为pod添加版本号并打上tag:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="operator">the</span> <span class="built_in">new</span> <span class="built_in">version</span> <span class="built_in">to</span> <span class="number">1.0</span>.1</span><br><span class="line"><span class="built_in">set</span> <span class="operator">the</span> <span class="built_in">new</span> tag <span class="built_in">to</span> <span class="number">1.0</span>.1</span><br></pre></td></tr></table></figure></p>
<p>在你podspec文件下的路径运行pod trunk push YXYNumberAnimationLabel.podspec 命令，同样需要翻墙梯子自备，别忘了将YXYNumberAnimationLabel.podspec替换成你的podspec文件名。<br>pod trunk push命令做了如下三个工作：<br>验证你本地的podspec文件（你也可以用pod lib lint命令来验证）<br>上传你的podspec文件到trunk<br>将你的podspec文件转化成trunk需要的JSON文件<br>如果部署成功，CocosPods会在Twitter上@你<br>就像文章最开始的架构图描述的那样，你在trunk中的操作依然会在CocoaPods/Specs仓库中更新。以后再做更改时只需要更新版本号然后通过trunk来提交，不用向CocoaPods/Specspull request并等待审核和merge了。<br>运行pod setup来更新你的Pods依赖库tree后，再使用pod search YXYNumberAnimationLabel命令来查找刚刚加入的名字叫YXYNumberAnimationLabel的依赖库：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; YXYNumberAnimationLabel (<span class="number">1.0</span>.1)</span><br><span class="line">   一个可以动起来的数字Label</span><br><span class="line">   pod <span class="string">'YXYNumberAnimationLabel'</span>, <span class="string">'~&gt; 1.0.1'</span></span><br><span class="line">   - <span class="string">Homepage:</span> <span class="string">https:</span><span class="comment">//github.com/yulingtianxia/YXYNumberAnimationLabel</span></span><br><span class="line">   - <span class="string">Source:</span>   <span class="string">https:</span><span class="comment">//github.com/yulingtianxia/YXYNumberAnimationLabel.git</span></span><br><span class="line">   - <span class="string">Versions:</span> <span class="number">1.0</span>.1, <span class="number">1.0</span>.0 [master repo]</span><br></pre></td></tr></table></figure></p>
<p>将其他人加入到你的Pod<br>为了让其他人也有权限来和你一起建设你的代码，你需要运行下面的命令来赋予别人权限，假如我将kyle@cocoapods.org加入到我的名字叫ARAnalytics的库中，我需要运行下面的命令：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk<span class="instruction"> add-owner </span>ARAnalytics kyle@cocoapods.org</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>摘自:<a href="http://yulingtianxia.com/blog/2014/05/26/publish-your-pods-on-cocoapods-with-trunk/" target="_blank" rel="external">玉令天下</a><]]>
    </summary>
    
      <category term="Cocoapods" scheme="http://linfeng1009.gitcafe.io/tags/Cocoapods/"/>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发常用正则表达式]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/08/18/modified-by-helensong/"/>
    <id>http://linfeng1009.gitcafe.io/2015/08/18/modified-by-helensong/</id>
    <published>2015-08-18T07:54:03.000Z</published>
    <updated>2015-10-19T09:02:20.000Z</updated>
    <content type="html"><![CDATA[<p>在之前项目开发中，遇到过一些输入内容的判断，判断手机号码是否合法等等。<br>记录下iOS开发中常用的正则表达式。</p>
<p>手机号码</p>
<p>1)移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188<br>2)联通：130,131,132,152,155,156,185,186<br>3)电信：133,1349,153,180,189<br>NSString * MOBILE = @”^1(3[0-9]|5[0-35-9]|8[025-9])\d{8}$”;</p>
<p>中国移动：China Mobile<br>134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188<br>NSString * CM = @”^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\d)\d{7}$”;</p>
<p>中国联通：China Unicom<br>130,131,132,152,155,156,185,186<br>NSString * CU = @”^1(3[0-2]|5[256]|8[56])\d{8}$”;</p>
<p>中国电信：China Telecom<br>133,1349,153,180,189<br>NSString * CT = @”^1((33|53|8[09])[0-9]|349)\d{7}$”;</p>
<p>大陆地区固话及小灵通<br>区号：010,020,021,022,023,024,025,027,028,029<br>号码：七位或八位<br>NSString * PHS = @”^0(10|2[0-5789]|\d{3})\d{7,8}$”;</p>
<pre><code>以上集合一起，并兼容<span class="number">14</span>开头的
+ (<span class="built_in">BOOL</span>)isMobileNumber:(<span class="built_in">NSString</span> *)mobileNum
{
    <span class="built_in">NSString</span> * phoneRegex = <span class="string">@"^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$"</span>;
    <span class="built_in">BOOL</span> isMatch = [mobileNum isMatchedByRegex:phoneRegex];
    <span class="keyword">return</span> isMatch;
}
</code></pre><hr>
<p>邮箱验证<br>       NSString *emailRegex = @”[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}”; </p>
<p>匹配中文字符的正则表达式： [\u4e00-\u9fa5]<br>评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 </p>
<p>匹配双字节字符(包括汉字在内)：[^\x00-\xff]<br>评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） </p>
<p>匹配空白行的正则表达式：\n\s*\r<br>评注：可以用来删除空白行 </p>
<p>匹配HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/\1&gt;|&lt;.</em>? /&gt;<br>评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧没有能力为力 </p>
<p>匹配首尾空白字符的正则表达式：^\s<em>|\s</em>$<br>评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 </p>
<p>匹配Email地址的正则表达式：\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*<br>评注：表单验证时很实用 </p>
<p>匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*<br>评注：网上流传的版本功能很有限，上面这个基本可以满足需求 </p>
<p>匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br>评注：表单验证时很实用 </p>
<p>匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}<br>评注：匹配形式如 0511-4405222 或 021-87888822 </p>
<p>匹配腾讯QQ号：[1-9][0-9]{4,}<br>评注：腾讯QQ号从10000开始 </p>
<p>匹配中国邮政编码：[1-9]\d{5}(?!\d)<br>评注：中国邮政编码为6位数字 </p>
<p>匹配身份证：\d{15}|\d{18}<br>评注：中国的身份证为15位或18位 </p>
<p>匹配ip地址：\d+.\d+.\d+.\d+<br>评注：提取ip地址时有用 </p>
<p>匹配特定数字：<br>^[1-9]\d<em>$　 　 //匹配正整数<br>^-[1-9]\d</em>$ 　 //匹配负整数<br>^-?[1-9]\d<em>$　　 //匹配整数<br>^[1-9]\d</em>|0$　 //匹配非负整数（正整数 + 0）<br>^-[1-9]\d<em>|0$　　 //匹配非正整数（负整数 + 0）<br>^[1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>$　　 //匹配正浮点数<br>^-([1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>)$　 //匹配负浮点数<br>^-?([1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>|0?.0+|0)$　 //匹配浮点数<br>^[1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）<br>^(-([1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）<br>评注：处理大量数据时有用，具体应用时注意修正 </p>
<p>匹配特定字符串：<br>^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串<br>^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串<br>^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串<br>^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串<br>^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在之前项目开发中，遇到过一些输入内容的判断，判断手机号码是否合法等等。<br>记录下iOS开发中常用的正则表达式。</p>
<p>手机号码</p>
<p>1)移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,18]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深复制VS浅复制]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/07/09/deepcopy-vs-shallowcopy/"/>
    <id>http://linfeng1009.gitcafe.io/2015/07/09/deepcopy-vs-shallowcopy/</id>
    <published>2015-07-09T06:26:48.000Z</published>
    <updated>2015-07-13T02:04:14.000Z</updated>
    <content type="html"><![CDATA[<p>苹果官方内存管理原则：<br>1.谁创建谁负责release：如果使用 alloc、new、copy、mutablecopy来创建对象，那么必须要调用release或者autorelease来释放对象。<br>2.谁retain谁负责release：只要你对对象使用了retain方法，那么必须要调用release或者autorelease来释放对象。</p>
<p>深复制 VS 浅复制 (deep copy VS shallow copy)</p>
<p>深复制：通过复制操作后，返回一个新的副本对象，对此副本对象的任何操作不会影响到原对象，当然原对象的任何操作也不会影响到副本对象。在OC中的深复制本质上是产生了一个新的对象，<br>也就是常说的内容复制(内容拷贝)；</p>
<p>浅复制：通过复制操作后，得到一个副本对象，在OC中本质上是对于原对象的指针复制，没有产生新的对象。</p>
<p>copy VS mutablecopy</p>
<p>shallow copy eg:</p>
<pre><code><span class="built_in">NSString</span> *scrStr  = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSString</span> *copyStr = [scrStr <span class="keyword">copy</span>];

<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %p,copyStr = %p \n"</span>,scrStr,copyStr); <span class="comment">// 内存地址: scrStr = 0x100211d90,copyStr = 0x100211d90  一致</span>
<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %@,copyStr = %@ \n"</span>,scrStr,copyStr); <span class="comment">// 打印内容: scrStr = deep copy vs shallow copy,copyStr = deep copy vs shallow copy </span>
</code></pre><p>deep copy eg:</p>
<pre><code><span class="built_in">NSString</span> *scrStr  = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSMutableString</span> *copyStr = [scrStr mutableCopy];

<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %p,copyStr = %p \n"</span>,scrStr,copyStr); <span class="comment">//内存地址: scrStr = 0x100208490,copyStr = 0x100208490 内存地址不一致，说明生产了新的对象</span>
<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %@,copyStr = %@ \n"</span>,scrStr,copyStr); <span class="comment">//打印内容: scrStr = deep copy vs shallow copy,copyStr = deep copy vs shallow copy </span>
</code></pre><p>deep copy eg:</p>
<pre><code><span class="built_in">NSMutableString</span> *scrStr  = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSString</span> *copyStr = [scrStr mutableCopy];

<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %p,copyStr = %p \n"</span>,scrStr,copyStr); <span class="comment">//内存地址: scrStr = 0x100111f10,copyStr = 0x100111fe0 内存地址不一致，说明生产了新的对象</span>
<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %@,copyStr = %@ \n"</span>,scrStr,copyStr); <span class="comment">//打印内容: scrStr = deep copy vs shallow copy,copyStr = deep copy vs shallow copy </span>
</code></pre><p>deep copy eg:</p>
<pre><code><span class="built_in">NSMutableString</span> *scrStr  = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSMutableString</span> *copyStr = [scrStr mutableCopy];

<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %p,copyStr = %p \n"</span>,scrStr,copyStr); <span class="comment">//内存地址: scrStr = 0x100111f10,copyStr = 0x100111fe0 内存地址不一致，说明生产了新的对象</span>
<span class="built_in">NSLog</span>(<span class="string">@"scrStr = %@,copyStr = %@ \n"</span>,scrStr,copyStr); <span class="comment">//打印内容: scrStr = deep copy vs shallow copy,copyStr = deep copy vs shallow copy </span>
</code></pre><p>通过以上几个示例，当使用copy方法时，返回的是一个不可变副本，也就是相当于指针拷贝，使用mutablecopy方法时，会返回一个可变副本，相当于内容拷贝，会生成新的对象。</p>
<p>Copy 内存管理</p>
<p>浅复制内存管理 eg:</p>
<pre><code><span class="built_in">NSString</span> *scrStr  = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSString</span> *copyStr = [scrStr <span class="keyword">copy</span>];
<span class="built_in">NSLog</span>(<span class="string">@"srcStr = %zd,copyStr = %zd"</span>,[scrStr retainCount],[copyStr retainCount]); <span class="comment">//引用计数: srcStr = 2,copyStr = 2</span>
[copyStr release];
</code></pre><p>深复制内存管理 eg:</p>
<pre><code><span class="built_in">NSMutableString</span> *scrStr  = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"deep copy vs shallow copy"</span>];
<span class="built_in">NSString</span> *copyStr = [scrStr <span class="keyword">copy</span>];        
<span class="built_in">NSLog</span>(<span class="string">@"srcStr = %zd,copyStr = %zd"</span>,[scrStr retainCount],[copyStr retainCount]); <span class="comment">//引用计数: srcStr = 1,copyStr = 1</span>
[copyStr release];
</code></pre><p>浅复制：没有产生新对象，但是原对象(副本对象)的引用计数会加1，上例中srcStr对象非自己生成，无需再调用release，但copyStr是srcStr对象的副本，所以需要调用release释放内存<br>深复制：产生新对象，原对象的引用计数不变，副本对象的引用计数为1，上例中srcStr对象非自己生成，无需再调用release,但copyStr是srcStr深复制而来，所以需要调用release释放内存</p>
<p>总结：</p>
<p>深复制：<br>        1.原对象和副本对象不是指向同一个对象<br>        2.原对象的引用计数不变，副本对象的引用计数为1<br>    3.深复制的实质是生成新的对象</p>
<p>浅复制：<br>    1.原对象和副本对象指向同一个对象<br>    2.原对象(副本对象)的引用计数加1，相当于做了一次retain操作<br>    3.浅复制的实质没有产生新对象，仅是指针拷贝</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>苹果官方内存管理原则：<br>1.谁创建谁负责release：如果使用 alloc、new、copy、mutablecopy来创建对象，那么必须要调用release或者autorelease来释放对象。<br>2.谁retain谁负责release：只要你对对象使用了ret]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Xcode升级插件失效修复方法]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/07/07/xcode-update-plugin-problem/"/>
    <id>http://linfeng1009.gitcafe.io/2015/07/07/xcode-update-plugin-problem/</id>
    <published>2015-07-07T09:50:23.000Z</published>
    <updated>2015-12-18T08:07:44.000Z</updated>
    <content type="html"><![CDATA[<p>1.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`defaults <span class="keyword">read</span> <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Info DVTPlugInCompatibilityUUID`</span><br></pre></td></tr></table></figure></p>
<p>2.然后输入如下命令   【最后一项是获取到的DVTPlugInCompatibilityUUID】</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find</span> ~<span class="regexp">/Library/</span>Application\ Support<span class="regexp">/Developer/</span>Shared<span class="regexp">/Xcode/</span>Plug-ins -name Info.plist -maxdepth <span class="number">3</span> | xargs -I&#123;&#125; defaults <span class="keyword">write</span> &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add <span class="number">0420</span>B86A-AA43-<span class="number">4792</span>-<span class="number">9</span>ED0-<span class="number">6</span>FE0F2B16A13</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>1.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</s]]>
    </summary>
    
      <category term="Xcode" scheme="http://linfeng1009.gitcafe.io/tags/Xcode/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用Quart2D给图片添加水印以及截取圆形图片]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/06/08/quart2d/"/>
    <id>http://linfeng1009.gitcafe.io/2015/06/08/quart2d/</id>
    <published>2015-06-08T10:34:33.000Z</published>
    <updated>2015-10-19T09:05:38.000Z</updated>
    <content type="html"><![CDATA[<p>一、添加水印<br>为了不让图片被别人滥用，造成侵权，一般都会给图片加上水印。在iOS里面添加水印可以通过[CoreGraphics]框架提供的方法来操作。<br>一般思路：<br>        1.开启一个跟原图大小一致的context<br>        2.将水印文字设置添加在原图上的位置并绘制在当前的context<br>        3.从当前的context获取新的图片<br>        4.关闭当前的context<br>    代码实现：</p>
<pre><code>+ (<span class="built_in">UIImage</span> *)imageNamed:(<span class="built_in">NSString</span> *)name waterMark:(<span class="built_in">NSString</span> *)mark
{
    <span class="built_in">CGFloat</span> textWidth = <span class="number">0</span>;
    <span class="built_in">UIImage</span> *originImage = [<span class="keyword">self</span> imageNamed:name];
    textWidth = [mark boundingRectWithSize:<span class="built_in">CGSizeMake</span>(MAXFLOAT, <span class="number">20.0</span>) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> attributes:@{<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15.0</span>]} context:<span class="literal">nil</span>]<span class="variable">.size</span><span class="variable">.width</span>;
    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(originImage<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0.0</span>);
    [originImage drawAtPoint:<span class="built_in">CGPointZero</span>];
    [mark drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">10.0</span>,<span class="number">5.0</span>) withAttributes:@{<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">22.0</span>],<span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> redColor]}];
    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();
    <span class="built_in">UIGraphicsEndImageContext</span>();

    <span class="keyword">return</span> newImage;
}
</code></pre><p> 效果图片如下：<br><img src="http://7xkpsz.com1.z0.glb.clouddn.com/watermark.png" alt="水印"></p>
<p>二、截取圆形图片<br>在平常项目开发中设计会有一些圆形的图片，例如用户头像。大多会去设置View的layer的cornerRadius和masksToBounds.<br>    self.imageView.layer.cornerRadius = 50.0;<br>    self.imageView.layer.masksToBounds = YES;<br>这样做虽然能够达到我们要的效果，每一次加载都要去将视图的图层去渲染，这样严重影响性能。在项目中不推荐这样使用，有更好的方法去达到这种效果—-截图图片<br>在原图的基础上去截取一个圆形的图片，关键点就是在原图上绘制一个正切圆。<br>    代码实现：</p>
<pre><code>+ (<span class="built_in">UIImage</span> *)circleImageWithNamed:(<span class="built_in">NSString</span> *)name
{
    <span class="built_in">UIImage</span> *originImage = [<span class="keyword">self</span> imageNamed:name];
    <span class="built_in">CGFloat</span> newImageW = originImage<span class="variable">.size</span><span class="variable">.width</span> &lt; originImage<span class="variable">.size</span><span class="variable">.height</span>? originImage<span class="variable">.size</span><span class="variable">.width</span> : originImage<span class="variable">.size</span><span class="variable">.height</span>;
    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(originImage<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0.0</span>);
    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, newImageW, newImageW)];
    [path addClip];
    [originImage drawAtPoint:<span class="built_in">CGPointZero</span>];
    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();
    <span class="built_in">UIGraphicsEndImageContext</span>();

    <span class="keyword">return</span> newImage;
}
</code></pre><p> 效果图如下：<br> <img src="http://7xkpsz.com1.z0.glb.clouddn.com/circle.png" alt="截取圆图"></p>
<p> 三、绘制纯色图片<br> 在开发过程会有遇到给Button设置背景色情况，直接设置Button的backgourndcolor就没有高亮的效果，所以直接根据颜色去绘制一张纯色的图片<br>     代码实现:</p>
<pre><code> + (<span class="built_in">UIImage</span> *)imageWith<span class="built_in">UIColor</span>:(<span class="built_in">UIColor</span> *)color
{
    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>);
    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0.0</span>);
    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();
    <span class="built_in">CGContextSetFillColorWithColor</span>(context, color<span class="variable">.CGColor</span>);
    <span class="built_in">CGContextFillRect</span>(context, rect);
    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();
    <span class="built_in">UIGraphicsEndImageContext</span>();

    <span class="keyword">return</span> image;
}
</code></pre><p>GitHub: <a href="https://github.com/ludaye123/UIImage-Quartz2D" target="_blank" rel="external">https://github.com/ludaye123/UIImage-Quartz2D</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一、添加水印<br>为了不让图片被别人滥用，造成侵权，一般都会给图片加上水印。在iOS里面添加水印可以通过[CoreGraphics]框架提供的方法来操作。<br>一般思路：<br>        1.开启一个跟原图大小一致的context<br>        2.将水印]]>
    </summary>
    
      <category term="Quart2D" scheme="http://linfeng1009.gitcafe.io/tags/Quart2D/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSLog高效打印调试信息]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/05/18/nslog/"/>
    <id>http://linfeng1009.gitcafe.io/2015/05/18/nslog/</id>
    <published>2015-05-18T09:50:01.000Z</published>
    <updated>2015-10-19T09:06:42.000Z</updated>
    <content type="html"><![CDATA[<p>打印当前的方法以及行号<br>NSMutableArray *someObject = [NSMutableArray array];<br>NSLog(@”%s:%d someObject=%@”, <strong>func</strong>, <strong>LINE</strong>, someObject);<br>[someObject addObject:@”foo”];<br>NSLog(@”%s:%d someObject=%@”, <strong>func</strong>, <strong>LINE</strong>, someObject);</p>
<p>表1 预处理的宏</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>格式说明符</th>
<th>描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>func</strong></td>
<td>%s</td>
<td>当前被调用的方法 </td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td>%d</td>
<td>当前的行号在源代码文件中 </td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td>%s</td>
<td>源代码文件的路径</td>
</tr>
<tr>
<td><strong>PRETTY_FUNCTION</strong></td>
<td>%s</td>
<td>类似 <strong>func</strong>, 但是包含详细信息在C++代码中</td>
</tr>
</tbody>
</table>
<p>项目中调试一般会定义一个宏，调试打印当前的信息，特别是在比较复杂的项目中调试。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#ifdef</span> DEBUG</span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">DSLog</span><span class="params">(...)</span></span> <span class="function"><span class="title">NSLog</span><span class="params">(@<span class="string">"%s %d \n %@ \n\n"</span>,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])</span></span></span><br><span class="line"><span class="id">#else</span></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">DSLog</span><span class="params">(...)</span></span></span><br><span class="line"><span class="id">#endif</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>打印当前的方法以及行号<br>NSMutableArray *someObject = [NSMutableArray array];<br>NSLog(@”%s:%d someObject=%@”, <strong>func</strong>, <strong>LINE<]]>
    </summary>
    
      <category term="iOS" scheme="http://linfeng1009.gitcafe.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://linfeng1009.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://linfeng1009.gitcafe.io/2015/04/10/hello-world/"/>
    <id>http://linfeng1009.gitcafe.io/2015/04/10/hello-world/</id>
    <published>2015-04-10T08:22:09.000Z</published>
    <updated>2015-04-10T08:22:09.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
</feed>
